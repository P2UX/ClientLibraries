{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to the P2UX Developer Site\n\n\nWe are working on bringing more documentation and samples for developers. Check back often for updates.\n\n\nWhat's New?\n\n\nRelease \n1.1.2.71\n\n\n\n\niOS and Android now support native navigation headers, including the iOS 11 large header.\n\n\nLots of bug fixes\n\n\n\n\nMore Docs Coming Soon!\n\n\nWe are working hard to bring more documents and examples to the site. If you have any questions that aren't available in the existing docs, please contact", 
            "title": "Latest News"
        }, 
        {
            "location": "/#welcome-to-the-p2ux-developer-site", 
            "text": "We are working on bringing more documentation and samples for developers. Check back often for updates.", 
            "title": "Welcome to the P2UX Developer Site"
        }, 
        {
            "location": "/#whats-new", 
            "text": "Release  1.1.2.71   iOS and Android now support native navigation headers, including the iOS 11 large header.  Lots of bug fixes", 
            "title": "What's New?"
        }, 
        {
            "location": "/#more-docs-coming-soon", 
            "text": "We are working hard to bring more documents and examples to the site. If you have any questions that aren't available in the existing docs, please contact", 
            "title": "More Docs Coming Soon!"
        }, 
        {
            "location": "/ios/quickstart/", 
            "text": "Introduction\n\n\nWhat follows is a detailed tutorial that walks developers through all of the steps involved in creating a customizable iOS or tvOS application using P2UX. Developers should be familiar with the Xcode integrated development environment for MacOS and either the Swift or the Objective-C programming languages for custom coding.\n\n\n\n\nTerminology\n\n\nThroughout the P2UX documentation the \u201cdeveloper\u201d refers to you, the reader who is developing an app with P2UX. The \u201cdesigner\u201d refers to the individual whose principal job is to create the appearance and style of the app and its visual components. \u201cPRL\u201d refers to the P2UX Rendering Library for iOS, which controls the creation and workflow of content created for the P2UX platform.\n\n\n\n\n\n\nCoding examples and code additions\n\n\nIn the coding examples below and throughout the documentation, changes and additions to be made by the developer are rendered with a blue highlight.\n\n\n\n\nP2UX versus the standard Xcode environment\n\n\nP2UX based applications for iOS are easy to customize and extend. Since the P2UX iOS rendering library is based on the native UIKit and other iOS primitives, writing custom business logic and integrating custom controls works much the same as it does when writing iOS applications using Xcode.\nWith the P2UX platform, Storyboards and XIB based User Interface (UI) definitions are no longer required. Instead, applications use P2UX Portable UX Bundles (PUB) either as embedded or dynamically accessed resources. Additionally, P2UX provides hooks to developers that allow them access to all of the components of P2UX, as well as the ability to fully customize instances of the application.\n\n\nGetting Started with P2UX and Xcode\n\n\nObjective-C or Swift\n\n\nP2UX native rendering libraries for iOS can be extended using either Objective-C or Swift. Developers are free to choose one or the other of these coding languages at any stage during the development process. The instructions below provide explicit reference to the proper use of either language in each applicable step that follows.\n\n\nCreating a new application\n\n\nFrom the Xcode environment:\n\n\n\n\nStart the Xcode new project wizard by selecting File-\nNew-\nProject.\n\n\nFrom the new project wizard select \u201cSingle View Application\u201d as the starting point for your app.\n\n\n\nThe rest of the options in the new project wizard are dependent on your application and the selection of either Swift or Objective-C.\n\n\n\n\nConnecting the PUB. Defining assets and custom behaviors\n\n\nNow that the initial project is set up, make the necessary changes to include the PUB for the application.\n\n\n\n\nRemove the Storyboard\n\n\n\n\nWhen Xcode creates a new project, it automatically generates a blank storyboard file called \nMain.storyboard\n. Rather than using storyboards to create the UI for your app, your app will use a PUB. To accomplish this, simply remove the \nMain.storyboard\n file from your project.\n\n\nFirst, delete the file itself from your project (move to trash).\n\n\n\nNext, in \nInfo.plist\n, remove the key \nMain storyboard file base name\n.\n\n\n\n\nSelect the Info.plist file from the project navigator.\n\n\nFrom the editor on the right side, select the \nMain storyboard file base name\n row.\n\n\nDouble click on the word \nMain\n from that row to edit it and delete the text, leaving the \nValue\n field empty.\n\n\nSave the modified \nInfo.plist\n file.\n\n\n\n\n\nFinally, in the project navigator under \u201cDeployment Info,\u201d delete the text from \u201cMain Interface\u201d so that the text field is blank.\n\n\n\n\nSelect the application name from the project navigator.\n\n\nFrom the right side editor, select the application target.\n\n\nSelect the \nGeneral\n tab (shown highlighted in blue in the example screenshot)\n\n\nIn the section titled \nDeployment Info\n, select the text in the \nMain Interface\n field and delete the text, leaving the field empty.\n\n\nSave the project changes.\n\n\nNow, your app runs without a storyboard.\n\n\n\n\nEnabling P2UX iOS Frameworks\n\n\nThe next step in developing your project with P2UX is to include the P2UX frameworks for iOS. The latest frameworks can be downloaded from this site (INSERT URL ONCE AVAILABLE). Once the frameworks are downloaded:\n\n\n\n\nUnzip the framework files.\n\n\nCopy the P2UXCore.framework, P2UXApp.framework and postbuild.sh files into the root of your project directory.\n\n\nAdd the framework files to your project in Xcode.\n\n\nSelect your project in the project navigator on the left side and then click on the \nTarget\n for your project.\n\n\nSelect the \nGeneral\n tab in your project target settings.\n\n\nIn the section labeled \nEmbedded Binaries\n, click the + button, then click the \nAdd Other\u2026\n button from the drop down dialog.\n\n\n\nFind the two framework files you added to your project folder, select them and then click \nOpen\n.\n\n\n\n\n\n\nAdd \npostbuild.sh\n as a Build Phases script.\n\n\nSelect your project in the project navigator on the left side and then click on the \nTarget\n for your project.\n\n\nSelect the \nBuild Phases\n tab for your project.\n\n\nClick the + button in the Build Phases window to add a new build step and select \nNew Run Script Phase\n from the drop down menu\n\n\n\nIn the new \nRun Script\n phase, click in the shell script area and paste in the text \n./postbuild.sh\n. This assumes you copied the \npostbuild.sh\n file from the earlier step into the root of your project.\n\n\n\n\n\n\n\n\n\nRemoving unused binaries by running the\n \npostbuild.sh\n \nscript\n\n\nThe step above removes unused binaries from the P2UX frameworks for the current architecture. By default, P2UX frameworks are built as fat binaries, that is, they have compiled support (binaries) for actual iOS devices and for mac-based simulators all in the same framework bundle. This means that both Xcode simulators and real iOS devices use the same framework files when running the application.\n\n\nThe \npostbuild.sh\n script will now run at the end of the build process and remove the extra binary (depending on the target device for your build) from the framework bundled into your application. This step is required for submission of an application to iTunes.\n\n\nMoving the app from Builder to Xcode\n\n\n\n\nApp License and AppDelegate\n\n\n\n\nFirst, edit the AppDelegate files. Xcode automatically generates AppDelegate files when you create a project. These files are AppDelegate.h and AppDelegate.m if you are using Objective-C. The file is AppDelegate.swift if you are using Swift.\n\n\n(Note, additions to be made to your code are rendered here and throughout the document in blue font.)\n\n\nIf your project is written in Objective-C, edit the \nAppDelegate.h\n file to look like this:\n\n\n#import \nUIKit/UIKit.h\n\n\n@\nimport\n \nP2UXApp\n;\n\n\n@interface\n \nAppDelegate\n : \nUIResponder\n \nUIApplicationDelegate\n,\n \nP2UXAppCreatorDelegate\n\n\n@property\n \n(\nstrong\n,\n \nnonatomic\n)\n \nUIWindow\n \n*\nwindow\n;\n\n\n@end\n\n\n\n\n\n\nEdit the \nAppDelegate.m\n file to look like this:\n\n\n#import \nAppDelegate.h\n\n\n@interface\n \nAppDelegate\n \n()\n\n\n@end\n\n\n@implementation\n \nAppDelegate\n\n\n-\n \n(\nBOOL\n)\napplication:\n(\nUIApplication\n \n*\n)\napplication\n \ndidFinishLaunchingWithOptions:\n(\nNSDictionary\n \n*\n)\nlaunchOptions\n \n{\n\n\n    \nNSString\n*\n \nappKey\n \n=\n \n@\nxxxxx\n;\n\n\n    \nNSDictionary\n*\n \nopts\n;\n\n\n#if DEBUG\n\n\n    \nopts\n \n=\n \n@{\nP2UXAppCreator_Opt_Env\n:\n \nP2UXAppCreator_Opt_Env_Stage\n}\n;\n\n\n#endif\n\n\n    \n[\nP2UXAppCreator\n \ncreateApplicationWithKey\n:\nappKey\n \nopts\n:\nopts\n \nresources\n:\nnil\n \ndelegate\n:\nself\n];\n\n\n    \nreturn\n \nYES\n;\n\n\n}\n\n\n...\n\n\n@end\n\n\n\n\n\n\nIf your project is written in Swift, edit the \nAppDelegate.swift\n file to look like this:\n\n\nimport\n \nUIKit\n\n\nimport\n \nP2UXApp\n\n\n@UIApplicationMain\n\n\nclass\n \nAppDelegate\n:\n \nUIResponder\n,\n \nUIApplicationDelegate\n,\n \nP2UXAppCreatorDelegate\n \n{\n\n    \nvar\n \nwindow\n:\n \nUIWindow\n?\n\n    \nfunc\n \napplication\n(\n_\n \napplication\n:\n \nUIApplication\n,\n \ndidFinishLaunchingWithOptions\n \nlaunchOptions\n:\n \n[\nUIApplicationLaunchOptionsKey\n:\n \nAny\n]\n?\n)\n \n-\n \nBool\n \n{\n\n\n        \nlet\n \nappKey\n \n=\n \nxxxxx\n;\n\n\n        \nvar\n \nopts\n \n:\n \n[\nAnyHashable\n \n:\n \nAny\n];\n\n\n#if DEBUG\n\n\n        \nopts\n \n=\n \n[\n\n\n            \nP2UXAppCreator_Opt_Env\n:\n \nP2UXAppCreator_Opt_Env_Prototype\n]\n\n\n#endif\n\n\n        \nP2UXAppCreator\n.\ncreateApplication\n(\nwithKey\n:\n \nappKey\n,\n \nopts\n:\n \nopts\n,\n \nresources\n:\n \nnil\n,\n \ndelegate\n:\n \nself\n)\n\n\n        \nreturn\n \ntrue\n\n    \n}\n\n    \n...\n\n\n}\n\n\n\n\n\n\nThe AppDelegate calls the \nP2UXAppCreator\n method \ncreateApplication\n using the appKey, which initializes the PRL with the application information. In this example, options are supplied to the \ncreateApplication\n method to use the prototype version of the application when the application is compiled for debugging. To use the production version of the application for debugging, remove the options.\n\n\nNext, retrieve the app\u2019s license. In Builder, to the right of the publish button are further options in a drop-down menu. Select \nGet App License\n from the menu and a window will pop up with your app\u2019s license. Copy the license.\n\n\nIn AppDelegate, replace the \nxxxxx\n in the line that reads \nappKey = @\u201dxxxxx\";\n with your app\u2019s license (retrieved earlier from Builder.)\n\n\n\n\nNote\n\n\nAt this point the application setup is complete and the app should run successfully.\n\n\n\n\nThe PUB and network connectivity\n\n\nThe next step in the  process requires developer awareness of the default PUB status and access to a network.\n\n\nBy default, the application accesses the PUB dynamically. This means that when the application is first installed, the P2UX rendering library (PRL) will authenticate the application key and then download the PUB before running the application content.\n\n\nThe first run of an application requires network connectivity. Otherwise, P2UX will return an error. The PUB\u2019s default update policy is automatic. This means that the PRL will automatically check for updates each time the application runs. The library will also download any updates that are available, and then notify the user that the application will restart to apply any updates.\n\n\nStatic Assets\n\n\nIn some cases, a developer may opt to use only static assets rather than require network access for an app. In this situation, the PUB can be added to the application as a collection of static assets. To achieve this, follow these steps:\n\n\n\n\nNote\n\n\nThis feature requires downloading your application PUB from Builder. This feature will be integrated as part of the P2UX Coordinator application for Mac OS\n\n\n\n\n\n\nIn Builder, download the published PUB for application\n\n\nSteps to download PUB will go here\n\n\n\n\n\n\nUnzip the PUB files and copy the assets into a folder inside your project directory.\n\n\nIn Xcode, add the folder to the project.\n\n\nFrom the project navigator, select the group folder with your application name.\n\n\nRight click and select \nAdd Files to \u2018app name\u2019\n\n\n\n\nFrom the dialog, click the \nOptions\n button in the bottom left corner and select \nCreate folder References\n from the \nAdded folders\n option\n\n\n\nSelect the folder containing the PUB assets and click the \nAdd\n button to add them to your project.\n\n\n\n\n\n\n\n\nIn the example, this folder is called \nphone_pub\n.\n\n\nIn order to incorporate these files into your project, as well as to adjust the resource use settings, you must change the AppDelegate file.\n\n\nFor projects in Objective-C, edit the \nAppDelegate.m\n file to look like this:   \n\n\n#import \nAppDelegate.h\n\n\n#import \nSampleBehavior.h\n\n\n@interface\n \nAppDelegate\n \n()\n\n\n@end\n\n\n@implementation\n \nAppDelegate\n\n\n-\n \n(\nBOOL\n)\napplication:\n(\nUIApplication\n \n*\n)\napplication\n \ndidFinishLaunchingWithOptions:\n(\nNSDictionary\n \n*\n)\nlaunchOptions\n \n{\n\n\n    \nNSString\n*\n \nappKey\n \n=\n \n@\nxxxxx\n;\n\n    \nNSDictionary\n \n*\nopts\n;\n\n\n#if DEBUG\n\n    \nopts\n \n=\n \n@{\nP2UXAppCreator_Opt_Env\n:\n \nP2UXAppCreator_Opt_Env_Prototype\n}\n;\n\n\n#endif    \n\n\n    \nNSDictionary\n \n*\nresources\n \n=\n \n@[\n\n\n        \n@{\nP2UXApp_PackageAttrib_FormFactor\n:\n \n[\nNSNumber\n \nnumberWithInteger\n:\nP2UXFormFactor_Phone\n],\n \n\n          \nP2UXApp_PackageAttrib_Type\n:\nP2UXApp_PackageType_Static\n,\n \n\n          \nP2UXApp_PackageAttrib_Package\n:\n@\nphone_pub\n,\n\n\n          \nP2UXApp_PackageAttrib_Update\n:\nP2UXApp_PackageUpdate_None\n}]\n;\n\n\n\n    \n[\nP2UXAppCreator\n \ncreateApplicationWithKey\n:\nappKey\n \nopts\n:\nopts\n \nresources\n:\nresources\n \ndelegate\n:\nself\n];\n\n    \nreturn\n \nYES\n;\n\n\n}\n\n\n@end\n\n\n\n\n\n\nFor projects in Swift, edit the \nAppDelegate.swift\n file to look like this:\n\n\nimport\n \nUIKit\n\n\nimport\n \nP2UXApp\n\n\n@UIApplicationMain\n\n\nclass\n \nAppDelegate\n:\n \nUIResponder\n,\n \nUIApplicationDelegate\n,\n \nP2UXAppCreatorDelegate\n \n{\n\n    \nvar\n \nwindow\n:\n \nUIWindow\n?\n\n    \nfunc\n \napplication\n(\n_\n \napplication\n:\n \nUIApplication\n,\n \ndidFinishLaunchingWithOptions\n \nlaunchOptions\n:\n \n[\nUIApplicationLaunchOptionsKey\n:\n \nAny\n]\n?\n)\n \n-\n \nBool\n \n{\n\n        \nlet\n \nappKey\n \n=\n \nxxxxx\n;\n\n        \nvar\n \nopts\n \n:\n \n[\nAnyHashable\n \n:\n \nAny\n];\n\n\n#if DEBUG\n\n        \nopts\n \n=\n \n[\n\n            \nP2UXAppCreator_Opt_Env\n:\n \nP2UXAppCreator_Opt_Env_Prototype\n\n        \n]\n\n\n#endif\n\n\n        \nvar\n \nphoneResources\n:\n \n[\nAnyHashable\n \n:\n \nAny\n]\n \n=\n \n[\n\n\n            \nP2UXApp_PackageAttrib_FormFactor\n:\n \nP2UXFormFactor\n.\nphone\n,\n\n\n            \nP2UXApp_PackageAttrib_Type\n:\n \nP2UXApp_PackageType_Static\n,\n\n\n            \nP2UXApp_PackageAttrib_Package\n:\n \nphone_pub\n,\n\n\n            \nP2UXApp_PackageAttrib_Update\n:\n \nP2UXApp_PackageUpdate_None\n\n\n        \n]\n\n\n\n        \nvar\n \nresources\n \n:\n \n[\nAny\n]\n \n=\n \n[\n\n            \nphoneResources\n\n        \n]\n\n        \nP2UXAppCreator\n.\ncreateApplication\n(\nwithKey\n:\n \nappKey\n,\n \nopts\n:\n \nopts\n,\n\n        \nresources\n:\n \nresources\n,\n \ndelegate\n:\n \nself\n)\n\n        \nreturn\n \ntrue\n\n    \n}\n\n\n}\n\n\n\n\n\n\nDefining Custom Resource Attributes\n\n\nIf desired, the developer can define specific resource attributes for the app. These attributes define where the assets of the application are located and how those assets are updated.\n\n\nThe resources parameter is an array of objects. Each object in the array defines the PUB usage for a particular form factor (Phone, Tablet, TV) using key value pairs. If the application supports multiple form factors, create an object in the resources array for each form factor.\n\n\nCustomize the resource attributes according to the possibilities below:\n\n\n\n\n\n\n\n\nResource Attribute\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nP2UXApp_PackageAttrib_FormFactor\n\n\nDefines which form factor the attributes reference.\nPossible Values:\nP2UXFormFactor_Phone\nP2UXFormFactor_Tablet\nP2UXFormFactor_TV\n\n\n\n\n\n\nP2UXApp_PackageAttrib_Type\n\n\nDefines the type of resources for the form factor\nPossible Values:\nP2UXApp_PackageType_Static\nP2UXApp_PackageType_Remote\n\n\n\n\n\n\nP2UXApp_PackageAttrib_Package\n\n\nDefines the name of the folder within the application bundle containing assets when the P2UXApp_PackageAttrib_Type is P2UXApp_PackageType_Static.\n\n\n\n\n\n\nP2UXApp_PackageAttrib_Update\n\n\nDefines how to update the application assets\nPossible Values:\nP2UXApp_PackageUpdate_None\nP2UXApp_PackageUpdate_Auto\nP2UXApp_PackageUpdate_Manual\n\n\n\n\n\n\n\n\nAfter defining the resources, change the resources line in the app code from \u201cnil\u201d to \u201cresources\u201d (as highlighted in the example code above).", 
            "title": "Quick Start"
        }, 
        {
            "location": "/ios/quickstart/#introduction", 
            "text": "What follows is a detailed tutorial that walks developers through all of the steps involved in creating a customizable iOS or tvOS application using P2UX. Developers should be familiar with the Xcode integrated development environment for MacOS and either the Swift or the Objective-C programming languages for custom coding.   Terminology  Throughout the P2UX documentation the \u201cdeveloper\u201d refers to you, the reader who is developing an app with P2UX. The \u201cdesigner\u201d refers to the individual whose principal job is to create the appearance and style of the app and its visual components. \u201cPRL\u201d refers to the P2UX Rendering Library for iOS, which controls the creation and workflow of content created for the P2UX platform.    Coding examples and code additions  In the coding examples below and throughout the documentation, changes and additions to be made by the developer are rendered with a blue highlight.   P2UX versus the standard Xcode environment  P2UX based applications for iOS are easy to customize and extend. Since the P2UX iOS rendering library is based on the native UIKit and other iOS primitives, writing custom business logic and integrating custom controls works much the same as it does when writing iOS applications using Xcode.\nWith the P2UX platform, Storyboards and XIB based User Interface (UI) definitions are no longer required. Instead, applications use P2UX Portable UX Bundles (PUB) either as embedded or dynamically accessed resources. Additionally, P2UX provides hooks to developers that allow them access to all of the components of P2UX, as well as the ability to fully customize instances of the application.", 
            "title": "Introduction"
        }, 
        {
            "location": "/ios/quickstart/#getting-started-with-p2ux-and-xcode", 
            "text": "Objective-C or Swift  P2UX native rendering libraries for iOS can be extended using either Objective-C or Swift. Developers are free to choose one or the other of these coding languages at any stage during the development process. The instructions below provide explicit reference to the proper use of either language in each applicable step that follows.", 
            "title": "Getting Started with P2UX and Xcode"
        }, 
        {
            "location": "/ios/quickstart/#creating-a-new-application", 
            "text": "From the Xcode environment:   Start the Xcode new project wizard by selecting File- New- Project.  From the new project wizard select \u201cSingle View Application\u201d as the starting point for your app.  The rest of the options in the new project wizard are dependent on your application and the selection of either Swift or Objective-C.", 
            "title": "Creating a new application"
        }, 
        {
            "location": "/ios/quickstart/#connecting-the-pub-defining-assets-and-custom-behaviors", 
            "text": "Now that the initial project is set up, make the necessary changes to include the PUB for the application.   Remove the Storyboard   When Xcode creates a new project, it automatically generates a blank storyboard file called  Main.storyboard . Rather than using storyboards to create the UI for your app, your app will use a PUB. To accomplish this, simply remove the  Main.storyboard  file from your project.  First, delete the file itself from your project (move to trash).  Next, in  Info.plist , remove the key  Main storyboard file base name .   Select the Info.plist file from the project navigator.  From the editor on the right side, select the  Main storyboard file base name  row.  Double click on the word  Main  from that row to edit it and delete the text, leaving the  Value  field empty.  Save the modified  Info.plist  file.   Finally, in the project navigator under \u201cDeployment Info,\u201d delete the text from \u201cMain Interface\u201d so that the text field is blank.   Select the application name from the project navigator.  From the right side editor, select the application target.  Select the  General  tab (shown highlighted in blue in the example screenshot)  In the section titled  Deployment Info , select the text in the  Main Interface  field and delete the text, leaving the field empty.  Save the project changes. \nNow, your app runs without a storyboard.", 
            "title": "Connecting the PUB. Defining assets and custom behaviors"
        }, 
        {
            "location": "/ios/quickstart/#enabling-p2ux-ios-frameworks", 
            "text": "The next step in developing your project with P2UX is to include the P2UX frameworks for iOS. The latest frameworks can be downloaded from this site (INSERT URL ONCE AVAILABLE). Once the frameworks are downloaded:   Unzip the framework files.  Copy the P2UXCore.framework, P2UXApp.framework and postbuild.sh files into the root of your project directory.  Add the framework files to your project in Xcode.  Select your project in the project navigator on the left side and then click on the  Target  for your project.  Select the  General  tab in your project target settings.  In the section labeled  Embedded Binaries , click the + button, then click the  Add Other\u2026  button from the drop down dialog.  Find the two framework files you added to your project folder, select them and then click  Open .    Add  postbuild.sh  as a Build Phases script.  Select your project in the project navigator on the left side and then click on the  Target  for your project.  Select the  Build Phases  tab for your project.  Click the + button in the Build Phases window to add a new build step and select  New Run Script Phase  from the drop down menu  In the new  Run Script  phase, click in the shell script area and paste in the text  ./postbuild.sh . This assumes you copied the  postbuild.sh  file from the earlier step into the root of your project.     Removing unused binaries by running the   postbuild.sh   script  The step above removes unused binaries from the P2UX frameworks for the current architecture. By default, P2UX frameworks are built as fat binaries, that is, they have compiled support (binaries) for actual iOS devices and for mac-based simulators all in the same framework bundle. This means that both Xcode simulators and real iOS devices use the same framework files when running the application.  The  postbuild.sh  script will now run at the end of the build process and remove the extra binary (depending on the target device for your build) from the framework bundled into your application. This step is required for submission of an application to iTunes.", 
            "title": "Enabling P2UX iOS Frameworks"
        }, 
        {
            "location": "/ios/quickstart/#moving-the-app-from-builder-to-xcode", 
            "text": "App License and AppDelegate   First, edit the AppDelegate files. Xcode automatically generates AppDelegate files when you create a project. These files are AppDelegate.h and AppDelegate.m if you are using Objective-C. The file is AppDelegate.swift if you are using Swift.  (Note, additions to be made to your code are rendered here and throughout the document in blue font.)  If your project is written in Objective-C, edit the  AppDelegate.h  file to look like this:  #import  UIKit/UIKit.h  @ import   P2UXApp ;  @interface   AppDelegate  :  UIResponder   UIApplicationDelegate ,   P2UXAppCreatorDelegate  @property   ( strong ,   nonatomic )   UIWindow   * window ;  @end   Edit the  AppDelegate.m  file to look like this:  #import  AppDelegate.h  @interface   AppDelegate   ()  @end  @implementation   AppDelegate  -   ( BOOL ) application: ( UIApplication   * ) application   didFinishLaunchingWithOptions: ( NSDictionary   * ) launchOptions   {       NSString *   appKey   =   @ xxxxx ;       NSDictionary *   opts ;  #if DEBUG       opts   =   @{ P2UXAppCreator_Opt_Env :   P2UXAppCreator_Opt_Env_Stage } ;  #endif       [ P2UXAppCreator   createApplicationWithKey : appKey   opts : opts   resources : nil   delegate : self ];       return   YES ;  }  ...  @end   If your project is written in Swift, edit the  AppDelegate.swift  file to look like this:  import   UIKit  import   P2UXApp  @UIApplicationMain  class   AppDelegate :   UIResponder ,   UIApplicationDelegate ,   P2UXAppCreatorDelegate   { \n     var   window :   UIWindow ? \n     func   application ( _   application :   UIApplication ,   didFinishLaunchingWithOptions   launchOptions :   [ UIApplicationLaunchOptionsKey :   Any ] ? )   -   Bool   {           let   appKey   =   xxxxx ;           var   opts   :   [ AnyHashable   :   Any ];  #if DEBUG           opts   =   [               P2UXAppCreator_Opt_Env :   P2UXAppCreator_Opt_Env_Prototype ]  #endif           P2UXAppCreator . createApplication ( withKey :   appKey ,   opts :   opts ,   resources :   nil ,   delegate :   self )           return   true \n     } \n     ...  }   The AppDelegate calls the  P2UXAppCreator  method  createApplication  using the appKey, which initializes the PRL with the application information. In this example, options are supplied to the  createApplication  method to use the prototype version of the application when the application is compiled for debugging. To use the production version of the application for debugging, remove the options.  Next, retrieve the app\u2019s license. In Builder, to the right of the publish button are further options in a drop-down menu. Select  Get App License  from the menu and a window will pop up with your app\u2019s license. Copy the license. \nIn AppDelegate, replace the  xxxxx  in the line that reads  appKey = @\u201dxxxxx\";  with your app\u2019s license (retrieved earlier from Builder.)   Note  At this point the application setup is complete and the app should run successfully.", 
            "title": "Moving the app from Builder to Xcode"
        }, 
        {
            "location": "/ios/quickstart/#the-pub-and-network-connectivity", 
            "text": "The next step in the  process requires developer awareness of the default PUB status and access to a network.  By default, the application accesses the PUB dynamically. This means that when the application is first installed, the P2UX rendering library (PRL) will authenticate the application key and then download the PUB before running the application content.  The first run of an application requires network connectivity. Otherwise, P2UX will return an error. The PUB\u2019s default update policy is automatic. This means that the PRL will automatically check for updates each time the application runs. The library will also download any updates that are available, and then notify the user that the application will restart to apply any updates.", 
            "title": "The PUB and network connectivity"
        }, 
        {
            "location": "/ios/quickstart/#static-assets", 
            "text": "In some cases, a developer may opt to use only static assets rather than require network access for an app. In this situation, the PUB can be added to the application as a collection of static assets. To achieve this, follow these steps:   Note  This feature requires downloading your application PUB from Builder. This feature will be integrated as part of the P2UX Coordinator application for Mac OS    In Builder, download the published PUB for application  Steps to download PUB will go here    Unzip the PUB files and copy the assets into a folder inside your project directory.  In Xcode, add the folder to the project.  From the project navigator, select the group folder with your application name.  Right click and select  Add Files to \u2018app name\u2019   From the dialog, click the  Options  button in the bottom left corner and select  Create folder References  from the  Added folders  option  Select the folder containing the PUB assets and click the  Add  button to add them to your project.     In the example, this folder is called  phone_pub .  In order to incorporate these files into your project, as well as to adjust the resource use settings, you must change the AppDelegate file.  For projects in Objective-C, edit the  AppDelegate.m  file to look like this:     #import  AppDelegate.h  #import  SampleBehavior.h  @interface   AppDelegate   ()  @end  @implementation   AppDelegate  -   ( BOOL ) application: ( UIApplication   * ) application   didFinishLaunchingWithOptions: ( NSDictionary   * ) launchOptions   { \n\n     NSString *   appKey   =   @ xxxxx ; \n     NSDictionary   * opts ;  #if DEBUG \n     opts   =   @{ P2UXAppCreator_Opt_Env :   P2UXAppCreator_Opt_Env_Prototype } ;  #endif           NSDictionary   * resources   =   @[           @{ P2UXApp_PackageAttrib_FormFactor :   [ NSNumber   numberWithInteger : P2UXFormFactor_Phone ],              P2UXApp_PackageAttrib_Type : P2UXApp_PackageType_Static ,              P2UXApp_PackageAttrib_Package : @ phone_pub ,             P2UXApp_PackageAttrib_Update : P2UXApp_PackageUpdate_None }] ;  \n     [ P2UXAppCreator   createApplicationWithKey : appKey   opts : opts   resources : resources   delegate : self ]; \n     return   YES ;  }  @end   For projects in Swift, edit the  AppDelegate.swift  file to look like this:  import   UIKit  import   P2UXApp  @UIApplicationMain  class   AppDelegate :   UIResponder ,   UIApplicationDelegate ,   P2UXAppCreatorDelegate   { \n     var   window :   UIWindow ? \n     func   application ( _   application :   UIApplication ,   didFinishLaunchingWithOptions   launchOptions :   [ UIApplicationLaunchOptionsKey :   Any ] ? )   -   Bool   { \n         let   appKey   =   xxxxx ; \n         var   opts   :   [ AnyHashable   :   Any ];  #if DEBUG \n         opts   =   [ \n             P2UXAppCreator_Opt_Env :   P2UXAppCreator_Opt_Env_Prototype \n         ]  #endif           var   phoneResources :   [ AnyHashable   :   Any ]   =   [               P2UXApp_PackageAttrib_FormFactor :   P2UXFormFactor . phone ,               P2UXApp_PackageAttrib_Type :   P2UXApp_PackageType_Static ,               P2UXApp_PackageAttrib_Package :   phone_pub ,               P2UXApp_PackageAttrib_Update :   P2UXApp_PackageUpdate_None           ]  \n         var   resources   :   [ Any ]   =   [ \n             phoneResources \n         ] \n         P2UXAppCreator . createApplication ( withKey :   appKey ,   opts :   opts , \n         resources :   resources ,   delegate :   self ) \n         return   true \n     }  }", 
            "title": "Static Assets"
        }, 
        {
            "location": "/ios/quickstart/#defining-custom-resource-attributes", 
            "text": "If desired, the developer can define specific resource attributes for the app. These attributes define where the assets of the application are located and how those assets are updated.  The resources parameter is an array of objects. Each object in the array defines the PUB usage for a particular form factor (Phone, Tablet, TV) using key value pairs. If the application supports multiple form factors, create an object in the resources array for each form factor.  Customize the resource attributes according to the possibilities below:     Resource Attribute  Description      P2UXApp_PackageAttrib_FormFactor  Defines which form factor the attributes reference. Possible Values: P2UXFormFactor_Phone P2UXFormFactor_Tablet P2UXFormFactor_TV    P2UXApp_PackageAttrib_Type  Defines the type of resources for the form factor Possible Values: P2UXApp_PackageType_Static P2UXApp_PackageType_Remote    P2UXApp_PackageAttrib_Package  Defines the name of the folder within the application bundle containing assets when the P2UXApp_PackageAttrib_Type is P2UXApp_PackageType_Static.    P2UXApp_PackageAttrib_Update  Defines how to update the application assets Possible Values: P2UXApp_PackageUpdate_None P2UXApp_PackageUpdate_Auto P2UXApp_PackageUpdate_Manual     After defining the resources, change the resources line in the app code from \u201cnil\u201d to \u201cresources\u201d (as highlighted in the example code above).", 
            "title": "Defining Custom Resource Attributes"
        }, 
        {
            "location": "/ios/customcode/", 
            "text": "Introduction\n\n\nWhat follows is a tutorial that walks developers through the steps of writing custom code for an iOS or tvOS application using P2UX. Developers should be familiar with the Xcode integrated development environment for MacOS and either the Swift or the Objective-C programming languages for custom coding.\n\n\nTopics include customizable View Controllers, UI controls, and Screens/Panels.\n\n\n\n\nTerminology\n\n\nThroughout the P2UX documentation the \u201cdeveloper\u201d refers to you, the reader who is developing an app with P2UX. The \u201cdesigner\u201d refers to the individual whose principal job is to create the appearance and style of the app and its visual components. \u201cPRL\u201d refers to the P2UX Rendering Library for iOS, which controls the creation and workflow of content created for the P2UX platform.\n\n\n\n\n\n\nCoding examples and code additions\n\n\nIn the coding examples below and throughout the documentation, changes and additions to be made by the developer are rendered with a blue highlight.\n\n\n\n\nP2UX versus the standard Xcode environment\n\n\nP2UX based applications for iOS are easy to customize and extend. Since the P2UX iOS rendering library is based on the native UIKit and other iOS primitives, writing custom business logic and integrating custom controls works much the same as it does when writing iOS applications using Xcode.\nWith the P2UX platform, Storyboards and XIB based User Interface (UI) definitions are no longer required. Instead, applications use P2UX Portable UX Bundles (PUB) either as embedded or dynamically accessed resources. Additionally, P2UX provides hooks to developers that allow them access to all of the components of P2UX, as well as the ability to fully customize instances of the application.\n\n\n\n\nCreate a P2UX enabled project first\n\n\nThis document assumes a P2UX enabled Xcode project has already been created. See \nQuick Start\n for steps to create a project.\n\n\n\n\nP2UX and Xcode\n\n\nObjective-C or Swift\n\n\nP2UX native rendering libraries for iOS can be extended using either Objective-C or Swift. Developers are free to choose one or the other of these coding languages at any stage during the development process. The instructions below provide explicit reference to the proper use of either language in each applicable step that follows.\n\n\nAdding Custom Behaviors\n\n\nIf desired, customizable behaviors can be added to the project code.\n\n\nA subclass of the \nP2UXAppBehavior\n class is the starting point for customizing the behavior of the application. From this class, all other parts of the application can be customized. (Common customized behaviors include creation of a Custom Control or overriding a particular View Controller.)\n\n\nIn Objective-C, create a header and module file for your project to store the customized behaviors. The easiest way to do is by making a \nNew File\n in your project \u2013  a \nCocoa Touch Class\n, which in this example is called \nSampleBehavior\n.  In Xcode, create a new class from the drop down box labeled \nSubclass of:\n and enter \nP2UXAppBehavior\n in the field. \n\n\nThis will create two files: \nSampleBehavior.h\n and \nSampleBehavior.m\n.\n\n\n@\nimport\n \nP2UXApp\n;\n\n\n@interface\n \nSampleBehavior\n : \nP2UXAppBehavior\n\n\n@end\n\n\n\n\n\n\nPut any customized behaviors within the implementation here. (Behaviors available for customization are found within the P2UXApp framework, under the file \nP2UXAppBehavior\n.)\n\n\nIn addition, update \nAppDelegate.m\n to include the custom behaviors.\n\n\nTo do this, \nAppDelegate\n must include an instance of the method createBehavior from \nP2UXAppCreatorDelegate\n protocol. (This will override any default behaviors.) Also, import the \nSampleBehavior.h\n file so that this class can be instantiated.\n\n\nEdit \nAppDelegate.m\n to look like this:\n\n\n#import \nAppDelegate.h\n\n\n#import \nSampleBehavior.h\n\n\n@interface\n \nAppDelegate\n \n()\n\n\n@end\n\n\n@implementation\n \nAppDelegate\n\n\n-\n \n(\nBOOL\n)\napplication:\n(\nUIApplication\n \n*\n)\napplication\n \ndidFinishLaunchingWithOptions:\n(\nNSDictionary\n \n*\n)\nlaunchOptions\n \n{\n\n    \nNSString\n*\n \nappKey\n;\n\n    \nappKey\n \n=\n \n@\nxxxxx\n;\n\n    \nNSDictionary\n \n*\nopts\n;\n\n\n#if DEBUG\n\n    \nopts\n \n=\n \n@{\nP2UXAppCreator_Opt_Env\n:\n \nP2UXAppCreator_Opt_Env_Stage\n}\n;\n\n\n#endif    \n\n    \nNSDictionary\n \n*\nresources\n \n=\n \n@[@{\nP2UXApp_PackageAttrib_FormFactor\n:\n \n[\nNSNumber\n \nnumberWithInteger\n:\nP2UXFormFactor_Phone\n],\n \nP2UXApp_PackageAttrib_Type\n:\nP2UXApp_PackageType_Static\n,\n \nP2UXApp_PackageAttrib_Package\n:\n@\nphone_pub\n,\nP2UXApp_PackageAttrib_Update\n:\nP2UXApp_PackageUpdate_None\n}]\n;\n\n\n    \n[\nP2UXAppCreator\n \ncreateApplicationWithKey\n:\nappKey\n \nopts\n:\nopts\n \nresources\n:\nresources\n \ndelegate\n:\nself\n];\n\n    \nreturn\n \nYES\n;\n\n\n}\n\n\n\n-\n \n(\nP2UXAppBehavior\n*\n)\n \ncreateBehaviorForApplication:\n(\nNSString\n \n*\n)\nappid\n\n\n{\n\n\n    \nreturn\n \n[[\nSampleBehavior\n \nalloc\n]\n \ninit\n];\n\n\n}\n\n\n@end\n\n\n\n\n\n\nIf working in Swift, create a swift file for your project to store new behaviors.\n\n\nCreate a \nNew File\n in your project \u2013 a \nSwift File\n, in this example called \nSampleBehavior\n. In Xcode, create a new class from the drop down box labeled \nSubclass of:\n and enter \nP2UXAppBehavior\n in the field. \n\n\nEdit the \nSampleBehavior.swift\n file to look like this:\n\n\nimport\n \nUIKit\n\n\nimport\n \nP2UXApp\n\n\nclass\n \nSampleBehavior\n:\n \nP2UXAppBehavior\n \n{\n\n\n\n//\n \noverride\n \nmethods\n \nhere\n\n\n\n}\n\n\n\n\n\n\nPlace any customized behaviors within the implementation. Behaviors available for customization are found within the P2UXApp framework, under the file \nP2UXAppBehavior\n.\n\n\nNext, update \nAppDelegate.swift\n to include the custom behaviors. \n\n\nTo do this, \nAppDelegate\n must must include an instance of the method \ncreateBehavior\n from the \nP2UXAppCreatorDelegate\n protocol. (This will override any default behaviors.)\n\n\nEdit \nAppDelegate.swift\n to look like this:\n\n\nimport\n \nUIKit\n\n\nimport\n \nP2UXApp\n\n\n@UIApplicationMain\n\n\nclass\n \nAppDelegate\n:\n \nUIResponder\n,\n \nUIApplicationDelegate\n,\n \nP2UXAppCreatorDelegate\n \n{\n\n    \nvar\n \nwindow\n:\n \nUIWindow\n?\n\n    \nfunc\n \napplication\n(\n_\n \napplication\n:\n \nUIApplication\n,\n \ndidFinishLaunchingWithOptions\n \nlaunchOptions\n:\n \n[\nUIApplicationLaunchOptionsKey\n:\n \nAny\n]\n?\n)\n \n-\n \nBool\n \n{\n\n        \nlet\n \nappKey\n \n=\n \nxxxxx\n;\n\n        \nvar\n \nopts\n \n:\n \n[\nAnyHashable\n \n:\n \nAny\n];\n\n\n#if DEBUG\n\n        \nopts\n \n=\n \n[\n\n            \nP2UXAppCreator_Opt_Env\n:\n \nP2UXAppCreator_Opt_Env_Stage\n,\n\n            \nP2UXAppCreator_Opt_LogLevel\n:\n \nP2UXCoreLogLevel\n.\nverbose\n.\nrawValue\n \nas\n  \n            \nNSNumber\n\n        \n]\n\n\n#endif\n\n        \nvar\n \nphoneResources\n:\n \n[\nAnyHashable\n \n:\n \nAny\n]\n \n=\n \n[\n\n            \nP2UXApp_PackageAttrib_FormFactor\n:\n \nP2UXFormFactor\n.\nphone\n,\n\n            \nP2UXApp_PackageAttrib_Type\n:\n \nP2UXApp_PackageType_Static\n,\n\n            \nP2UXApp_PackageAttrib_Package\n:\n \nphone_pub\n,\n\n            \nP2UXApp_PackageAttrib_Update\n:\n \nP2UXApp_PackageUpdate_None\n\n        \n]\n\n\n        \nvar\n \nresources\n \n:\n \n[\nAny\n]\n \n=\n \n[\n\n            \nphoneResources\n\n        \n]\n\n        \nP2UXAppCreator\n.\ncreateApplication\n(\nwithKey\n:\n \nappKey\n,\n \nopts\n:\n \nopts\n,\n\n        \nresources\n:\n \nresources\n,\n \ndelegate\n:\n \nself\n)\n\n    \n}\n\n\n    \nfunc\n \ncreateBehavior\n(\nforApplication\n \nappid\n:\n \nString\n)\n \n-\n \nP2UXAppBehavior\n \n{\n\n\n        \nreturn\n \nSampleBehavior\n();\n\n\n    \n}\n\n\n}\n\n\n\n\n\n\nAdding Custom View Controllers\n\n\nJust like writing traditional Storyboard based iOS applications, writing custom code to interact with the User Interface is done using a subclass of \nUIViewController\n. Instead of subclassing directly from \nUIViewController\n, P2UX provides the class \nP2UXViewController\n, which itself is a subclass of \nUIViewController\n with a few added helper methods that interface with P2UX generated controls and events.\n\n\nThe \nP2UXViewController\n subclass\n\n\nSince the P2UX UI is not based on Storyboards, connecting custom methods for each button click action is unnecessary. Instead, the user can override the methods of the \nP2UXViewController\n class to handle button click and other UI events. (In all other respects, writing code for customized Screen and Panel behavior is the same as for Storyboard-based content.)\n\n\nThe name of a chosen View Controller, such as a Screen or Panel, is the value used to identify the item when the P2UX rendering library creates an instance of this object. (To create an instance of a \nP2UXViewController\n for a Screen, for example, override the \nP2UXAppBehavior\n method \ncreateViewControllerWithDef\n.) The \ndef\n parameter passed to this method contains the member variable \nsystemType\n that identifies the Screen that is being created. From this object, the developer determines the requested Screen and the specific \nP2UXViewController\n subclass to be instantiated. \n\n\nObjective-C example: creating a custom \nP2UXViewController\n\n\n#import \nSampleBehavior.h\n\n\n#import \nSampleViewController.h\n\n\n@\nimport\n \nP2UXApp\n;\n\n\n\n@implementation\n \nSampleBehavior\n\n\n\n-\n \n(\nP2UXViewController\n*\n)\n \ncreateViewControllerWithDef:\n(\nP2UXDefinition\n*\n)\ndef\n\n         \ncache:\n(\nBOOL\n)\ncache\n \nindex:\n(\nid\n)\nindex\n \ndata:\n(\nid\n)\ndata\n\n         \nviewDelegate:\n(\nid\nP2UXViewContainerDelegate\n)\nviewDelegate\n  \n{\n\n\n    \n// Determine which screen is being requested, the systemType of the P2UXDefinition class has the name of the screen as given in Builder\n\n    \nif\n \n([\ndef\n.\nsystemType\n \nisEqualToString\n:@\n\u201d\nhome\n\u201d\n])\n\n    \n{\n\n        \n// This is our custom home screen controller instance\n\n        \nreturn\n \n[[\nMyHomeController\n \nalloc\n]\n \ninitWithView\n:\ndef\n \nbehavior\n:\nself\n \ncache\n:\ncache\n \nindex\n:\nindex\n \ndata\n:\ndata\n \nviewDelegate\n:\nviewDelegate\n];\n\n    \n}\n\n    \n// Make sure to call the superclass if a instance is not created\n\n    \nreturn\n \n[\nsuper\n \ncreateViewControllerWithDef\n:\ndef\n \ncache\n:\ncache\n \nindex\n:\nindex\n \ndata\n:\ndata\n \nviewDelegate\n:\nviewDelegate\n];\n\n\n}\n\n\n@end\n\n\n\n\n\n\nSwift example: creating a custom \nP2UXViewController\n\n\noverride\n \nfunc\n \ncreateViewController\n(\nwithDef\n \ndef\n:\n \nP2UXDefinition\n!,\n \ncache\n:\n \nBool\n,\n \nindex\n:\n \nAny\n!,\n \ndata\n:\n \nAny\n!,\n \nviewDelegate\n:\n \nP2UXViewContainerDelegate\n!)\n \n-\n \nP2UXViewController\n!\n \n{\n\n\n    \n// Determine which screen is being requested, the systemType of the P2UXDefinition class has the name of the screen as given in Builder\n\n    \nif\n \ndef\n.\nsystemType\n \n==\n \nhome\n \n{\n\n        \n// This is our custom home screen controller instance\n\n        \nreturn\n \nMyHomeController\n(\nview\n:\n \ndef\n,\n \nbehavior\n:\n \nself\n,\n \ncache\n:\n \ncache\n,\n \nindex\n:\n \nindex\n,\n \ndata\n:\n \ndata\n,\n \nviewDelegate\n:\n \nviewDelegate\n)\n\n    \n}\n        \n    \n// Make sure to call the superclass if a instance is not created\n\n    \nreturn\n \nsuper\n.\ncreateViewController\n(\nwithDef\n:\n \ndef\n,\n \ncache\n:\n \ncache\n,\n \nindex\n:\n \nindex\n,\n \ndata\n:\n \ndata\n,\n \nviewDelegate\n:\n \nviewDelegate\n);\n\n\n}\n\n\n\n\n\n\nThe \nP2UXViewController\n view instance managed by your controller is created automatically based on the \nP2UXDefinition\n.\n\n\nJust as Screens can have custom \nUIViewController\n instances to override their behavior, so too can Panels. The \nUIViewController\n based subclass \nP2UXPanelController\n manages Panel instances. To create a custom \nP2UXPanelController\n instance, override the \nP2UXAppBehavior\n method \ncreatePanelControllerWithDef\n and return an instance of a \nP2UXPanelController\n subclass.\n\n\nObjective-C example: creating a custom P2UXPanelController\n\n\n-\n \n(\nP2UXViewController\n*\n)\n \ncreatePanelControllerWithDef:\n(\nP2UXDefinition\n*\n)\ndef\n\n      \ncache:\n(\nBOOL\n)\ncache\n \nindex:\n(\nid\n)\nindex\n \ndata:\n(\nid\n)\ndata\n\n      \nviewDelegate:\n(\nid\nP2UXViewContainerDelegate\n)\nviewDelegate\n \n{\n\n\n   \n// Determine which screen is being requested, the systemType of the P2UXDefinition class has the name of the screen as given in Builder\n\n   \nif\n \n([\ndef\n.\nsystemType\n \nisEqualToString\n:@\n\u201d\nuserprofile\n\u201d\n])\n \n{\n\n      \n// This is our custom panel controller instance\n\n      \nreturn\n \n[[\nUserProfilePanelController\n \nalloc\n]\n \ninitWithView\n:\ndef\n \nbehavior\n:\nself\n \ncache\n:\ncache\n \nindex\n:\nindex\n \ndata\n:\ndata\n \nviewDelegate\n:\nviewDelegate\n];\n\n   \n}\n\n   \n// Make sure to call the superclass if a instance is not created\n\n   \nreturn\n \n[\nsuper\n \ncreatePanelControllerWithDef\n:\ndef\n \ncache\n:\ncache\n \n      \nindex\n:\nindex\n \ndata\n:\ndata\n \nviewDelegate\n:\nviewDelegate\n];\n\n\n}\n\n\n\n\n\n\nSwift example: creating a custom P2UXPanelController\n\n\noverride\n \nfunc\n \ncreatePanelController\n(\nwithDef\n \ndef\n:\n \nP2UXDefinition\n!,\n \n      \ncache\n:\n \nBool\n,\n \nindex\n:\n \nAny\n!,\n \ndata\n:\n \nAny\n!,\n \n      \nviewDelegate\n:\n \nP2UXViewContainerDelegate\n!)\n \n-\n \nP2UXViewController\n!\n \n{\n\n\n   \n// Determine which screen is being requested, the systemType of the\n\n   \n// P2UXDefinition class has the name of the screen as given in Builder\n\n   \nif\n \ndef\n.\nsystemType\n \n==\n \nuserprofile\n \n{\n\n       \n// This is our custom panel controller instance\n\n       \nreturn\n \nUserProfilePanelController\n(\nview\n:\n \ndef\n,\n \nbehavior\n:\n \nself\n,\n \ncache\n:\n \ncache\n,\n \nindex\n:\n \nindex\n,\n \ndata\n:\n \ndata\n,\n \nviewDelegate\n:\n \nviewDelegate\n)\n\n   \n}\n\n\n   \nreturn\n \nsuper\n.\ncreatePanelController\n(\nwithDef\n:\n \ndef\n,\n \ncache\n:\n \ncache\n,\n \nindex\n:\n \nindex\n,\n \ndata\n:\n \ndata\n,\n \nviewDelegate\n:\n \nviewDelegate\n);\n\n\n}\n\n\n\n\n\n\nAccessing Control Instances from \nP2UXViewController\n\n\nTo access instances of controls, \nP2UXViewController\n provides a helper method, \ncontrolWithElementSystemTypeOrId\n. This method takes the name or ID of the desired control and returns access to the control instance.\n\n\nUpon creating a new control, such as a new Button, Builder assigns it a \u201csystem type.\u201d (Builder generates the system type from the designer\u2019s name for the Button.) Later, the designer might decide to create an alternative variation of the Button. To prevent altering any existing controls, the developer should refer to the new version of the Button by its system type to eliminate overwriting or rewriting any code.\n\n\nObjective-C example: accessing a control in a \nP2UXViewController\n\n\n-(\nvoid\n)\n \nviewDidLoad\n \n{\n\n   \n[\nsuper\n \nviewDidLoad\n];\n\n\n   \nUIButton\n*\n \nbtn\n \n=\n \n(\nUIButton\n*\n)[\nself\n \ncontrolWithElementSystemTypeOrId\n:@\n\u201d\nshow\n \nbtn\n\u201d\n];\n\n   \nif\n \n(\nbtn\n \n!=\n \nnil\n)\n \n{\n\n      \nbtn\n.\nenabled\n \n=\n \nNO\n;\n\n   \n}\n\n\n}\n\n\n\n\n\n\nSwift example: accessing a control in a \nP2UXViewController\n\n\noverride\n \nfunc\n \nviewDidLoad\n()\n \n{\n\n   \nsuper\n.\nviewDidLoad\n()\n\n\n   \nif\n \nlet\n \nbtn\n \n=\n \nself\n.\ncontrol\n(\nwithElementSystemTypeOrId\n:\n \nshow btn\n)\n \nas\n?\n \nUIButton\n \n{\n\n      \nbtn\n.\nisEnabled\n \n=\n \nfalse\n;\n\n   \n}\n\n\n}\n\n\n\n\n\n\nHandling Events from P2UXViewController\n\n\nEnd-users of a completed app will interact with controls in a Screen or Panel to generate events. These interactions will, in turn, trigger actions. Typically the PRL handles events directly through event interactions set up in Builder. In some cases, additional custom code may be needed to trigger actions not directly supported by P2UX.\n\n\nThe PRL provides a chain of event handlers that propagate an event through different components. Handling events at any point in the propagation chain provides a way to trigger custom code and also (optionally) to stop the propagation of the event at any specific handler.\n\n\nEvent propagation follows a set pattern.\n\n\nFirst, events are relayed to the \nP2UXViewController\n for the current Screen or Panel. Next, they pass to \nP2UXAppBehavior\n. Finally, events are handled by the custom instance of the \nUIView\n itself. If none of these components halt event propagation, the PRL will then handle any interactions defined for the event in Builder.\n\n\nThe \nP2UXViewController\n contains helper methods that handle a variety of events when they occur. These methods give the developer a chance to integrate any custom code needed from the basic event level without triggering any custom actions.\n\n\nMost standard control events are routed through the \nP2UXViewController\n instance. Handling these events is a matter of overriding the appropriate event method in your \nP2UXViewController\n subclass. Event propagation can be allowed to continue or not depending on the return value from the event handler methods.\n\n\nObjective-C example: handling a Button press event in \nP2UXViewController\n subclass\n\n\n-\n \n(\nBOOL\n)\n \nhandleButtonClick:\n(\nid\n)\nsender\n \nelement:\n(\nP2UXElementInstance\n \n*\n)\nelement\n \n{\n\n    \nif\n \n([\nelement\n.\nsystemType\n \nisEqualToString\n:\n@\nokbtn\n])\n \n{\n\n        \n// take some custom action here for the \nokbtn\n\n\n        \n// return YES to indicate the event was handled and propagation \n\n        \n// shouldn\nt continue\n\n        \nreturn\n \nYES\n;\n\n    \n}\n\n    \nreturn\n \nNO\n;\n\n\n}\n\n\n\n\n\n\nSwift example: handling a Button press event in \nP2UXViewController\n subclass\n\n\noverride\n \nfunc\n \nhandleButtonClick\n(\n_\n \nsender\n:\n \nAny\n!,\n \nelement\n:\n \nP2UXElementInstance\n!)\n \n-\n \nBool\n \n{\n\n    \nif\n \nelement\n.\nsystemType\n \n==\n \nokbtn\n \n{\n\n        \n// take some custom action here for the \nokbtn\n\n\n        \n// return true to indicate the event was handled and propagation \n\n        \n// shouldn\nt continue\n\n        \nreturn\n \ntrue\n;\n\n    \n}\n\n    \nreturn\n \nfalse\n;\n\n\n}\n\n\n\n\n\n\nAdding Custom UI Controls\n\n\nUI Controls are the visual components of a Screen or Panel created in the Builder tool. These can be interactive, like Buttons or Sliders, or non-interactive, like Shapes or Text. Although P2UX offers many different UI Controls directly creatable and usable in Builder, a specific application may require developer-defined UI controls. Builder provides a Custom Control component that can be added to a Screen or Panel and then replaced using custom code.\n\n\nAny \nUIView\n based control can be injected into your Screens and Panels via a Custom Control. This allows for existing custom controls or third party custom controls to be used with your P2UX based applications.\n\n\nThe PRL manages the size and position of any custom controls defined using Builder. To provide an instance of a custom control, override the method \ncreateControlWithType\n in your \nP2UXAppBehavior\n subclass and return the \nUIView\n subclassed instance of your control. The first parameter passed to this method, type, is the name of the control set when you created the custom control in Builder. P2UX will pass you the initial size to use with your Custom Control as well as a few other components that can be used to access any custom information created with your control in Builder.\n\n\nThe \nelementInstance\n parameter contains all the parameters specified using Builder for the control via its \nitemSpec\n member. Even though the parent \nUIView\n is passed to the create method, you should not add the instance of your \nUIView\n control to the parent as this is managed by P2UX when you return the instance of the control.\n\n\nObjective-C example: creating a custom control in \nP2UXAppBehavior\n subclass:\n\n\n-\n \n(\nUIView\n*\n)\n \ncreateControlWithType:\n(\nNSString\n \n*\n)\ntype\n \nelementInstance:\n(\nP2UXElementInstance\n \n*\n)\nelementInstance\n \nframe:\n(\nCGRect\n)\nframe\n \nviewDelegate:\n(\nid\nP2UXViewContainerDelegate\n)\nviewDelegate\n \nindex:\n(\nid\n)\nindex\n \ndata:\n(\nid\n)\ndata\n \nparent:\n(\nUIView\n \n*\n)\nparent\n \n{\n\n\n    \nif\n \n([\ntype\n \nisEqualToString\n:\n@\ngraphcontrol\n])\n \n{\n\n\n        \nCustomGraph\n*\n \ngraph\n \n=\n \n[[\nCustomGraph\n \nalloc\n]\n \ninitWithFrame\n:\nframe\n];\n\n        \nNSDictionary\n*\n \ngraphOpts\n \n=\n \n[\nelementInstance\n.\nitemSpec\n \nobjectForKey\n:\n@\ngraphopts\n];\n\n        \nif\n \n(\ngraphOpts\n \n!=\n \nnil\n)\n \n{\n\n            \n// handle extra parameters here, for this example we defined an object\n\n            \n// in the itemspec of the control\n\n            \n// in Builder named \ngraphopts\n which has information specific to \n\n            \n// our graph object\n\n            \ngraph\n.\nopts\n \n=\n \ngraphOpts\n;\n\n        \n}\n\n        \nreturn\n \ngraph\n;\n\n    \n}\n\n    \nreturn\n \n[\nsuper\n \ncreateControlWithType\n:\ntype\n \nelementInstance\n:\nelementInstance\n \nframe\n:\nframe\n \nviewDelegate\n:\nviewDelegate\n \nindex\n:\nindex\n \ndata\n:\ndata\n \nparent\n:\nparent\n];\n\n\n}\n\n\n\n\n\n\nSwift example: creating a custom control in \nP2UXAppBehavior\n subclass:\n\n\noverride\n \nfunc\n \ncreateControl\n(\nwithType\n \ntype\n:\n \nString\n!,\n \nelementInstance\n:\n \nP2UXElementInstance\n!,\n \nframe\n:\n \nCGRect\n,\n \nviewDelegate\n:\n \nP2UXViewContainerDelegate\n!,\n \nindex\n:\n \nAny\n!,\n \ndata\n:\n \nAny\n!,\n \nparent\n:\n \nUIView\n!)\n \n-\n \nUIView\n!\n \n{\n\n\n    \nif\n \ntype\n \n==\n \ngraphcontrol\n \n{\n\n        \nlet\n \ngraph\n \n:\n \nCustomGraph\n \n=\n \nCustomGraph\n(\nframe\n:\n \nframe\n);\n\n        \nif\n \nlet\n \ngraphOpts\n \n=\n \nelementInstance\n.\nitemSpec\n[\ngraphopts\n]\n \nas\n?\n \nNSDictionary\n \n{\n\n            \n// handle extra parameters here, for this example we defined an object \n\n            \n// in the itemspec of the control\n\n            \n// in Builder named \ngraphopts\n which has information specific to \n\n            \n// our graph object\n\n            \ngraph\n.\nopts\n \n=\n \ngraphOpts\n;\n\n        \n}\n\n        \nreturn\n \ngraph\n;\n\n    \n}\n\n    \nreturn\n \nsuper\n.\ncreateControl\n(\nwithType\n:\n \ntype\n,\n \nelementInstance\n:\n \nelementInstance\n,\n \nframe\n:\n \nframe\n,\n \nviewDelegate\n:\n \nviewDelegate\n,\n \nindex\n:\n \nindex\n,\n \ndata\n:\n \ndata\n,\n \nparent\n:\n \nparent\n);\n\n\n}\n\n\n\n\n\n\nAdding Custom Screens/Panels\n\n\nIn addition to using a \nUIViewController\n based class to override behavior for an application Screen or Panel, the actual Screen or Panel instance can also be overridden to provide any custom code needed for the hosted \nUIView\n itself.\n\n\nP2UX will request an instance from \nP2UXAppBehavior\n when the Screen or Panel is created. If no instance is provided, P2UX will generate a standard instance of the Screen or Panel.\n\n\nTo provide a custom Screen instance, override the method \ncreateScreenWithDef\n from a \nP2UXAppBehavior\n subclass and return an instance of \nP2UXScreen\n. To provide a custom Panel instance, override the method \ncreatePanelWithDef\n and return an instance of \nP2UXPanel\n. (Both \nP2UXScreen\n and \nP2UXPanel\n are \nUIView\n based subclasses that add some additional helper methods. These methods make it easier to access screen components.)\n\n\nObjective-C example: creating a custom Screen or Panel instance in P2UXAppBehavior subclass\n\n\n// For custom Screen instances\n\n\n-(\nP2UXScreen\n*\n)\n \ncreateScreenWithDef:\n(\nP2UXDefinition\n \n*\n)\ndef\n \nrect:\n(\nCGRect\n)\nrect\n \nindex:\n(\nid\n)\nindex\n \ndata:\n(\nid\n)\ndata\n \nviewDelegate:\n(\nid\nP2UXViewContainerDelegate\n)\nviewDelegate\n \n{\n\n\n    \n// If the screen \u201csystemType\u201d matches the name of the screen, return\n\n    \n// the custom screen instance\n\n    \nif\n \n([\ndef\n.\nsystemType\n \nisEqualToString\n:\n@\nhome\n])\n \n{\n\n        \n// Here we return an instance of HomeScreen which is a \n\n        \n// subclass of P2UXScreen\n\n        \nreturn\n \n[[\nHomeScreen\n \nalloc\n]\n \ninitWithFrame\n:\nrect\n \ncontents\n:\ndef\n \nviewDelegate\n:\nviewDelegate\n \nindex\n:\nindex\n \ndata\n:\ndata\n];\n\n    \n}\n\n    \nreturn\n \n[\nsuper\n \ncreateScreenWithDef\n:\ndef\n \nrect\n:\nrect\n \nindex\n:\nindex\n \ndata\n:\ndata\n \nviewDelegate\n:\nviewDelegate\n];\n\n\n}\n\n\n\n// For custom panel instances\n\n\n-\n \n(\nP2UXPanel\n*\n)\n \ncreatePanelWithDef:\n(\nP2UXDefinition\n \n*\n)\ndef\n \nrect:\n(\nCGRect\n)\nrect\n \nindex:\n(\nid\n)\nindex\n \ndata:\n(\nid\n)\ndata\n \nviewDelegate:\n(\nid\nP2UXViewContainerDelegate\n)\nviewDelegate\n \n{\n\n\n    \n// if this is the userinfo panel, return the custom UserInfoPanel instance\n\n    \nif\n \n([\ndef\n.\nsystemType\n \nisEqualToString\n:\n@\nuserinfo\n])\n \n{\n\n        \nreturn\n \n[[\nUserInfoPanel\n \nalloc\n]\n \ninitWithFrame\n:\nrect\n \ncontents\n:\ndef\n \nviewDelegate\n:\nviewDelegate\n \nindex\n:\nindex\n \ndata\n:\ndata\n];\n\n    \n}\n\n    \nreturn\n \n[\nsuper\n \ncreatePanelWithDef\n:\ndef\n \nrect\n:\nrect\n \nindex\n:\nindex\n \ndata\n:\ndata\n \nviewDelegate\n:\nviewDelegate\n];\n\n\n}\n\n\n\n\n\n\nSwift example: creating a custom Screen or Panel instance in \nP2UXAppBehavior\n subclass\n\n\n// For custom Screen instances\n\n\noverride\n \nfunc\n \ncreateScreen\n(\nwithDef\n \ndef\n:\n \nP2UXDefinition\n!,\n \nrect\n:\n \nCGRect\n,\n \nindex\n:\n \nAny\n!,\n \ndata\n:\n \nAny\n!,\n \nviewDelegate\n:\n \nP2UXViewContainerDelegate\n!)\n \n-\n \nP2UXScreen\n!\n \n{\n\n\n    \n// If the screen \u201csystemType\u201d matches the name of the screen, return\n\n    \n// the custom screen instance.\n\n    \nif\n \ndef\n.\nsystemType\n \n==\n \nhome\n \n{\n   \n       \n// Here we return an instance of HomeScreen which is a \n\n       \n// subclass of P2UXScreen\n\n       \nreturn\n \nHomeScreen\n(\nframe\n:\n \nrect\n,\n \ncontents\n:\n \ndef\n,\n \nviewDelegate\n:\n \nviewDelegate\n,\n \nindex\n:\n \nindex\n,\n \ndata\n:\n \ndata\n);\n\n    \n}\n\n    \nreturn\n \nsuper\n.\ncreateScreen\n(\nwithDef\n:\n \ndef\n,\n \nrect\n:\n \nrect\n,\n \nindex\n:\n \nindex\n,\n \ndata\n:\n \ndata\n,\n \nviewDelegate\n:\n \nviewDelegate\n);\n\n\n}\n\n\n\n// For custom panel instances\n\n\noverride\n \nfunc\n \ncreatePanel\n(\nwithDef\n \ndef\n:\n \nP2UXDefinition\n!,\n \nrect\n:\n \nCGRect\n,\n \nindex\n:\n \nAny\n!,\n \ndata\n:\n \nAny\n!,\n \nviewDelegate\n:\n \nP2UXViewContainerDelegate\n!)\n \n-\n \nP2UXPanel\n!\n \n{\n\n\n    \n// If the panel \u201csystemType\u201d matches the name of the screen, return\n\n    \n// the custom panel instance.\n\n    \nif\n \ndef\n.\nsystemType\n \n==\n \nuserinfo\n \n{\n\n           \n// Here we return an instance of HomeScreen which is a \n\n           \n// subclass of P2UXScreen\n\n           \nreturn\n \nUserInfoPanel\n(\nframe\n:\n \nrect\n,\n \ncontents\n:\n \ndef\n,\n \nviewDelegate\n:\n \nviewDelegate\n,\n \nindex\n:\n \nindex\n,\n \ndata\n:\n \ndata\n);\n\n    \n}\n\n    \nreturn\n \nsuper\n.\ncreatePanel\n(\nwithDef\n:\n \ndef\n,\n \nrect\n:\n \nrect\n,\n \nindex\n:\n \nindex\n,\n \ndata\n:\n \ndata\n,\n \nviewDelegate\n:\n \nviewDelegate\n);\n\n\n}", 
            "title": "Custom Code"
        }, 
        {
            "location": "/ios/customcode/#introduction", 
            "text": "What follows is a tutorial that walks developers through the steps of writing custom code for an iOS or tvOS application using P2UX. Developers should be familiar with the Xcode integrated development environment for MacOS and either the Swift or the Objective-C programming languages for custom coding.  Topics include customizable View Controllers, UI controls, and Screens/Panels.   Terminology  Throughout the P2UX documentation the \u201cdeveloper\u201d refers to you, the reader who is developing an app with P2UX. The \u201cdesigner\u201d refers to the individual whose principal job is to create the appearance and style of the app and its visual components. \u201cPRL\u201d refers to the P2UX Rendering Library for iOS, which controls the creation and workflow of content created for the P2UX platform.    Coding examples and code additions  In the coding examples below and throughout the documentation, changes and additions to be made by the developer are rendered with a blue highlight.   P2UX versus the standard Xcode environment  P2UX based applications for iOS are easy to customize and extend. Since the P2UX iOS rendering library is based on the native UIKit and other iOS primitives, writing custom business logic and integrating custom controls works much the same as it does when writing iOS applications using Xcode.\nWith the P2UX platform, Storyboards and XIB based User Interface (UI) definitions are no longer required. Instead, applications use P2UX Portable UX Bundles (PUB) either as embedded or dynamically accessed resources. Additionally, P2UX provides hooks to developers that allow them access to all of the components of P2UX, as well as the ability to fully customize instances of the application.   Create a P2UX enabled project first  This document assumes a P2UX enabled Xcode project has already been created. See  Quick Start  for steps to create a project.", 
            "title": "Introduction"
        }, 
        {
            "location": "/ios/customcode/#p2ux-and-xcode", 
            "text": "Objective-C or Swift  P2UX native rendering libraries for iOS can be extended using either Objective-C or Swift. Developers are free to choose one or the other of these coding languages at any stage during the development process. The instructions below provide explicit reference to the proper use of either language in each applicable step that follows.", 
            "title": "P2UX and Xcode"
        }, 
        {
            "location": "/ios/customcode/#adding-custom-behaviors", 
            "text": "If desired, customizable behaviors can be added to the project code.  A subclass of the  P2UXAppBehavior  class is the starting point for customizing the behavior of the application. From this class, all other parts of the application can be customized. (Common customized behaviors include creation of a Custom Control or overriding a particular View Controller.)  In Objective-C, create a header and module file for your project to store the customized behaviors. The easiest way to do is by making a  New File  in your project \u2013  a  Cocoa Touch Class , which in this example is called  SampleBehavior .  In Xcode, create a new class from the drop down box labeled  Subclass of:  and enter  P2UXAppBehavior  in the field.  \nThis will create two files:  SampleBehavior.h  and  SampleBehavior.m .  @ import   P2UXApp ;  @interface   SampleBehavior  :  P2UXAppBehavior  @end   Put any customized behaviors within the implementation here. (Behaviors available for customization are found within the P2UXApp framework, under the file  P2UXAppBehavior .)  In addition, update  AppDelegate.m  to include the custom behaviors.  To do this,  AppDelegate  must include an instance of the method createBehavior from  P2UXAppCreatorDelegate  protocol. (This will override any default behaviors.) Also, import the  SampleBehavior.h  file so that this class can be instantiated.  Edit  AppDelegate.m  to look like this:  #import  AppDelegate.h  #import  SampleBehavior.h  @interface   AppDelegate   ()  @end  @implementation   AppDelegate  -   ( BOOL ) application: ( UIApplication   * ) application   didFinishLaunchingWithOptions: ( NSDictionary   * ) launchOptions   { \n     NSString *   appKey ; \n     appKey   =   @ xxxxx ; \n     NSDictionary   * opts ;  #if DEBUG \n     opts   =   @{ P2UXAppCreator_Opt_Env :   P2UXAppCreator_Opt_Env_Stage } ;  #endif     \n     NSDictionary   * resources   =   @[@{ P2UXApp_PackageAttrib_FormFactor :   [ NSNumber   numberWithInteger : P2UXFormFactor_Phone ],   P2UXApp_PackageAttrib_Type : P2UXApp_PackageType_Static ,   P2UXApp_PackageAttrib_Package : @ phone_pub , P2UXApp_PackageAttrib_Update : P2UXApp_PackageUpdate_None }] ; \n\n     [ P2UXAppCreator   createApplicationWithKey : appKey   opts : opts   resources : resources   delegate : self ]; \n     return   YES ;  }  -   ( P2UXAppBehavior * )   createBehaviorForApplication: ( NSString   * ) appid  {       return   [[ SampleBehavior   alloc ]   init ];  }  @end   If working in Swift, create a swift file for your project to store new behaviors.  Create a  New File  in your project \u2013 a  Swift File , in this example called  SampleBehavior . In Xcode, create a new class from the drop down box labeled  Subclass of:  and enter  P2UXAppBehavior  in the field.   Edit the  SampleBehavior.swift  file to look like this:  import   UIKit  import   P2UXApp  class   SampleBehavior :   P2UXAppBehavior   {  //   override   methods   here  }   Place any customized behaviors within the implementation. Behaviors available for customization are found within the P2UXApp framework, under the file  P2UXAppBehavior .  Next, update  AppDelegate.swift  to include the custom behaviors.   To do this,  AppDelegate  must must include an instance of the method  createBehavior  from the  P2UXAppCreatorDelegate  protocol. (This will override any default behaviors.)  Edit  AppDelegate.swift  to look like this:  import   UIKit  import   P2UXApp  @UIApplicationMain  class   AppDelegate :   UIResponder ,   UIApplicationDelegate ,   P2UXAppCreatorDelegate   { \n     var   window :   UIWindow ? \n     func   application ( _   application :   UIApplication ,   didFinishLaunchingWithOptions   launchOptions :   [ UIApplicationLaunchOptionsKey :   Any ] ? )   -   Bool   { \n         let   appKey   =   xxxxx ; \n         var   opts   :   [ AnyHashable   :   Any ];  #if DEBUG \n         opts   =   [ \n             P2UXAppCreator_Opt_Env :   P2UXAppCreator_Opt_Env_Stage , \n             P2UXAppCreator_Opt_LogLevel :   P2UXCoreLogLevel . verbose . rawValue   as   \n             NSNumber \n         ]  #endif \n         var   phoneResources :   [ AnyHashable   :   Any ]   =   [ \n             P2UXApp_PackageAttrib_FormFactor :   P2UXFormFactor . phone , \n             P2UXApp_PackageAttrib_Type :   P2UXApp_PackageType_Static , \n             P2UXApp_PackageAttrib_Package :   phone_pub , \n             P2UXApp_PackageAttrib_Update :   P2UXApp_PackageUpdate_None \n         ] \n\n         var   resources   :   [ Any ]   =   [ \n             phoneResources \n         ] \n         P2UXAppCreator . createApplication ( withKey :   appKey ,   opts :   opts , \n         resources :   resources ,   delegate :   self ) \n     }       func   createBehavior ( forApplication   appid :   String )   -   P2UXAppBehavior   {           return   SampleBehavior ();       }  }", 
            "title": "Adding Custom Behaviors"
        }, 
        {
            "location": "/ios/customcode/#adding-custom-view-controllers", 
            "text": "Just like writing traditional Storyboard based iOS applications, writing custom code to interact with the User Interface is done using a subclass of  UIViewController . Instead of subclassing directly from  UIViewController , P2UX provides the class  P2UXViewController , which itself is a subclass of  UIViewController  with a few added helper methods that interface with P2UX generated controls and events.  The  P2UXViewController  subclass  Since the P2UX UI is not based on Storyboards, connecting custom methods for each button click action is unnecessary. Instead, the user can override the methods of the  P2UXViewController  class to handle button click and other UI events. (In all other respects, writing code for customized Screen and Panel behavior is the same as for Storyboard-based content.)  The name of a chosen View Controller, such as a Screen or Panel, is the value used to identify the item when the P2UX rendering library creates an instance of this object. (To create an instance of a  P2UXViewController  for a Screen, for example, override the  P2UXAppBehavior  method  createViewControllerWithDef .) The  def  parameter passed to this method contains the member variable  systemType  that identifies the Screen that is being created. From this object, the developer determines the requested Screen and the specific  P2UXViewController  subclass to be instantiated.   Objective-C example: creating a custom  P2UXViewController  #import  SampleBehavior.h  #import  SampleViewController.h  @ import   P2UXApp ;  @implementation   SampleBehavior  -   ( P2UXViewController * )   createViewControllerWithDef: ( P2UXDefinition * ) def \n          cache: ( BOOL ) cache   index: ( id ) index   data: ( id ) data \n          viewDelegate: ( id P2UXViewContainerDelegate ) viewDelegate    { \n\n     // Determine which screen is being requested, the systemType of the P2UXDefinition class has the name of the screen as given in Builder \n     if   ([ def . systemType   isEqualToString :@ \u201d home \u201d ]) \n     { \n         // This is our custom home screen controller instance \n         return   [[ MyHomeController   alloc ]   initWithView : def   behavior : self   cache : cache   index : index   data : data   viewDelegate : viewDelegate ]; \n     } \n     // Make sure to call the superclass if a instance is not created \n     return   [ super   createViewControllerWithDef : def   cache : cache   index : index   data : data   viewDelegate : viewDelegate ];  }  @end   Swift example: creating a custom  P2UXViewController  override   func   createViewController ( withDef   def :   P2UXDefinition !,   cache :   Bool ,   index :   Any !,   data :   Any !,   viewDelegate :   P2UXViewContainerDelegate !)   -   P2UXViewController !   { \n\n     // Determine which screen is being requested, the systemType of the P2UXDefinition class has the name of the screen as given in Builder \n     if   def . systemType   ==   home   { \n         // This is our custom home screen controller instance \n         return   MyHomeController ( view :   def ,   behavior :   self ,   cache :   cache ,   index :   index ,   data :   data ,   viewDelegate :   viewDelegate ) \n     }         \n     // Make sure to call the superclass if a instance is not created \n     return   super . createViewController ( withDef :   def ,   cache :   cache ,   index :   index ,   data :   data ,   viewDelegate :   viewDelegate );  }   The  P2UXViewController  view instance managed by your controller is created automatically based on the  P2UXDefinition .  Just as Screens can have custom  UIViewController  instances to override their behavior, so too can Panels. The  UIViewController  based subclass  P2UXPanelController  manages Panel instances. To create a custom  P2UXPanelController  instance, override the  P2UXAppBehavior  method  createPanelControllerWithDef  and return an instance of a  P2UXPanelController  subclass.  Objective-C example: creating a custom P2UXPanelController  -   ( P2UXViewController * )   createPanelControllerWithDef: ( P2UXDefinition * ) def \n       cache: ( BOOL ) cache   index: ( id ) index   data: ( id ) data \n       viewDelegate: ( id P2UXViewContainerDelegate ) viewDelegate   { \n\n    // Determine which screen is being requested, the systemType of the P2UXDefinition class has the name of the screen as given in Builder \n    if   ([ def . systemType   isEqualToString :@ \u201d userprofile \u201d ])   { \n       // This is our custom panel controller instance \n       return   [[ UserProfilePanelController   alloc ]   initWithView : def   behavior : self   cache : cache   index : index   data : data   viewDelegate : viewDelegate ]; \n    } \n    // Make sure to call the superclass if a instance is not created \n    return   [ super   createPanelControllerWithDef : def   cache : cache  \n       index : index   data : data   viewDelegate : viewDelegate ];  }   Swift example: creating a custom P2UXPanelController  override   func   createPanelController ( withDef   def :   P2UXDefinition !,  \n       cache :   Bool ,   index :   Any !,   data :   Any !,  \n       viewDelegate :   P2UXViewContainerDelegate !)   -   P2UXViewController !   { \n\n    // Determine which screen is being requested, the systemType of the \n    // P2UXDefinition class has the name of the screen as given in Builder \n    if   def . systemType   ==   userprofile   { \n        // This is our custom panel controller instance \n        return   UserProfilePanelController ( view :   def ,   behavior :   self ,   cache :   cache ,   index :   index ,   data :   data ,   viewDelegate :   viewDelegate ) \n    } \n\n    return   super . createPanelController ( withDef :   def ,   cache :   cache ,   index :   index ,   data :   data ,   viewDelegate :   viewDelegate );  }", 
            "title": "Adding Custom View Controllers"
        }, 
        {
            "location": "/ios/customcode/#accessing-control-instances-from-p2uxviewcontroller", 
            "text": "To access instances of controls,  P2UXViewController  provides a helper method,  controlWithElementSystemTypeOrId . This method takes the name or ID of the desired control and returns access to the control instance.  Upon creating a new control, such as a new Button, Builder assigns it a \u201csystem type.\u201d (Builder generates the system type from the designer\u2019s name for the Button.) Later, the designer might decide to create an alternative variation of the Button. To prevent altering any existing controls, the developer should refer to the new version of the Button by its system type to eliminate overwriting or rewriting any code.  Objective-C example: accessing a control in a  P2UXViewController  -( void )   viewDidLoad   { \n    [ super   viewDidLoad ]; \n\n    UIButton *   btn   =   ( UIButton * )[ self   controlWithElementSystemTypeOrId :@ \u201d show   btn \u201d ]; \n    if   ( btn   !=   nil )   { \n       btn . enabled   =   NO ; \n    }  }   Swift example: accessing a control in a  P2UXViewController  override   func   viewDidLoad ()   { \n    super . viewDidLoad () \n\n    if   let   btn   =   self . control ( withElementSystemTypeOrId :   show btn )   as ?   UIButton   { \n       btn . isEnabled   =   false ; \n    }  }", 
            "title": "Accessing Control Instances from P2UXViewController"
        }, 
        {
            "location": "/ios/customcode/#handling-events-from-p2uxviewcontroller", 
            "text": "End-users of a completed app will interact with controls in a Screen or Panel to generate events. These interactions will, in turn, trigger actions. Typically the PRL handles events directly through event interactions set up in Builder. In some cases, additional custom code may be needed to trigger actions not directly supported by P2UX.  The PRL provides a chain of event handlers that propagate an event through different components. Handling events at any point in the propagation chain provides a way to trigger custom code and also (optionally) to stop the propagation of the event at any specific handler.  Event propagation follows a set pattern.  First, events are relayed to the  P2UXViewController  for the current Screen or Panel. Next, they pass to  P2UXAppBehavior . Finally, events are handled by the custom instance of the  UIView  itself. If none of these components halt event propagation, the PRL will then handle any interactions defined for the event in Builder.  The  P2UXViewController  contains helper methods that handle a variety of events when they occur. These methods give the developer a chance to integrate any custom code needed from the basic event level without triggering any custom actions.  Most standard control events are routed through the  P2UXViewController  instance. Handling these events is a matter of overriding the appropriate event method in your  P2UXViewController  subclass. Event propagation can be allowed to continue or not depending on the return value from the event handler methods.  Objective-C example: handling a Button press event in  P2UXViewController  subclass  -   ( BOOL )   handleButtonClick: ( id ) sender   element: ( P2UXElementInstance   * ) element   { \n     if   ([ element . systemType   isEqualToString : @ okbtn ])   { \n         // take some custom action here for the  okbtn \n\n         // return YES to indicate the event was handled and propagation  \n         // shouldn t continue \n         return   YES ; \n     } \n     return   NO ;  }   Swift example: handling a Button press event in  P2UXViewController  subclass  override   func   handleButtonClick ( _   sender :   Any !,   element :   P2UXElementInstance !)   -   Bool   { \n     if   element . systemType   ==   okbtn   { \n         // take some custom action here for the  okbtn \n\n         // return true to indicate the event was handled and propagation  \n         // shouldn t continue \n         return   true ; \n     } \n     return   false ;  }", 
            "title": "Handling Events from P2UXViewController"
        }, 
        {
            "location": "/ios/customcode/#adding-custom-ui-controls", 
            "text": "UI Controls are the visual components of a Screen or Panel created in the Builder tool. These can be interactive, like Buttons or Sliders, or non-interactive, like Shapes or Text. Although P2UX offers many different UI Controls directly creatable and usable in Builder, a specific application may require developer-defined UI controls. Builder provides a Custom Control component that can be added to a Screen or Panel and then replaced using custom code.  Any  UIView  based control can be injected into your Screens and Panels via a Custom Control. This allows for existing custom controls or third party custom controls to be used with your P2UX based applications.  The PRL manages the size and position of any custom controls defined using Builder. To provide an instance of a custom control, override the method  createControlWithType  in your  P2UXAppBehavior  subclass and return the  UIView  subclassed instance of your control. The first parameter passed to this method, type, is the name of the control set when you created the custom control in Builder. P2UX will pass you the initial size to use with your Custom Control as well as a few other components that can be used to access any custom information created with your control in Builder.  The  elementInstance  parameter contains all the parameters specified using Builder for the control via its  itemSpec  member. Even though the parent  UIView  is passed to the create method, you should not add the instance of your  UIView  control to the parent as this is managed by P2UX when you return the instance of the control.  Objective-C example: creating a custom control in  P2UXAppBehavior  subclass:  -   ( UIView * )   createControlWithType: ( NSString   * ) type   elementInstance: ( P2UXElementInstance   * ) elementInstance   frame: ( CGRect ) frame   viewDelegate: ( id P2UXViewContainerDelegate ) viewDelegate   index: ( id ) index   data: ( id ) data   parent: ( UIView   * ) parent   { \n\n     if   ([ type   isEqualToString : @ graphcontrol ])   { \n\n         CustomGraph *   graph   =   [[ CustomGraph   alloc ]   initWithFrame : frame ]; \n         NSDictionary *   graphOpts   =   [ elementInstance . itemSpec   objectForKey : @ graphopts ]; \n         if   ( graphOpts   !=   nil )   { \n             // handle extra parameters here, for this example we defined an object \n             // in the itemspec of the control \n             // in Builder named  graphopts  which has information specific to  \n             // our graph object \n             graph . opts   =   graphOpts ; \n         } \n         return   graph ; \n     } \n     return   [ super   createControlWithType : type   elementInstance : elementInstance   frame : frame   viewDelegate : viewDelegate   index : index   data : data   parent : parent ];  }   Swift example: creating a custom control in  P2UXAppBehavior  subclass:  override   func   createControl ( withType   type :   String !,   elementInstance :   P2UXElementInstance !,   frame :   CGRect ,   viewDelegate :   P2UXViewContainerDelegate !,   index :   Any !,   data :   Any !,   parent :   UIView !)   -   UIView !   { \n\n     if   type   ==   graphcontrol   { \n         let   graph   :   CustomGraph   =   CustomGraph ( frame :   frame ); \n         if   let   graphOpts   =   elementInstance . itemSpec [ graphopts ]   as ?   NSDictionary   { \n             // handle extra parameters here, for this example we defined an object  \n             // in the itemspec of the control \n             // in Builder named  graphopts  which has information specific to  \n             // our graph object \n             graph . opts   =   graphOpts ; \n         } \n         return   graph ; \n     } \n     return   super . createControl ( withType :   type ,   elementInstance :   elementInstance ,   frame :   frame ,   viewDelegate :   viewDelegate ,   index :   index ,   data :   data ,   parent :   parent );  }", 
            "title": "Adding Custom UI Controls"
        }, 
        {
            "location": "/ios/customcode/#adding-custom-screenspanels", 
            "text": "In addition to using a  UIViewController  based class to override behavior for an application Screen or Panel, the actual Screen or Panel instance can also be overridden to provide any custom code needed for the hosted  UIView  itself.  P2UX will request an instance from  P2UXAppBehavior  when the Screen or Panel is created. If no instance is provided, P2UX will generate a standard instance of the Screen or Panel.  To provide a custom Screen instance, override the method  createScreenWithDef  from a  P2UXAppBehavior  subclass and return an instance of  P2UXScreen . To provide a custom Panel instance, override the method  createPanelWithDef  and return an instance of  P2UXPanel . (Both  P2UXScreen  and  P2UXPanel  are  UIView  based subclasses that add some additional helper methods. These methods make it easier to access screen components.)  Objective-C example: creating a custom Screen or Panel instance in P2UXAppBehavior subclass  // For custom Screen instances  -( P2UXScreen * )   createScreenWithDef: ( P2UXDefinition   * ) def   rect: ( CGRect ) rect   index: ( id ) index   data: ( id ) data   viewDelegate: ( id P2UXViewContainerDelegate ) viewDelegate   { \n\n     // If the screen \u201csystemType\u201d matches the name of the screen, return \n     // the custom screen instance \n     if   ([ def . systemType   isEqualToString : @ home ])   { \n         // Here we return an instance of HomeScreen which is a  \n         // subclass of P2UXScreen \n         return   [[ HomeScreen   alloc ]   initWithFrame : rect   contents : def   viewDelegate : viewDelegate   index : index   data : data ]; \n     } \n     return   [ super   createScreenWithDef : def   rect : rect   index : index   data : data   viewDelegate : viewDelegate ];  }  // For custom panel instances  -   ( P2UXPanel * )   createPanelWithDef: ( P2UXDefinition   * ) def   rect: ( CGRect ) rect   index: ( id ) index   data: ( id ) data   viewDelegate: ( id P2UXViewContainerDelegate ) viewDelegate   { \n\n     // if this is the userinfo panel, return the custom UserInfoPanel instance \n     if   ([ def . systemType   isEqualToString : @ userinfo ])   { \n         return   [[ UserInfoPanel   alloc ]   initWithFrame : rect   contents : def   viewDelegate : viewDelegate   index : index   data : data ]; \n     } \n     return   [ super   createPanelWithDef : def   rect : rect   index : index   data : data   viewDelegate : viewDelegate ];  }   Swift example: creating a custom Screen or Panel instance in  P2UXAppBehavior  subclass  // For custom Screen instances  override   func   createScreen ( withDef   def :   P2UXDefinition !,   rect :   CGRect ,   index :   Any !,   data :   Any !,   viewDelegate :   P2UXViewContainerDelegate !)   -   P2UXScreen !   { \n\n     // If the screen \u201csystemType\u201d matches the name of the screen, return \n     // the custom screen instance. \n     if   def . systemType   ==   home   {    \n        // Here we return an instance of HomeScreen which is a  \n        // subclass of P2UXScreen \n        return   HomeScreen ( frame :   rect ,   contents :   def ,   viewDelegate :   viewDelegate ,   index :   index ,   data :   data ); \n     } \n     return   super . createScreen ( withDef :   def ,   rect :   rect ,   index :   index ,   data :   data ,   viewDelegate :   viewDelegate );  }  // For custom panel instances  override   func   createPanel ( withDef   def :   P2UXDefinition !,   rect :   CGRect ,   index :   Any !,   data :   Any !,   viewDelegate :   P2UXViewContainerDelegate !)   -   P2UXPanel !   { \n\n     // If the panel \u201csystemType\u201d matches the name of the screen, return \n     // the custom panel instance. \n     if   def . systemType   ==   userinfo   { \n            // Here we return an instance of HomeScreen which is a  \n            // subclass of P2UXScreen \n            return   UserInfoPanel ( frame :   rect ,   contents :   def ,   viewDelegate :   viewDelegate ,   index :   index ,   data :   data ); \n     } \n     return   super . createPanel ( withDef :   def ,   rect :   rect ,   index :   index ,   data :   data ,   viewDelegate :   viewDelegate );  }", 
            "title": "Adding Custom Screens/Panels"
        }, 
        {
            "location": "/android/quickstart/", 
            "text": "Introduction\n\n\nWhat follows is a detailed tutorial that walks developers through all of the steps involved in creating a customizable Android application using P2UX. Developers should be familiar with the Android Studio integrated development environment and the Java programming language for custom coding.\n\n\n\n\nTerminology\n\n\nThroughout the P2UX documentation the \u201cdeveloper\u201d refers to you, the reader who is developing an app with P2UX. The \u201cdesigner\u201d refers to the individual whose principal job is to create the appearance and style of the app and its visual components. \u201cPRL\u201d refers to the P2UX Rendering Library for Android, which controls the creation and workflow of content created for the P2UX platform.\n\n\n\n\n\n\nCoding examples and code additions\n\n\nIn the coding examples below and throughout the documentation, changes and additions to be made by the developer are rendered with a blue highlight.\n\n\n\n\nP2UX versus the standard Android Studio environment\n\n\nP2UX based applications are easy to customize and extend for Android. The P2UX Android rendering library is based on the Android Widget package (android.widget) and other Android primitives. This means that writing custom business logic and integrating custom controls works much the same as it does when writing Android applications using Android Studio.\nWith the P2UX platform, XML Layout files are no longer required for Android development. Instead, applications use P2UX Portable UX Bundles (PUB) either as embedded or dynamically accessed resources. Additionally, P2UX provides hooks to developers that allow them access to all of the components of P2UX as well as the ability to fully customize instances of the application.\n\n\nGetting Started with P2UX and Android Studio\n\n\nJava\n\n\nP2UX native rendering libraries for Android can be extended using the Java programming language. The instructions below provide explicit reference to the proper use of Java coding in each applicable step that follows.\n\n\nCreating a new application\n\n\nFrom Android Studio environment:\n\n\n\n\nStart the Android Studio new project wizard either from the Welcome to Android Studio screen by clicking \u2018Start a new Android Studio project\u2019 or by selecting File-\nNew-\nNew Project.\n\n\nFrom the new project wizard enter your application name, company domain, and project location.\n\n\n\nIn the Target Android Devices window, set the minimum SDK to API 18: Android 4.3 (Jelly Bean).\n\n\nIn the Add an Activity to Mobile window, select the Empty Activity.\n\n\nIn the Customize the Activity window, uncheck the \u2018Generate Layout File\u2019 option.\n\n\n\n\nP2UX libraries download and PUB hook up\n\n\nThe next step in developing your project with P2UX is to include the P2UX libraries (AAR) for Android. The latest libraries can be downloaded from here. After downloading the libraries, make the following changes to hook up the PUB for the application:\n\n\n\n\nUnzip the library file.\n\n\nCreate a subdirectory under the root of your project directory, i.e. \u2018p2ux\u2019\n\n\nCopy P2UXCore.aar and P2UXApp.aar files into the subdirectory, \u2018p2ux\u2019.\n\n\nEdit the app\u2019s build.gradle (Module: app) to look like this:\n\n\n\n\napply plugin: \ncom.android.application\n\n\nandroid {\n   compileSdkVersion 25\n   buildToolsVersion \n26.0.0\n\n   defaultConfig {\n       applicationId \ncom.p2ux.sampleapp\n\n       minSdkVersion 18\n       targetSdkVersion 25\n       versionCode 1\n       versionName \n1.0\n\n       multiDexEnabled true\n   }\n   buildTypes {\n       release {\n           minifyEnabled false\n           proguardFiles getDefaultProguardFile(\nproguard-android.txt\n), \nproguard-rules.pro\n\n       }\n   }\n}\n\nrepositories {\n   mavenCentral()\n\n   flatDir { dirs \n../p2ux\n }   // Replace this directory with the location of P2UX libraries\n\n}\n\ndependencies {\n   compile fileTree(dir: \nlibs\n, include: [\n*.jar\n])\n   compile \ncom.android.support:appcompat-v7:25.3.1\n\n\n\n   compile(name: \nP2UXCore\n, ext: \naar\n)\n\n   compile(name: \nP2UXApp\n, ext: \naar\n)\n\n   compile \ncom.android.support:recyclerview-v7:25.3.1\n\n\n   // If Google Maps are required for your app, add the following 4 Google Play \n   // Services dependencies\n\n   compile \ncom.google.android.gms:play-services-maps:10.2.1\n\n\n   compile \ncom.google.android.gms:play-services-ads:10.2.1\n\n\n   compile \ncom.google.android.gms:play-services-identity:10.2.1\n\n\n   compile \ncom.google.android.gms:play-services-gcm:10.2.1\n\n\n   compile \ncom.madgag.spongycastle:core:1.54.0.0\n\n\n   compile \ncom.madgag.spongycastle:prov:1.54.0.0\n\n\n}\n\n\n\n\n\nMoving the app from Builder to Android Studio\n\n\n\n\nApp License and Android App Activity class\n\n\n\n\nAndroid Studio automatically generates an app activity class when you create a project. Unless you rename the file, the app activity file is named \nMainActivity\n. \nEdit the \nMainActivity\n file to look like this:\n\n\nimport\n \nandroid.os.Bundle\n;\n\n\n\nimport\n \ncom.p2ux.app.P2UXAppCreator\n;\n\n\nimport\n \ncom.p2ux.app.P2UXAppFragmentActivity\n;\n\n\nimport\n \ncom.p2ux.app.components.P2UXAppBehavior\n;\n\n\nimport\n \ncom.p2ux.core.utils.P2UXLog\n;\n\n\n\n\npublic\n \nclass\n \nMainActivity\n \nextends\n \nP2UXAppFragmentActivity\n\n\n{\n\n   \n@Override\n\n   \npublic\n \nvoid\n \nonCreate\n(\nBundle\n \nsavedInstanceState\n)\n\n   \n{\n\n       \n//You can get the app key or license key from builder for your app. This is required to link your builder up to your local app\n\n       \n// This is the key generated from Builder for the application. This key is needed to initialize the P2UX rendering framework.\n\n\n       \nmAppKey\n \n=\n \nxxxxxx\n;\n  \n\n       \nif\n \n((\ngetApplicationInfo\n().\nflags\n \n \nApplicationInfo\n.\nFLAG_DEBUGGABLE\n)\n \n==\n \nApplicationInfo\n.\nFLAG_DEBUGGABLE\n)\n \n{\n\n\n           \nif\n \n(\nsavedInstanceState\n \n==\n \nnull\n)\n \n{\n\n\n               \nsavedInstanceState\n \n=\n \nnew\n \nBundle\n();\n\n\n           \n}\n\n\n           \nsavedInstanceState\n.\nputString\n(\nP2UXAppCreator\n.\nP2UXAppCreator_Opt_Env\n,\n \nP2UXAppCreator\n.\nP2UXAppCreator_Opt_Env_Prototype\n);\n\n\n           \nsavedInstanceState\n.\nputLong\n(\nP2UXAppCreator\n.\nP2UXAppCreator_Opt_LogLevel\n,\n \nP2UXLog\n.\nP2UXCoreLogFlagVerbose\n);\n\n\n       \n}\n\n\n       \nsuper\n.\nonCreate\n(\nsavedInstanceState\n);\n\n       \napplyTranslucentStatusBar\n();\n\n   \n}\n\n\n}\n\n\n\n\n\n\nNext, retrieve the app\u2019s license. In Builder, to the right of the publish button are further options in a drop-down menu. Select \n\u201cGet App License\u201d\n from the menu and a window will pop up with your app\u2019s license. Copy the license. The \nMainActivity\n calls the super.OnCreate() with the \nmAppKey\n. This initializes the PRL with the application information. In this example, options supplied to the savedInstanceState variable use the prototype version of the application when the application is compiled for debugging. To use the production version of the application, remove the section that checks for \nFLAG_DEBUGGABLE\n.\n\n\n\nIn \nMainActivity\n, replace the \n\u201cxxxxxx\u201d\n in the line that reads \n\u201cmAppKey = \u201cxxxxxx\u201d;\n with the app\u2019s license you just retrieved from Builder to finalize the initial app setup in P2UX.\n\n\n\n\nNote\n\n\nAt this point the application setup is complete and the app should run successfully.\n\n\n\n\nThe PUB and network connectivity\n\n\nThe next step in the process requires developer awareness of the default PUB status and access to a network.\n\n\nBy default, the application accesses the PUB dynamically. This means that when the application is first installed, the P2UX rendering library (PRL) will authenticate the application key and then download the PUB before running the application content.\n\n\nThe first run of an application requires network connectivity. Otherwise, P2UX will return an error. The PUB\u2019s default update policy is automatic. This means that the PRL will automatically check for updates each time the application runs. The library will also download any updates that are available, and then notify the user that the application will restart to apply any updates.\n\n\nStatic Assets\n\n\nIn some cases, a developer may opt to use only static assets rather than require network access for an app. In this situation, the PUB can be added to the application as a collection of static assets. Additionally, other static assets usable by the app can be added to an Android project. To achieve this, follow these steps:\n\n\n\n\nNote\n\n\nThis feature requires downloading your application PUB from Builder. This feature will be integrated as part of the P2UX Coordinator application for Mac OS\n\n\n\n\n\n\nIn Builder, download the published PUB for application\n\n\nSteps to download PUB will go here\n\n\n\n\n\n\nUnzip the PUB files and copy the assets into a folder inside your project directory.\n\n\nIn Android Studio, add the assets folder to the project.\n\n\nFrom the Android project navigator, select the app module folder.\n\n\nRight click and select \nNew-\nFolder-\nAssets\n Folder.\n\n\n\nFrom the \nConfigure Component\n dialog, click \nFinish\n. This creates a folder named \nassets\n under your app main folder.\n\n\n\nRename the folder containing the PUB assets to something more readable such as \nphone_pub\n.\n\n\nMove the \u2018phone_pub\u2019 folder to the \u2018assets\u2019 folder.\n\n\n\n\n\n\n\n\nIn order to incorporate these files into your project, as well as to adjust the resource use settings, you must change the Activity file. Edit the \nMainActivity\n file to look like this:\n\n\n@Override\n\n\npublic\n \nvoid\n \nonCreate\n(\nBundle\n \nsavedInstanceState\n)\n\n\n{\n\n   \nmAppKey\n \n=\n \nxxxxx\n;\n\n\n\n   \ntry\n \n{\n\n\n       \nmResources\n \n=\n \nnew\n \nJSONArray\n();\n\n\n       \nJSONObject\n \nresource\n \n=\n \nnew\n \nJSONObject\n();\n\n\n       \nresource\n.\nput\n(\nP2UXAppTypes\n.\nP2UXApp_PackageAttrib_FormFactor\n,\n \n0\n);\n\n\n       \nresource\n.\nput\n(\nP2UXAppTypes\n.\nP2UXApp_PackageAttrib_Type\n,\n \nP2UXAppTypes\n.\nP2UXApp_PackageType_Static\n);\n\n\n       \nresource\n.\nput\n(\nP2UXAppTypes\n.\nP2UXApp_PackageAttrib_Package\n,\n \nphone_pub\n);\n\n\n       \nresource\n.\nput\n(\nP2UXAppTypes\n.\nP2UXApp_PackageAttrib_Update\n,\n \nP2UXAppTypes\n.\nP2UXApp_PackageUpdate_None\n);\n\n\n       \nmResources\n.\nput\n(\nresource\n);\n\n\n   \n}\n\n\n   \ncatch\n \n(\nJSONException\n \ne\n)\n\n\n   \n{\n\n\n       \nP2UXLog\n.\ne\n(\nTAG\n,\n \nonCreate - \n \n+\n \ne\n.\ngetMessage\n());\n\n\n   \n}\n\n\n\n   \nif\n \n((\ngetApplicationInfo\n().\nflags\n \n \nApplicationInfo\n.\nFLAG_DEBUGGABLE\n)\n \n==\n \nApplicationInfo\n.\nFLAG_DEBUGGABLE\n)\n \n{\n\n       \nif\n \n(\nsavedInstanceState\n \n==\n \nnull\n)\n \n{\n\n           \nsavedInstanceState\n \n=\n \nnew\n \nBundle\n();\n\n       \n}\n\n       \nsavedInstanceState\n.\nputString\n(\nP2UXAppCreator\n.\nP2UXAppCreator_Opt_Env\n,\n \nP2UXAppCreator\n.\nP2UXAppCreator_Opt_Env_Prototype\n);\n\n       \nsavedInstanceState\n.\nputLong\n(\nP2UXAppCreator\n.\nP2UXAppCreator_Opt_LogLevel\n,\n \nP2UXLog\n.\nP2UXCoreLogFlagVerbose\n);\n\n   \n}\n\n\n   \nsuper\n.\nonCreate\n(\nsavedInstanceState\n);\n\n   \napplyTranslucentStatusBar\n();\n\n\n}\n\n\n\n\n\n\nDefining Custom Resource Attributes\n\n\nIf desired, the developer can define specific resource attributes for the app.\n\n\nThe resources parameter is an array of objects. Each object in the array defines the PUB usage for a particular form factor (Phone, Tablet, TV) using key value pairs. If the application supports multiple form factors, create an object in the resources array for each form factor.\n\n\nCustomize the resource attributes according to the possibilities below:\n\n\n\n\n\n\n\n\nResource Attribute\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nP2UXApp_PackageAttrib_FormFactor\n\n\nDefines which form factor the attributes reference.\nPossible Values:\nP2UXFormFactor_Phone\nP2UXFormFactor_Tablet\nP2UXFormFactor_TV\n\n\n\n\n\n\nP2UXApp_PackageAttrib_Type\n\n\nDefines the type of resources for the form factor\nPossible Values:\nP2UXApp_PackageType_Static\nP2UXApp_PackageType_Remote\n\n\n\n\n\n\nP2UXApp_PackageAttrib_Package\n\n\nDefines the name of the folder within the application bundle containing assets when the P2UXApp_PackageAttrib_Type is P2UXApp_PackageType_Static.\n\n\n\n\n\n\nP2UXApp_PackageAttrib_Update\n\n\nDefines how to update the application assets\nPossible Values:\nP2UXApp_PackageUpdate_None\nP2UXApp_PackageUpdate_Auto\nP2UXApp_PackageUpdate_Manual", 
            "title": "Quick Start"
        }, 
        {
            "location": "/android/quickstart/#introduction", 
            "text": "What follows is a detailed tutorial that walks developers through all of the steps involved in creating a customizable Android application using P2UX. Developers should be familiar with the Android Studio integrated development environment and the Java programming language for custom coding.   Terminology  Throughout the P2UX documentation the \u201cdeveloper\u201d refers to you, the reader who is developing an app with P2UX. The \u201cdesigner\u201d refers to the individual whose principal job is to create the appearance and style of the app and its visual components. \u201cPRL\u201d refers to the P2UX Rendering Library for Android, which controls the creation and workflow of content created for the P2UX platform.    Coding examples and code additions  In the coding examples below and throughout the documentation, changes and additions to be made by the developer are rendered with a blue highlight.   P2UX versus the standard Android Studio environment  P2UX based applications are easy to customize and extend for Android. The P2UX Android rendering library is based on the Android Widget package (android.widget) and other Android primitives. This means that writing custom business logic and integrating custom controls works much the same as it does when writing Android applications using Android Studio.\nWith the P2UX platform, XML Layout files are no longer required for Android development. Instead, applications use P2UX Portable UX Bundles (PUB) either as embedded or dynamically accessed resources. Additionally, P2UX provides hooks to developers that allow them access to all of the components of P2UX as well as the ability to fully customize instances of the application.", 
            "title": "Introduction"
        }, 
        {
            "location": "/android/quickstart/#getting-started-with-p2ux-and-android-studio", 
            "text": "Java  P2UX native rendering libraries for Android can be extended using the Java programming language. The instructions below provide explicit reference to the proper use of Java coding in each applicable step that follows.", 
            "title": "Getting Started with P2UX and Android Studio"
        }, 
        {
            "location": "/android/quickstart/#creating-a-new-application", 
            "text": "From Android Studio environment:   Start the Android Studio new project wizard either from the Welcome to Android Studio screen by clicking \u2018Start a new Android Studio project\u2019 or by selecting File- New- New Project.  From the new project wizard enter your application name, company domain, and project location.  In the Target Android Devices window, set the minimum SDK to API 18: Android 4.3 (Jelly Bean).  In the Add an Activity to Mobile window, select the Empty Activity.  In the Customize the Activity window, uncheck the \u2018Generate Layout File\u2019 option.", 
            "title": "Creating a new application"
        }, 
        {
            "location": "/android/quickstart/#p2ux-libraries-download-and-pub-hook-up", 
            "text": "The next step in developing your project with P2UX is to include the P2UX libraries (AAR) for Android. The latest libraries can be downloaded from here. After downloading the libraries, make the following changes to hook up the PUB for the application:   Unzip the library file.  Create a subdirectory under the root of your project directory, i.e. \u2018p2ux\u2019  Copy P2UXCore.aar and P2UXApp.aar files into the subdirectory, \u2018p2ux\u2019.  Edit the app\u2019s build.gradle (Module: app) to look like this:   apply plugin:  com.android.application \n\nandroid {\n   compileSdkVersion 25\n   buildToolsVersion  26.0.0 \n   defaultConfig {\n       applicationId  com.p2ux.sampleapp \n       minSdkVersion 18\n       targetSdkVersion 25\n       versionCode 1\n       versionName  1.0 \n       multiDexEnabled true\n   }\n   buildTypes {\n       release {\n           minifyEnabled false\n           proguardFiles getDefaultProguardFile( proguard-android.txt ),  proguard-rules.pro \n       }\n   }\n}\n\nrepositories {\n   mavenCentral()    flatDir { dirs  ../p2ux  }   // Replace this directory with the location of P2UX libraries }\n\ndependencies {\n   compile fileTree(dir:  libs , include: [ *.jar ])\n   compile  com.android.support:appcompat-v7:25.3.1     compile(name:  P2UXCore , ext:  aar )    compile(name:  P2UXApp , ext:  aar )    compile  com.android.support:recyclerview-v7:25.3.1     // If Google Maps are required for your app, add the following 4 Google Play \n   // Services dependencies    compile  com.google.android.gms:play-services-maps:10.2.1     compile  com.google.android.gms:play-services-ads:10.2.1     compile  com.google.android.gms:play-services-identity:10.2.1     compile  com.google.android.gms:play-services-gcm:10.2.1     compile  com.madgag.spongycastle:core:1.54.0.0     compile  com.madgag.spongycastle:prov:1.54.0.0  }", 
            "title": "P2UX libraries download and PUB hook up"
        }, 
        {
            "location": "/android/quickstart/#moving-the-app-from-builder-to-android-studio", 
            "text": "App License and Android App Activity class   Android Studio automatically generates an app activity class when you create a project. Unless you rename the file, the app activity file is named  MainActivity . \nEdit the  MainActivity  file to look like this:  import   android.os.Bundle ;  import   com.p2ux.app.P2UXAppCreator ;  import   com.p2ux.app.P2UXAppFragmentActivity ;  import   com.p2ux.app.components.P2UXAppBehavior ;  import   com.p2ux.core.utils.P2UXLog ;   public   class   MainActivity   extends   P2UXAppFragmentActivity  { \n    @Override \n    public   void   onCreate ( Bundle   savedInstanceState ) \n    { \n        //You can get the app key or license key from builder for your app. This is required to link your builder up to your local app \n        // This is the key generated from Builder for the application. This key is needed to initialize the P2UX rendering framework.          mAppKey   =   xxxxxx ;            if   (( getApplicationInfo (). flags     ApplicationInfo . FLAG_DEBUGGABLE )   ==   ApplicationInfo . FLAG_DEBUGGABLE )   {              if   ( savedInstanceState   ==   null )   {                  savedInstanceState   =   new   Bundle ();              }              savedInstanceState . putString ( P2UXAppCreator . P2UXAppCreator_Opt_Env ,   P2UXAppCreator . P2UXAppCreator_Opt_Env_Prototype );              savedInstanceState . putLong ( P2UXAppCreator . P2UXAppCreator_Opt_LogLevel ,   P2UXLog . P2UXCoreLogFlagVerbose );          }          super . onCreate ( savedInstanceState ); \n        applyTranslucentStatusBar (); \n    }  }   Next, retrieve the app\u2019s license. In Builder, to the right of the publish button are further options in a drop-down menu. Select  \u201cGet App License\u201d  from the menu and a window will pop up with your app\u2019s license. Copy the license. The  MainActivity  calls the super.OnCreate() with the  mAppKey . This initializes the PRL with the application information. In this example, options supplied to the savedInstanceState variable use the prototype version of the application when the application is compiled for debugging. To use the production version of the application, remove the section that checks for  FLAG_DEBUGGABLE .  In  MainActivity , replace the  \u201cxxxxxx\u201d  in the line that reads  \u201cmAppKey = \u201cxxxxxx\u201d;  with the app\u2019s license you just retrieved from Builder to finalize the initial app setup in P2UX.   Note  At this point the application setup is complete and the app should run successfully.", 
            "title": "Moving the app from Builder to Android Studio"
        }, 
        {
            "location": "/android/quickstart/#the-pub-and-network-connectivity", 
            "text": "The next step in the process requires developer awareness of the default PUB status and access to a network.  By default, the application accesses the PUB dynamically. This means that when the application is first installed, the P2UX rendering library (PRL) will authenticate the application key and then download the PUB before running the application content.  The first run of an application requires network connectivity. Otherwise, P2UX will return an error. The PUB\u2019s default update policy is automatic. This means that the PRL will automatically check for updates each time the application runs. The library will also download any updates that are available, and then notify the user that the application will restart to apply any updates.", 
            "title": "The PUB and network connectivity"
        }, 
        {
            "location": "/android/quickstart/#static-assets", 
            "text": "In some cases, a developer may opt to use only static assets rather than require network access for an app. In this situation, the PUB can be added to the application as a collection of static assets. Additionally, other static assets usable by the app can be added to an Android project. To achieve this, follow these steps:   Note  This feature requires downloading your application PUB from Builder. This feature will be integrated as part of the P2UX Coordinator application for Mac OS    In Builder, download the published PUB for application  Steps to download PUB will go here    Unzip the PUB files and copy the assets into a folder inside your project directory.  In Android Studio, add the assets folder to the project.  From the Android project navigator, select the app module folder.  Right click and select  New- Folder- Assets  Folder.  From the  Configure Component  dialog, click  Finish . This creates a folder named  assets  under your app main folder.  Rename the folder containing the PUB assets to something more readable such as  phone_pub .  Move the \u2018phone_pub\u2019 folder to the \u2018assets\u2019 folder.     In order to incorporate these files into your project, as well as to adjust the resource use settings, you must change the Activity file. Edit the  MainActivity  file to look like this:  @Override  public   void   onCreate ( Bundle   savedInstanceState )  { \n    mAppKey   =   xxxxx ;      try   {          mResources   =   new   JSONArray ();          JSONObject   resource   =   new   JSONObject ();          resource . put ( P2UXAppTypes . P2UXApp_PackageAttrib_FormFactor ,   0 );          resource . put ( P2UXAppTypes . P2UXApp_PackageAttrib_Type ,   P2UXAppTypes . P2UXApp_PackageType_Static );          resource . put ( P2UXAppTypes . P2UXApp_PackageAttrib_Package ,   phone_pub );          resource . put ( P2UXAppTypes . P2UXApp_PackageAttrib_Update ,   P2UXAppTypes . P2UXApp_PackageUpdate_None );          mResources . put ( resource );      }      catch   ( JSONException   e )      {          P2UXLog . e ( TAG ,   onCreate -    +   e . getMessage ());      }  \n    if   (( getApplicationInfo (). flags     ApplicationInfo . FLAG_DEBUGGABLE )   ==   ApplicationInfo . FLAG_DEBUGGABLE )   { \n        if   ( savedInstanceState   ==   null )   { \n            savedInstanceState   =   new   Bundle (); \n        } \n        savedInstanceState . putString ( P2UXAppCreator . P2UXAppCreator_Opt_Env ,   P2UXAppCreator . P2UXAppCreator_Opt_Env_Prototype ); \n        savedInstanceState . putLong ( P2UXAppCreator . P2UXAppCreator_Opt_LogLevel ,   P2UXLog . P2UXCoreLogFlagVerbose ); \n    } \n\n    super . onCreate ( savedInstanceState ); \n    applyTranslucentStatusBar ();  }", 
            "title": "Static Assets"
        }, 
        {
            "location": "/android/quickstart/#defining-custom-resource-attributes", 
            "text": "If desired, the developer can define specific resource attributes for the app.  The resources parameter is an array of objects. Each object in the array defines the PUB usage for a particular form factor (Phone, Tablet, TV) using key value pairs. If the application supports multiple form factors, create an object in the resources array for each form factor.  Customize the resource attributes according to the possibilities below:     Resource Attribute  Description      P2UXApp_PackageAttrib_FormFactor  Defines which form factor the attributes reference. Possible Values: P2UXFormFactor_Phone P2UXFormFactor_Tablet P2UXFormFactor_TV    P2UXApp_PackageAttrib_Type  Defines the type of resources for the form factor Possible Values: P2UXApp_PackageType_Static P2UXApp_PackageType_Remote    P2UXApp_PackageAttrib_Package  Defines the name of the folder within the application bundle containing assets when the P2UXApp_PackageAttrib_Type is P2UXApp_PackageType_Static.    P2UXApp_PackageAttrib_Update  Defines how to update the application assets Possible Values: P2UXApp_PackageUpdate_None P2UXApp_PackageUpdate_Auto P2UXApp_PackageUpdate_Manual", 
            "title": "Defining Custom Resource Attributes"
        }, 
        {
            "location": "/android/customcode/", 
            "text": "Introduction\n\n\nWhat follows is a detailed tutorial that walks developers through the steps of writing custom code for an Android application using P2UX. Developers should be familiar with the Android Studio integrated development environment for MacOS and the Java programming languages for custom coding. \n\n\nTopics include customizable View and control behaviors, Screen/Panels, and UI controls.\n\n\n\n\nTerminology\n\n\nThroughout the P2UX documentation the \u201cdeveloper\u201d refers to you, the reader who is developing an app with P2UX. The \u201cdesigner\u201d refers to the individual whose principal job is to create the appearance and style of the app and its visual components. \u201cPRL\u201d refers to the P2UX Rendering Library for iOS, which controls the creation and workflow of content created for the P2UX platform.\n\n\n\n\n\n\nCoding examples and code additions\n\n\nIn the coding examples below and throughout the documentation, changes and additions to be made by the developer are rendered with a blue highlight.\n\n\n\n\nP2UX versus the standard Android Studio environment\n\n\nP2UX based applications are easy to customize and extend for Android. The P2UX Android rendering library is based on the Android Widget package (android.widget) and other Android primitives. This means that writing custom business logic and integrating custom controls works much the same as it does when writing Android applications using Android Studio.\nWith the P2UX platform, XML Layout files are no longer required for Android development. Instead, applications use P2UX Portable UX Bundles (PUB) either as embedded or dynamically accessed resources. Additionally, P2UX provides hooks to developers that allow them access to all of the components of P2UX as well as the ability to fully customize instances of the application.\n\n\n\n\nCreate a P2UX enabled project first\n\n\nThis document assumes a P2UX enabled Android Studio project has already been created. See \nQuick Start\n for steps to create a project.\n\n\n\n\nP2UX and Android Studio\n\n\nJava\n\n\nP2UX native rendering libraries for Android can be extended using the Java programming language. The instructions below provide explicit reference to the proper use of Java coding in each applicable step that follows.\n\n\nAdding Custom Behaviors\n\n\nIf desired, customizable behaviors can be added to the project code.\n\n\nA subclass of the \nP2UXAppBehavior\n class is the starting point for customizing the behavior of the application. From this class, all other parts of the application can be customized. (Common customized behaviors include creation of a Custom Control or overriding a particular View.)\n\n\nIn Android Studio, create a class to store the customized behaviors. The easiest way to do is by doing a right click on your project package and selecting \nNew-\nJava Class\n. (This example uses the name \nSampleBehavior\n.) In the \nCreate New Class\n dialog, type in \nP2UXAppBehavior\n in the Superclass field.\n\n\nThis will create \nSampleBehavior\n class. Put any customized behaviors within the implementation here. Below is a list of available customization methods for \nP2UXAppBehavior\n:\n\n\n\n\n\n\n\n\nModifier and Type\n\n\nMethod and Description\n\n\n\n\n\n\n\n\n\n\nP2UXFragment\n\n\ncreateViewFragment(int type, Context context, P2UXDefinition def, P2UXFragment.UXFragmentDelegate fragmentDelegate, RectF rect, boolean cache, Object index, Object data, P2UXViewContainerDelegate viewDelegate)\nCreates a custom fragment\n\n\n\n\n\n\nP2UXScreen\n\n\ncreateScreen(Context context, P2UXDefinition def, RectF rect, Object index, Object data, P2UXViewContainerDelegate viewDelegate)\nCreates a custom screen\n\n\n\n\n\n\nP2UXPanel\n\n\ncreatePanel(Context context, P2UXDefinition def, RectF rect, Object index, Object data, P2UXViewContainerDelegate viewDelegate)\nCreates a custom panel\n\n\n\n\n\n\nView\n\n\ncreateControl(String type, P2UXElementInstance elInstance, RectF rect, P2UXViewContainerDelegate viewDelegate, Object index, Object data)\nCreates a custom control\n\n\n\n\n\n\n\n\nIn addition, update \nMainActivity\n to include the custom behaviors.\n\n\nTo do this,\nMainActivity\n must override the method \ncreateBehavior\n. (This will override any default behaviors.) Edit \nMainActivity\n to look like this:\n\n\n@Override\n\n\npublic\n \nvoid\n \nonCreate\n(\nBundle\n \nsavedInstanceState\n)\n\n\n{\n\n   \nmAppKey\n \n=\n \nxxxxx\n;\n      \n   \ntry\n \n{\n\n       \nmResources\n \n=\n \nnew\n \nJSONArray\n();\n\n       \nJSONObject\n \nresource\n \n=\n \nnew\n \nJSONObject\n();\n\n       \nresource\n.\nput\n(\nP2UXAppTypes\n.\nP2UXApp_PackageAttrib_FormFactor\n,\n \n0\n);\n\n       \nresource\n.\nput\n(\nP2UXAppTypes\n.\nP2UXApp_PackageAttrib_Type\n,\n \nP2UXAppTypes\n.\nP2UXApp_PackageType_Static\n);\n\n       \nresource\n.\nput\n(\nP2UXAppTypes\n.\nP2UXApp_PackageAttrib_Package\n,\n \nshellui_phone\n);\n\n       \nresource\n.\nput\n(\nP2UXAppTypes\n.\nP2UXApp_PackageAttrib_Update\n,\n \nP2UXAppTypes\n.\nP2UXApp_PackageUpdate_None\n);\n\n       \nmResources\n.\nput\n(\nresource\n);\n\n   \n}\n\n   \ncatch\n \n(\nJSONException\n \ne\n)\n\n   \n{\n\n       \nP2UXLog\n.\ne\n(\nTAG\n,\n \nonCreate - \n \n+\n \ne\n.\ngetMessage\n());\n\n   \n}\n\n\n   \nif\n \n((\ngetApplicationInfo\n().\nflags\n \n \nApplicationInfo\n.\nFLAG_DEBUGGABLE\n)\n \n==\n \nApplicationInfo\n.\nFLAG_DEBUGGABLE\n)\n \n{\n\n       \nif\n \n(\nsavedInstanceState\n \n==\n \nnull\n)\n \n{\n\n           \nsavedInstanceState\n \n=\n \nnew\n \nBundle\n();\n\n       \n}\n\n       \nsavedInstanceState\n.\nputString\n(\nP2UXAppCreator\n.\nP2UXAppCreator_Opt_Env\n,\n \nP2UXAppCreator\n.\nP2UXAppCreator_Opt_Env_Prototype\n);\n\n       \nsavedInstanceState\n.\nputLong\n(\nP2UXAppCreator\n.\nP2UXAppCreator_Opt_LogLevel\n,\n \nP2UXLog\n.\nP2UXCoreLogFlagVerbose\n);\n\n   \n}\n\n\n   \nsuper\n.\nonCreate\n(\nsavedInstanceState\n);\n\n   \napplyTranslucentStatusBar\n();\n\n\n}\n\n\n\n@Override\n\n\npublic\n \nP2UXAppBehavior\n \ncreateBehavior\n(\nString\n \nappId\n)\n\n\n{\n\n\n   \nreturn\n \nnew\n \nSampleAppBehavior\n();\n\n\n}\n\n\n\n\n\n\nAdding Custom Fragment\n\n\nDevelopers can override Fragment instances to provide any custom code needed for a fragment lifecycle/behavior and its hosted \nView\n.\n\n\nThe PRL will request an instance from \nP2UXAppBehavior\n when it needs to create a new fragment. If no instance is provided, P2UX will generate a standard instance of the Fragment.\n\n\nTo provide a custom Fragment instance, override the method \ncreateViewFragment\n from a \nP2UXAppBehavior\n subclass and return an instance of \nP2UXFragment\n. \n\n\nTo handle button click action, override the method \nhandleButtonClick\n from \nP2UXAppFragment\n. To access a control in the fragment, override the method \nviewCreated\n from \nP2UXAppFragment\n. \n\n\nThe name of a chosen Fragment is the value used to identify the screen when the PRL creates an instance of this object. The \u201cdef\u201d parameter passed to this method contains the member variable \nsystemType\n that identifies the Screen being created. From this object, the developer determines the requested Screen and the specific \nP2UXFragment\n subclass to instantiate.\n\n\nCreating a custom Fragment instance in a \nP2UXAppBehavior\n subclass\n\n\n@Override\n\n\npublic\n \nP2UXFragment\n \ncreateViewFragment\n(\nint\n \ntype\n,\n \nContext\n \ncontext\n,\n \nP2UXDefinition\n \ndef\n,\n \nP2UXFragment\n.\nUXFragmentDelegate\n \nfragmentDelegate\n,\n \nRectF\n \nrect\n,\n \nboolean\n \ncache\n,\n \nObject\n \nindex\n,\n \nObject\n \ndata\n,\n \nP2UXViewContainerDelegate\n \nviewDelegate\n)\n\n\n{\n\n   \nif\n \n(\ndef\n.\ngetSystemType\n().\nequals\n(\nxxxxx\n))\n \n{\n\n       \n//return a fragment here, for example:\n\n       \nreturn\n \nnew\n \nSampleFragment\n(\ncontext\n,\n \ndef\n,\n \nfragmentDelegate\n,\n \nrect\n,\n \ncache\n,\n \nindex\n,\n \ndata\n,\n \nviewDelegate\n);\n\n   \n}\n\n   \nreturn\n \nsuper\n.\ncreateViewFragment\n(\ntype\n,\n \ncontext\n,\n \ndef\n,\n \nfragmentDelegate\n,\n \nrect\n,\n \ncache\n,\n \nindex\n,\n \ndata\n,\n \nviewDelegate\n);\n\n\n}\n\n\n\n@Override\n\n\npublic\n \nvoid\n \nviewCreated\n()\n\n\n{\n\n    \nsuper\n.\nviewCreated\n();\n\n    \nP2UXButton\n \nbtn\n \n=\n \n(\nP2UXButton\n)\n \ncontrolWithElementSystemTypeOrId\n(\nshow_btn\n);\n\n    \nif\n \n(\nbtn\n \n!=\n \nnull\n)\n \n{\n\n       \nbtn\n.\nsetEnabled\n(\nfalse\n);\n\n    \n}\n\n\n}\n\n\n\n@Override\n\n\npublic\n \nboolean\n \nhandleButtonClick\n(\nView\n \nctrl\n)\n \n\n{\n\n    \nP2UXElementInstance\n \nelementInstance\n \n=\n \nP2UXControlHelper\n.\ngetElementInstance\n(\nctrl\n);\n\n    \nif\n \n(\nelInstance\n \n!=\n \nnull\n \n \nelInstance\n.\ngetSystemType\n.\nequals\n(\nbutton1\n))\n\n    \n{\n\n        \nString\n \nelId\n \n=\n \nelInstance\n.\ngetElId\n();\n\n        \nif\n \n(\nelId\n \n!=\n \nnull\n \n \nelId\n.\nequals\n(\nbutton1\n))\n \n{\n\n           \n// take some custom action here for the \nokbtn\n\n\n           \n// return true to indicate the event was handled and propagation\n\n           \n// shouldn\nt continue\n\n           \nreturn\n \ntrue\n;\n\n        \n}\n\n    \n}\n\n    \nreturn\n \nsuper\n.\nhandleButtonClick\n(\nctrl\n);\n\n\n}\n\n\n\n\n\n\nAdding Custom Screens/Panels\n\n\nDevelopers can override Screen or Panel instances to provide any custom code needed for a hosted \nView\n.\n\n\nSince the P2UX UI is not based on XML Layout, connecting custom methods for each button click action is unnecessary. Instead, the developer can override the methods of the \nP2UXScreen\n class to handle button click and other UI events. (In all other respects, writing code for customized Screen and Panel behavior is the same as for XML layout-based content.)\n\n\nThe PRL will request an instance from \nP2UXAppBehavior\n when it needs to create a new Screen or Panel. If no instance is provided, P2UX will generate a standard instance of the Screen or Panel.\n\n\nTo provide a custom Screen instance, override the method \ncreateScreen\n from a \nP2UXAppBehavior\n subclass and return an instance of \nP2UXScreen\n. To provide a custom Panel instance, override the method \ncreatePanel\n and return an instance of \nP2UXPanel\n. (Both \nP2UXScreen\n and \nP2UXPanel\n are \nView\n based subclasses that add some additional helper methods. These methods make it easier to access screen components.)\n\n\nThe name of a chosen Screen or Panel is the value used to identify the item when the PRL creates an instance of this object. The \u201cdef\u201d parameter passed to this method contains the member variable \nsystemType\n that identifies the Screen being created. From this object, the developer determines the requested Screen and the specific \nP2UXScreen\n or \nP2UXPanel\n subclass to instantiate.\n\n\nCreating a custom Screen or Panel instance in a \nP2UXAppBehavior\n subclass\n\n\n@Override\n\n\npublic\n \nP2UXScreen\n \ncreateScreen\n(\nContext\n \ncontext\n,\n \nP2UXDefinition\n \ndef\n,\n \nRectF\n \nrect\n,\n \nObject\n \nindex\n,\n \nObject\n \ndata\n,\n \nP2UXViewContainerDelegate\n \nviewDelegate\n)\n\n\n{\n\n   \nif\n \n(\ndef\n.\ngetSystemType\n().\nequals\n(\nxxxxx\n))\n \n{\n\n       \n//return some screen here, for example:\n\n       \nreturn\n \nnew\n \nSampleScreen\n(\ncontext\n,\n \nrect\n,\n \ndef\n,\n \nviewDelegate\n,\n \nindex\n,\n \ndata\n);\n\n   \n}\n\n   \nreturn\n \nsuper\n.\ncreateScreen\n(\ncontext\n,\n \ndef\n,\n \nrect\n,\n \nindex\n,\n \ndata\n,\n \nviewDelegate\n);\n\n\n}\n\n\n\n@Override\n\n\npublic\n \nP2UXPanel\n \ncreatePanel\n(\nContext\n \ncontext\n,\n \nP2UXDefinition\n \ndef\n,\n \nRectF\n \nrect\n,\n \nObject\n \nindex\n,\n \nObject\n \ndata\n,\n \nP2UXViewContainerDelegate\n \nviewDelegate\n)\n\n\n{\n\n   \nif\n \n(\ndef\n.\ngetSystemType\n().\nequals\n(\nxxxxx\n))\n \n{\n\n       \n//return some screen here, for example:\n\n       \nreturn\n \nnew\n \nSamplePanel\n(\ncontext\n,\n \nrect\n,\n \ndef\n,\n \nviewDelegate\n,\n \nindex\n,\n \ndata\n);\n\n   \n}\n\n   \nreturn\n \nsuper\n.\ncreatePanel\n(\ncontext\n,\n \ndef\n,\n \nrect\n,\n \nindex\n,\n \ndata\n,\n \nviewDelegate\n);\n\n\n}\n\n\n\n\n\n\nAccessing Control instances from \nP2UXPanel\n or \nP2UXScreen\n\n\nTo access instances of controls, \nP2UXScreen\n provides a helper method, \ncontrolWithElementSystemTypeOrId\n. This method takes the name or id of the control to be accessed and returns a control instance.\n\n\n\u201cSystem type\u201d references\n\n\nAfter creating a control, the developer can set a \u201csystem type\u201d for the control in Builder. This effectively becomes the name for the new control. Referring to the control by its \u201csystem type\u201d means that the developer does not need to change any existing custom code when choosing to create an alternate variation of the same control. (Otherwise, if the developer changes the name of the control in Builder, any custom code to referring to the new name would have to be changed as well.)\n\n\nAccessing a control in a custom instance of \nP2UXScreen\n looks like this:\n\n\n@Override\n\n\npublic\n \nvoid\n \nshowView\n(\nboolean\n \nreload\n)\n\n\n{\n\n   \nsuper\n.\nshowView\n(\nreload\n);\n\n   \nP2UXButton\n \nbtn\n \n=\n \n(\nP2UXButton\n)\n \ncontrolWithElementSystemTypeOrId\n(\nshow_btn\n);\n\n   \nif\n \n(\nbtn\n \n!=\n \nnull\n)\n \n{\n\n       \nbtn\n.\nsetEnabled\n(\nfalse\n);\n\n   \n}\n\n\n}\n\n\n\n\n\n\nHandling Events from P2UXAppController\n\n\nEnd-users of a completed app will interact with controls in a Screen or Panel to generate events. These interactions will, in turn, trigger actions. Typically the PRL handles events directly through event interactions set up in Builder. In some cases, additional custom code may be needed to trigger actions not directly supported by P2UX.\n\n\nThe PRL provides a chain of event handlers that propagate an event through different components. Handling events at any point in the propagation chain provides a way to trigger custom code and also (optionally) to stop the propagation of the event at any specific handler.\n\n\nEvent propagation follows a set pattern.\n\n\nFirst, events are relayed to the \nP2UXScreen\n for the current Screen or Panel. Next, they pass to \nP2UXAppBehavior\n. Finally, events are handled by the custom instance of the \nView\n itself. If none of these components halt event propagation, the PRL will then handle any interactions defined for the event in Builder.\n\n\nThe \nP2UXScreen\n contains helper methods that handle a variety of events when they occur. These methods give the developer a chance to integrate any custom code needed from the basic event level without triggering any custom actions.\n\n\nMost standard control events are routed through the \nP2UXScreen\n instance. Handling these events is a matter of overriding the appropriate event method in your P2UXScreen subclass. Event propagation can be allowed to continue or not depending on the return value from the event handler methods.\n\n\nThe example below illustrates the code that handles a Button press event.\n\n\nHandling a Button press event in P2UXScreen subclass:\n\n\n@Override\n\n\npublic\n \nboolean\n \nhandleButtonClick\n(\nView\n \nctrl\n,\n \nP2UXElementInstance\n \nelInstance\n)\n\n\n{\n\n   \nif\n \n(\nelInstance\n \n!=\n \nnull\n \n \nelInstance\n.\ngetSystemType\n.\nequals\n(\nbutton1\n))\n\n   \n{\n\n       \nString\n \nelId\n \n=\n \nelInstance\n.\ngetElId\n();\n\n       \nif\n \n(\nelId\n \n!=\n \nnull\n \n \nelId\n.\nequals\n(\nbutton1\n))\n \n{\n\n           \n// take some custom action here for the \nokbtn\n\n\n           \n// return true to indicate the event was handled and propagation\n\n           \n// shouldn\nt continue\n\n           \nreturn\n \ntrue\n;\n\n       \n}\n\n   \n}\n\n   \nreturn\n \nsuper\n.\nhandleButtonClick\n(\nctrl\n);\n\n\n}\n\n\n\n\n\n\nAdding Custom UI Controls\n\n\nUI Controls are the visual components of a Screen or Panel created in the Builder tool. These can be interactive, like Buttons or Sliders, or non-interactive, like Shapes or Text. Although P2UX offers many different UI Controls directly creatable and usable in Builder, a specific application may require developer-defined UI controls. Builder provides a Custom Control component that can be added to a Screen or Panel and then replaced using custom code.\n\n\nAny \nView\n based control can be injected into your Screens and Panels via a Custom Control. This allows for existing custom controls or third party custom controls to be used with P2UX based applications.\n\n\nThe PRL manages the size and position of any custom controls defined using Builder. To provide an instance of a custom control, override the method createControl in your \nP2UXAppBehavior\n subclass and return the \nView\n subclassed instance of your control. The first parameter passed to this method, type, is the name of the control set when you created the custom control in Builder. P2UX will pass the initial size to use with your Custom Control, as well as a few other components that can be used to access any custom information created with your control in Builder.\n\n\nThe elementInstance parameter contains all the parameters specified using Builder for the control via its itemSpec member.\n\n\nCreate a custom control in \nP2UXAppBehavior\n subclass like this:\n\n\n@Override\n\n\npublic\n \nView\n \ncreateControl\n(\nString\n \ntype\n,\n \nP2UXElementInstance\n \nelemInstance\n,\n \nRectF\n \nrect\n,\n \nP2UXViewContainerDelegate\n \nviewDelegate\n,\n \nObject\n \nindex\n,\n \nObject\n \ndata\n)\n\n\n{\n\n   \nif\n \n(\ntype\n \n!=\n \nnull\n \n \n!\ntype\n.\nisEmpty\n())\n \n{\n\n       \nif\n \n(\ntype\n.\nequals\n(\ncalendar\n))\n \n{\n\n\n           \n// Below is an example of implementing a calendar using CalendarView\n\n           \nView\n \nctrl\n \n=\n \nnew\n \nCalendarView\n(\nmContext\n);\n\n           \nRelativeLayout\n.\nLayoutParams\n \nparams\n \n=\n \nnew\n \nRelativeLayout\n.\nLayoutParams\n((\nint\n)\nrect\n.\nwidth\n(),\n \n(\nint\n)\nrect\n.\nheight\n());\n\n           \nparams\n.\nleftMargin\n \n=\n \n(\nint\n)\nrect\n.\nleft\n;\n\n           \nparams\n.\ntopMargin\n \n=\n \n(\nint\n)\nrect\n.\ntop\n;\n\n           \nctrl\n.\nsetLayoutParams\n(\nparams\n);\n\n           \n((\nCalendarView\n)\n \nctrl\n).\nsetOnDateChangeListener\n(\nnew\n \nCalendarView\n.\nOnDateChangeListener\n()\n \n{\n\n               \n@Override\n\n               \npublic\n \nvoid\n \nonSelectedDayChange\n(\n@NonNull\n \nCalendarView\n \nview\n,\n \nint\n \nyear\n,\n \nint\n \nmonth\n,\n \nint\n \ndayOfMonth\n)\n \n{\n\n                   \nToast\n.\nmakeText\n(\nmContext\n,\n \nmonth\n+\n1\n \n+\n \n/\n \n+\n \ndayOfMonth\n \n+\n \n/\n \n+\n \nyear\n,\n \nToast\n.\nLENGTH_SHORT\n).\nshow\n();\n\n               \n}\n\n           \n});\n\n           \nreturn\n \nctrl\n;\n\n       \n}\n\n   \n}\n\n   \nreturn\n \nsuper\n.\ncreateControl\n(\ntype\n,\n \nelemInstance\n,\n \nrect\n,\n \nviewDelegate\n,\n \nindex\n,\n \ndata\n);\n\n\n}", 
            "title": "Custom Code"
        }, 
        {
            "location": "/android/customcode/#introduction", 
            "text": "What follows is a detailed tutorial that walks developers through the steps of writing custom code for an Android application using P2UX. Developers should be familiar with the Android Studio integrated development environment for MacOS and the Java programming languages for custom coding.   Topics include customizable View and control behaviors, Screen/Panels, and UI controls.   Terminology  Throughout the P2UX documentation the \u201cdeveloper\u201d refers to you, the reader who is developing an app with P2UX. The \u201cdesigner\u201d refers to the individual whose principal job is to create the appearance and style of the app and its visual components. \u201cPRL\u201d refers to the P2UX Rendering Library for iOS, which controls the creation and workflow of content created for the P2UX platform.    Coding examples and code additions  In the coding examples below and throughout the documentation, changes and additions to be made by the developer are rendered with a blue highlight.   P2UX versus the standard Android Studio environment  P2UX based applications are easy to customize and extend for Android. The P2UX Android rendering library is based on the Android Widget package (android.widget) and other Android primitives. This means that writing custom business logic and integrating custom controls works much the same as it does when writing Android applications using Android Studio.\nWith the P2UX platform, XML Layout files are no longer required for Android development. Instead, applications use P2UX Portable UX Bundles (PUB) either as embedded or dynamically accessed resources. Additionally, P2UX provides hooks to developers that allow them access to all of the components of P2UX as well as the ability to fully customize instances of the application.   Create a P2UX enabled project first  This document assumes a P2UX enabled Android Studio project has already been created. See  Quick Start  for steps to create a project.", 
            "title": "Introduction"
        }, 
        {
            "location": "/android/customcode/#p2ux-and-android-studio", 
            "text": "Java  P2UX native rendering libraries for Android can be extended using the Java programming language. The instructions below provide explicit reference to the proper use of Java coding in each applicable step that follows.", 
            "title": "P2UX and Android Studio"
        }, 
        {
            "location": "/android/customcode/#adding-custom-behaviors", 
            "text": "If desired, customizable behaviors can be added to the project code.  A subclass of the  P2UXAppBehavior  class is the starting point for customizing the behavior of the application. From this class, all other parts of the application can be customized. (Common customized behaviors include creation of a Custom Control or overriding a particular View.)  In Android Studio, create a class to store the customized behaviors. The easiest way to do is by doing a right click on your project package and selecting  New- Java Class . (This example uses the name  SampleBehavior .) In the  Create New Class  dialog, type in  P2UXAppBehavior  in the Superclass field.  This will create  SampleBehavior  class. Put any customized behaviors within the implementation here. Below is a list of available customization methods for  P2UXAppBehavior :     Modifier and Type  Method and Description      P2UXFragment  createViewFragment(int type, Context context, P2UXDefinition def, P2UXFragment.UXFragmentDelegate fragmentDelegate, RectF rect, boolean cache, Object index, Object data, P2UXViewContainerDelegate viewDelegate) Creates a custom fragment    P2UXScreen  createScreen(Context context, P2UXDefinition def, RectF rect, Object index, Object data, P2UXViewContainerDelegate viewDelegate) Creates a custom screen    P2UXPanel  createPanel(Context context, P2UXDefinition def, RectF rect, Object index, Object data, P2UXViewContainerDelegate viewDelegate) Creates a custom panel    View  createControl(String type, P2UXElementInstance elInstance, RectF rect, P2UXViewContainerDelegate viewDelegate, Object index, Object data) Creates a custom control     In addition, update  MainActivity  to include the custom behaviors.  To do this, MainActivity  must override the method  createBehavior . (This will override any default behaviors.) Edit  MainActivity  to look like this:  @Override  public   void   onCreate ( Bundle   savedInstanceState )  { \n    mAppKey   =   xxxxx ;       \n    try   { \n        mResources   =   new   JSONArray (); \n        JSONObject   resource   =   new   JSONObject (); \n        resource . put ( P2UXAppTypes . P2UXApp_PackageAttrib_FormFactor ,   0 ); \n        resource . put ( P2UXAppTypes . P2UXApp_PackageAttrib_Type ,   P2UXAppTypes . P2UXApp_PackageType_Static ); \n        resource . put ( P2UXAppTypes . P2UXApp_PackageAttrib_Package ,   shellui_phone ); \n        resource . put ( P2UXAppTypes . P2UXApp_PackageAttrib_Update ,   P2UXAppTypes . P2UXApp_PackageUpdate_None ); \n        mResources . put ( resource ); \n    } \n    catch   ( JSONException   e ) \n    { \n        P2UXLog . e ( TAG ,   onCreate -    +   e . getMessage ()); \n    } \n\n    if   (( getApplicationInfo (). flags     ApplicationInfo . FLAG_DEBUGGABLE )   ==   ApplicationInfo . FLAG_DEBUGGABLE )   { \n        if   ( savedInstanceState   ==   null )   { \n            savedInstanceState   =   new   Bundle (); \n        } \n        savedInstanceState . putString ( P2UXAppCreator . P2UXAppCreator_Opt_Env ,   P2UXAppCreator . P2UXAppCreator_Opt_Env_Prototype ); \n        savedInstanceState . putLong ( P2UXAppCreator . P2UXAppCreator_Opt_LogLevel ,   P2UXLog . P2UXCoreLogFlagVerbose ); \n    } \n\n    super . onCreate ( savedInstanceState ); \n    applyTranslucentStatusBar ();  }  @Override  public   P2UXAppBehavior   createBehavior ( String   appId )  {      return   new   SampleAppBehavior ();  }", 
            "title": "Adding Custom Behaviors"
        }, 
        {
            "location": "/android/customcode/#adding-custom-fragment", 
            "text": "Developers can override Fragment instances to provide any custom code needed for a fragment lifecycle/behavior and its hosted  View .  The PRL will request an instance from  P2UXAppBehavior  when it needs to create a new fragment. If no instance is provided, P2UX will generate a standard instance of the Fragment.  To provide a custom Fragment instance, override the method  createViewFragment  from a  P2UXAppBehavior  subclass and return an instance of  P2UXFragment .   To handle button click action, override the method  handleButtonClick  from  P2UXAppFragment . To access a control in the fragment, override the method  viewCreated  from  P2UXAppFragment .   The name of a chosen Fragment is the value used to identify the screen when the PRL creates an instance of this object. The \u201cdef\u201d parameter passed to this method contains the member variable  systemType  that identifies the Screen being created. From this object, the developer determines the requested Screen and the specific  P2UXFragment  subclass to instantiate.  Creating a custom Fragment instance in a  P2UXAppBehavior  subclass  @Override  public   P2UXFragment   createViewFragment ( int   type ,   Context   context ,   P2UXDefinition   def ,   P2UXFragment . UXFragmentDelegate   fragmentDelegate ,   RectF   rect ,   boolean   cache ,   Object   index ,   Object   data ,   P2UXViewContainerDelegate   viewDelegate )  { \n    if   ( def . getSystemType (). equals ( xxxxx ))   { \n        //return a fragment here, for example: \n        return   new   SampleFragment ( context ,   def ,   fragmentDelegate ,   rect ,   cache ,   index ,   data ,   viewDelegate ); \n    } \n    return   super . createViewFragment ( type ,   context ,   def ,   fragmentDelegate ,   rect ,   cache ,   index ,   data ,   viewDelegate );  }  @Override  public   void   viewCreated ()  { \n     super . viewCreated (); \n     P2UXButton   btn   =   ( P2UXButton )   controlWithElementSystemTypeOrId ( show_btn ); \n     if   ( btn   !=   null )   { \n        btn . setEnabled ( false ); \n     }  }  @Override  public   boolean   handleButtonClick ( View   ctrl )   { \n     P2UXElementInstance   elementInstance   =   P2UXControlHelper . getElementInstance ( ctrl ); \n     if   ( elInstance   !=   null     elInstance . getSystemType . equals ( button1 )) \n     { \n         String   elId   =   elInstance . getElId (); \n         if   ( elId   !=   null     elId . equals ( button1 ))   { \n            // take some custom action here for the  okbtn \n\n            // return true to indicate the event was handled and propagation \n            // shouldn t continue \n            return   true ; \n         } \n     } \n     return   super . handleButtonClick ( ctrl );  }", 
            "title": "Adding Custom Fragment"
        }, 
        {
            "location": "/android/customcode/#adding-custom-screenspanels", 
            "text": "Developers can override Screen or Panel instances to provide any custom code needed for a hosted  View .  Since the P2UX UI is not based on XML Layout, connecting custom methods for each button click action is unnecessary. Instead, the developer can override the methods of the  P2UXScreen  class to handle button click and other UI events. (In all other respects, writing code for customized Screen and Panel behavior is the same as for XML layout-based content.)  The PRL will request an instance from  P2UXAppBehavior  when it needs to create a new Screen or Panel. If no instance is provided, P2UX will generate a standard instance of the Screen or Panel.  To provide a custom Screen instance, override the method  createScreen  from a  P2UXAppBehavior  subclass and return an instance of  P2UXScreen . To provide a custom Panel instance, override the method  createPanel  and return an instance of  P2UXPanel . (Both  P2UXScreen  and  P2UXPanel  are  View  based subclasses that add some additional helper methods. These methods make it easier to access screen components.)  The name of a chosen Screen or Panel is the value used to identify the item when the PRL creates an instance of this object. The \u201cdef\u201d parameter passed to this method contains the member variable  systemType  that identifies the Screen being created. From this object, the developer determines the requested Screen and the specific  P2UXScreen  or  P2UXPanel  subclass to instantiate.  Creating a custom Screen or Panel instance in a  P2UXAppBehavior  subclass  @Override  public   P2UXScreen   createScreen ( Context   context ,   P2UXDefinition   def ,   RectF   rect ,   Object   index ,   Object   data ,   P2UXViewContainerDelegate   viewDelegate )  { \n    if   ( def . getSystemType (). equals ( xxxxx ))   { \n        //return some screen here, for example: \n        return   new   SampleScreen ( context ,   rect ,   def ,   viewDelegate ,   index ,   data ); \n    } \n    return   super . createScreen ( context ,   def ,   rect ,   index ,   data ,   viewDelegate );  }  @Override  public   P2UXPanel   createPanel ( Context   context ,   P2UXDefinition   def ,   RectF   rect ,   Object   index ,   Object   data ,   P2UXViewContainerDelegate   viewDelegate )  { \n    if   ( def . getSystemType (). equals ( xxxxx ))   { \n        //return some screen here, for example: \n        return   new   SamplePanel ( context ,   rect ,   def ,   viewDelegate ,   index ,   data ); \n    } \n    return   super . createPanel ( context ,   def ,   rect ,   index ,   data ,   viewDelegate );  }", 
            "title": "Adding Custom Screens/Panels"
        }, 
        {
            "location": "/android/customcode/#accessing-control-instances-from-p2uxpanel-or-p2uxscreen", 
            "text": "To access instances of controls,  P2UXScreen  provides a helper method,  controlWithElementSystemTypeOrId . This method takes the name or id of the control to be accessed and returns a control instance.  \u201cSystem type\u201d references  After creating a control, the developer can set a \u201csystem type\u201d for the control in Builder. This effectively becomes the name for the new control. Referring to the control by its \u201csystem type\u201d means that the developer does not need to change any existing custom code when choosing to create an alternate variation of the same control. (Otherwise, if the developer changes the name of the control in Builder, any custom code to referring to the new name would have to be changed as well.)  Accessing a control in a custom instance of  P2UXScreen  looks like this:  @Override  public   void   showView ( boolean   reload )  { \n    super . showView ( reload ); \n    P2UXButton   btn   =   ( P2UXButton )   controlWithElementSystemTypeOrId ( show_btn ); \n    if   ( btn   !=   null )   { \n        btn . setEnabled ( false ); \n    }  }", 
            "title": "Accessing Control instances from P2UXPanel or P2UXScreen"
        }, 
        {
            "location": "/android/customcode/#handling-events-from-p2uxappcontroller", 
            "text": "End-users of a completed app will interact with controls in a Screen or Panel to generate events. These interactions will, in turn, trigger actions. Typically the PRL handles events directly through event interactions set up in Builder. In some cases, additional custom code may be needed to trigger actions not directly supported by P2UX.  The PRL provides a chain of event handlers that propagate an event through different components. Handling events at any point in the propagation chain provides a way to trigger custom code and also (optionally) to stop the propagation of the event at any specific handler.  Event propagation follows a set pattern.  First, events are relayed to the  P2UXScreen  for the current Screen or Panel. Next, they pass to  P2UXAppBehavior . Finally, events are handled by the custom instance of the  View  itself. If none of these components halt event propagation, the PRL will then handle any interactions defined for the event in Builder.  The  P2UXScreen  contains helper methods that handle a variety of events when they occur. These methods give the developer a chance to integrate any custom code needed from the basic event level without triggering any custom actions.  Most standard control events are routed through the  P2UXScreen  instance. Handling these events is a matter of overriding the appropriate event method in your P2UXScreen subclass. Event propagation can be allowed to continue or not depending on the return value from the event handler methods.  The example below illustrates the code that handles a Button press event.  Handling a Button press event in P2UXScreen subclass:  @Override  public   boolean   handleButtonClick ( View   ctrl ,   P2UXElementInstance   elInstance )  { \n    if   ( elInstance   !=   null     elInstance . getSystemType . equals ( button1 )) \n    { \n        String   elId   =   elInstance . getElId (); \n        if   ( elId   !=   null     elId . equals ( button1 ))   { \n            // take some custom action here for the  okbtn \n\n            // return true to indicate the event was handled and propagation \n            // shouldn t continue \n            return   true ; \n        } \n    } \n    return   super . handleButtonClick ( ctrl );  }", 
            "title": "Handling Events from P2UXAppController"
        }, 
        {
            "location": "/android/customcode/#adding-custom-ui-controls", 
            "text": "UI Controls are the visual components of a Screen or Panel created in the Builder tool. These can be interactive, like Buttons or Sliders, or non-interactive, like Shapes or Text. Although P2UX offers many different UI Controls directly creatable and usable in Builder, a specific application may require developer-defined UI controls. Builder provides a Custom Control component that can be added to a Screen or Panel and then replaced using custom code.  Any  View  based control can be injected into your Screens and Panels via a Custom Control. This allows for existing custom controls or third party custom controls to be used with P2UX based applications.  The PRL manages the size and position of any custom controls defined using Builder. To provide an instance of a custom control, override the method createControl in your  P2UXAppBehavior  subclass and return the  View  subclassed instance of your control. The first parameter passed to this method, type, is the name of the control set when you created the custom control in Builder. P2UX will pass the initial size to use with your Custom Control, as well as a few other components that can be used to access any custom information created with your control in Builder.  The elementInstance parameter contains all the parameters specified using Builder for the control via its itemSpec member.  Create a custom control in  P2UXAppBehavior  subclass like this:  @Override  public   View   createControl ( String   type ,   P2UXElementInstance   elemInstance ,   RectF   rect ,   P2UXViewContainerDelegate   viewDelegate ,   Object   index ,   Object   data )  { \n    if   ( type   !=   null     ! type . isEmpty ())   { \n        if   ( type . equals ( calendar ))   { \n\n            // Below is an example of implementing a calendar using CalendarView \n            View   ctrl   =   new   CalendarView ( mContext ); \n            RelativeLayout . LayoutParams   params   =   new   RelativeLayout . LayoutParams (( int ) rect . width (),   ( int ) rect . height ()); \n            params . leftMargin   =   ( int ) rect . left ; \n            params . topMargin   =   ( int ) rect . top ; \n            ctrl . setLayoutParams ( params ); \n            (( CalendarView )   ctrl ). setOnDateChangeListener ( new   CalendarView . OnDateChangeListener ()   { \n                @Override \n                public   void   onSelectedDayChange ( @NonNull   CalendarView   view ,   int   year ,   int   month ,   int   dayOfMonth )   { \n                    Toast . makeText ( mContext ,   month + 1   +   /   +   dayOfMonth   +   /   +   year ,   Toast . LENGTH_SHORT ). show (); \n                } \n            }); \n            return   ctrl ; \n        } \n    } \n    return   super . createControl ( type ,   elemInstance ,   rect ,   viewDelegate ,   index ,   data );  }", 
            "title": "Adding Custom UI Controls"
        }, 
        {
            "location": "/general/envandpublish/", 
            "text": "Introduction\n\n\nPublishing applications on the P2UX Platform allows for use in different environments to support prototype testing, staged testing for release to live applications, and deployment of the application content to production native apps. Each environment can be targeted by the native application based on the creation and initialization of the app in native code. The use of these different environments is not enforced by the P2UX rendering libraries (PRL) on the different platforms which allows the developer to decide how they are used.\n\n\nWhen using application bundles as dynamic resources, P2UX based native applications will check for updates to the application bundle on startup of the app.\n\n\nEnvironments\n\n\nThere are three environments for applications to make use of: \nPrototype, Stage, Deployed\n. Applications are promoted from one stage to another via the \nBuilder\n application. Native applications can toggle the environment used programmatically so that the application can be tested using the different environments prior to release to production.\n\n\nPrototype\n\n\nWhen an application is Published via the \nPublish\n menu in \nBuilder\n, the application contents are compressed and bundled into packages for use on the specified platforms and form factors. These published versions of the application are \nPrototypes\n of the application. The primary use of \nPrototypes\n is to try out UI variations, workflow, and even custom code. \n\n\n\n\nPrivate and Public Publishing\n\n\nBuilder\n provides the option to publicly or privately publish prototypes. A private publish of the Prototype is only available to the user that Published the application and will only be usable by the \nP2UX Player\n for Android and iOS/tvOS. A public publish of the application will be available in the \nP2UX Player\n to any user in the same group as the user that published the application as well as being available for use in native application instances.\n\n\n\n\nTo use a \nPrototype\n in a native application, the developer needs to setup the PRL environment to refer to prototypes. \n\n\nThe environment value to use for Prototypes is: \nP2UXAppCreator_Opt_Env_Recent\n\n\nThis setting will fetch the most recent \nPublic\n version of the Application bundle regardless of whether it is in the \nPrototype\n, \nStaged\n, or \nProduction\n environments. Every time the application is published publicly, it becomes the most recent version and is available to developer builds of the application.\n\n\n\n\nPrototypes aren't meant for Release!\n\n\nUsing a \nPrototype\n bundle with dynamic updates in a native application is supported by P2UX, but NOT recommended for applications released to the public. It is meant for developer builds try out features quickly and test your custom code. Be aware that every time a public pubish is performed on the application, the native application will pick up the changes when it restarts which means every change made to the application and published as a public \nPrototype\n would be pushed to your users! \n\n\n\n\nThe following code examples set the environment to \nP2UXAppCreator_Opt_Env_Recent\n for developer testing and debugging purposes.\n\n\niOS/tvOS\n\n\nIn Objective-C, edit \nAppDelegate.m\n:\n\n\n#import \nAppDelegate.h\n\n\n@interface\n \nAppDelegate\n \n()\n\n\n@end\n\n\n@implementation\n \nAppDelegate\n\n\n-\n \n(\nBOOL\n)\napplication:\n(\nUIApplication\n \n*\n)\napplication\n \ndidFinishLaunchingWithOptions:\n(\nNSDictionary\n \n*\n)\nlaunchOptions\n \n{\n\n    \nNSString\n*\n \nappKey\n;\n\n    \nappKey\n \n=\n \n@\nxxxxx\n;\n\n    \nNSDictionary\n \n*\nopts\n;\n\n\n#if DEBUG\n\n\n    \nopts\n \n=\n \n@{\nP2UXAppCreator_Opt_Env\n:\n \nP2UXAppCreator_Opt_Env_Recent\n}\n;\n\n\n#endif    \n\n\n    \n[\nP2UXAppCreator\n \ncreateApplicationWithKey\n:\nappKey\n \nopts\n:\nopts\n \nresources\n:\nresources\n \ndelegate\n:\nself\n];\n\n    \nreturn\n \nYES\n;\n\n\n}\n\n\n\n\n\n\nIn Swift, edit \nAppDelegate.swift\n:\n\n\nimport\n \nUIKit\n\n\nimport\n \nP2UXApp\n\n\n\n@UIApplicationMain\n\n\nclass\n \nAppDelegate\n:\n \nUIResponder\n,\n \nUIApplicationDelegate\n,\n \nP2UXAppCreatorDelegate\n \n{\n\n    \nvar\n \nwindow\n:\n \nUIWindow\n?\n\n    \nfunc\n \napplication\n(\n_\n \napplication\n:\n \nUIApplication\n,\n \ndidFinishLaunchingWithOptions\n \nlaunchOptions\n:\n \n[\nUIApplicationLaunchOptionsKey\n:\n \nAny\n]?)\n \n-\n \nBool\n \n{\n\n        \nlet\n \nappKey\n \n=\n \nxxxxx\n;\n\n        \nvar\n \nopts\n \n:\n \n[\nAnyHashable\n \n:\n \nAny\n];\n\n\n#if\n \nDEBUG\n\n        \nopts\n \n=\n \n[\n\n\n            \nP2UXAppCreator_Opt_Env\n:\n \nP2UXAppCreator_Opt_Env_Recent\n,\n\n\n        \n]\n\n\n#endif\n\n        \nP2UXAppCreator\n.\ncreateApplication\n(\nwithKey\n:\n \nappKey\n,\n \nopts\n:\n \nopts\n,\n\n            \nresources\n:\n \nresources\n,\n \ndelegate\n:\n \nself\n)\n\n    \n}\n\n    \nfunc\n \ncreateBehavior\n(\nforApplication\n \nappid\n:\n \nString\n)\n \n-\n \nP2UXAppBehavior\n \n{\n\n        \nreturn\n \nSampleBehavior\n();\n\n    \n}\n\n\n}\n\n\n\n\n\n\nAndroid\n\n\nEdit \nMainActivity.java\n:\n\n\n@Override\n\n\npublic\n \nvoid\n \nonCreate\n(\nBundle\n \nsavedInstanceState\n)\n\n\n{\n\n   \nmAppKey\n \n=\n \nxxxxx\n;\n      \n   \nif\n \n((\ngetApplicationInfo\n().\nflags\n \n \nApplicationInfo\n.\nFLAG_DEBUGGABLE\n)\n \n==\n \nApplicationInfo\n.\nFLAG_DEBUGGABLE\n)\n \n{\n\n       \nif\n \n(\nsavedInstanceState\n \n==\n \nnull\n)\n \n{\n\n           \nsavedInstanceState\n \n=\n \nnew\n \nBundle\n();\n\n       \n}\n\n\n       \nsavedInstanceState\n.\nputString\n(\nP2UXAppCreator\n.\nP2UXAppCreator_Opt_Env\n,\n \nP2UXAppCreator\n.\nP2UXAppCreator_Opt_Env_Recent\n);\n\n\n   \n}\n\n\n   \nsuper\n.\nonCreate\n(\nsavedInstanceState\n);\n\n\n}\n\n\n\n\n\n\nStage\n\n\nThe \nStage\n environment is intended for testing an application prior to its release to production. Once application content is staged, it will NOT pick up any changes from subsequent publishes of the application as a \nPrototype\n. Staged application content will also NOT be delivered to native applications using \nProduction\n content.\n\n\nTo make application content available to the \nStage\n environment in \nBuilder\n:\n\n\n\n\nClick the \nPublish\n menu dropdown and select \nMake it real\n from the menu.\n\n\nMake sure you are in the \nPrototypes\n tab at the top of the \nMake it Real\n dialog\n\n\nClick the \nStage App\n button next to the Prototype application bundle. \n\n\nClick \nOK\n from the \nStage App Confirmation\n to finish the staging.\n\n\n\n\nTo use \nStage\n content in a native application, the developer needs to setup the PRL environment to refer to staged content. \n\n\nThe environment value to use for Prototypes is: \nP2UXAppCreator_Opt_Env_Stage\n\n\nThis setting will fetch the staged version of the Application bundle when the application starts if it doesn't already have the most recent version of the bundle. \n\n\n\n\nStaged content is for testing\n\n\nUsing a \nStaged\n bundle with dynamic updates in a native application is not recommended for applications released to the public. It is meant for testing an application's content changes prior to release.\n\n\n\n\nThe following code examples set the environment to \nP2UXAppCreator_Opt_Env_Stage\n for developer testing and debugging purposes.\n\n\niOS/tvOS\n\n\nIn Objective-C, edit \nAppDelegate.m\n:\n\n\n#import \nAppDelegate.h\n\n\n@interface\n \nAppDelegate\n \n()\n\n\n@end\n\n\n@implementation\n \nAppDelegate\n\n\n-\n \n(\nBOOL\n)\napplication:\n(\nUIApplication\n \n*\n)\napplication\n \ndidFinishLaunchingWithOptions:\n(\nNSDictionary\n \n*\n)\nlaunchOptions\n \n{\n\n    \nNSString\n*\n \nappKey\n;\n\n    \nappKey\n \n=\n \n@\nxxxxx\n;\n\n    \nNSDictionary\n \n*\nopts\n;\n\n\n#if DEBUG\n\n\n    \nopts\n \n=\n \n@{\nP2UXAppCreator_Opt_Env\n:\n \nP2UXAppCreator_Opt_Env_Stage\n}\n;\n\n\n#endif    \n\n\n    \n[\nP2UXAppCreator\n \ncreateApplicationWithKey\n:\nappKey\n \nopts\n:\nopts\n \nresources\n:\nresources\n \ndelegate\n:\nself\n];\n\n    \nreturn\n \nYES\n;\n\n\n}\n\n\n\n\n\n\nIn Swift, edit \nAppDelegate.swift\n:\n\n\nimport\n \nUIKit\n\n\nimport\n \nP2UXApp\n\n\n\n@UIApplicationMain\n\n\nclass\n \nAppDelegate\n:\n \nUIResponder\n,\n \nUIApplicationDelegate\n,\n \nP2UXAppCreatorDelegate\n \n{\n\n    \nvar\n \nwindow\n:\n \nUIWindow\n?\n\n    \nfunc\n \napplication\n(\n_\n \napplication\n:\n \nUIApplication\n,\n \ndidFinishLaunchingWithOptions\n \nlaunchOptions\n:\n \n[\nUIApplicationLaunchOptionsKey\n:\n \nAny\n]?)\n \n-\n \nBool\n \n{\n\n        \nlet\n \nappKey\n \n=\n \nxxxxx\n;\n\n        \nvar\n \nopts\n \n:\n \n[\nAnyHashable\n \n:\n \nAny\n];\n\n\n#if\n \nDEBUG\n\n        \nopts\n \n=\n \n[\n\n\n            \nP2UXAppCreator_Opt_Env\n:\n \nP2UXAppCreator_Opt_Env_Stage\n,\n\n\n        \n]\n\n\n#endif\n\n        \nP2UXAppCreator\n.\ncreateApplication\n(\nwithKey\n:\n \nappKey\n,\n \nopts\n:\n \nopts\n,\n\n            \nresources\n:\n \nresources\n,\n \ndelegate\n:\n \nself\n)\n\n    \n}\n\n    \nfunc\n \ncreateBehavior\n(\nforApplication\n \nappid\n:\n \nString\n)\n \n-\n \nP2UXAppBehavior\n \n{\n\n        \nreturn\n \nSampleBehavior\n();\n\n    \n}\n\n\n}\n\n\n\n\n\n\nAndroid\n\n\nEdit \nMainActivity.java\n:\n\n\n@Override\n\n\npublic\n \nvoid\n \nonCreate\n(\nBundle\n \nsavedInstanceState\n)\n\n\n{\n\n   \nmAppKey\n \n=\n \nxxxxx\n;\n      \n   \nif\n \n((\ngetApplicationInfo\n().\nflags\n \n \nApplicationInfo\n.\nFLAG_DEBUGGABLE\n)\n \n==\n \nApplicationInfo\n.\nFLAG_DEBUGGABLE\n)\n \n{\n\n       \nif\n \n(\nsavedInstanceState\n \n==\n \nnull\n)\n \n{\n\n           \nsavedInstanceState\n \n=\n \nnew\n \nBundle\n();\n\n       \n}\n\n\n       \nsavedInstanceState\n.\nputString\n(\nP2UXAppCreator\n.\nP2UXAppCreator_Opt_Env\n,\n \nP2UXAppCreator\n.\nP2UXAppCreator_Opt_Env_Stage\n);\n\n\n   \n}\n\n\n   \nsuper\n.\nonCreate\n(\nsavedInstanceState\n);\n\n\n}\n\n\n\n\n\n\nProduction (Deployed)\n\n\nThe \nProduction\n environment is intended for use in the released production application. This is the default setting for the PRL when no specific environment setting is provided. Application content can only be moved into \nProduction\n after first being moved to the \nStage\n environment. Once application content is deployed to production, it will NOT pick up any changes from subsequent publishes of the application as a \nPrototype\n or from content moved into the \nStage\n environment. \n\n\nTo make application content available to the \nProduction\n environment in \nBuilder\n:\n\n\n\n\nClick the \nPublish\n menu dropdown and select \nMake it real\n from the menu.\n\n\nClick on the \nApps\n tab at the top of the \nMake it Real\n dialog\n\n\nClick the \nDeploy\n button next to the Staged application bundle. \n\n\n\n\nTo use a \nProduction\n in a native application, the developer needs to setup the PRL environment to refer to deployed content. \n\n\nThe environment value to use for Prototypes is: \nP2UXAppCreator_Opt_Env_Production\n\n\nThis setting will fetch the deployed version of the Application bundle when the application starts if it doesn't have the most recent deployed version of the bundle. \n\n\nTo set the PRL to the \nProduction\n environment, either omit the \nP2UXAppCreator_Opt_Env\n value from the options at startup or explicitly set it to \nP2UXAppCreator_Opt_Env_Production\n. The previous code examples would work as is for using the \nProduction\n environment for released applications as the other environment alternatives are only set when debugging the application.", 
            "title": "Application Environments"
        }, 
        {
            "location": "/general/envandpublish/#introduction", 
            "text": "Publishing applications on the P2UX Platform allows for use in different environments to support prototype testing, staged testing for release to live applications, and deployment of the application content to production native apps. Each environment can be targeted by the native application based on the creation and initialization of the app in native code. The use of these different environments is not enforced by the P2UX rendering libraries (PRL) on the different platforms which allows the developer to decide how they are used.  When using application bundles as dynamic resources, P2UX based native applications will check for updates to the application bundle on startup of the app.", 
            "title": "Introduction"
        }, 
        {
            "location": "/general/envandpublish/#environments", 
            "text": "There are three environments for applications to make use of:  Prototype, Stage, Deployed . Applications are promoted from one stage to another via the  Builder  application. Native applications can toggle the environment used programmatically so that the application can be tested using the different environments prior to release to production.", 
            "title": "Environments"
        }, 
        {
            "location": "/general/envandpublish/#prototype", 
            "text": "When an application is Published via the  Publish  menu in  Builder , the application contents are compressed and bundled into packages for use on the specified platforms and form factors. These published versions of the application are  Prototypes  of the application. The primary use of  Prototypes  is to try out UI variations, workflow, and even custom code.    Private and Public Publishing  Builder  provides the option to publicly or privately publish prototypes. A private publish of the Prototype is only available to the user that Published the application and will only be usable by the  P2UX Player  for Android and iOS/tvOS. A public publish of the application will be available in the  P2UX Player  to any user in the same group as the user that published the application as well as being available for use in native application instances.   To use a  Prototype  in a native application, the developer needs to setup the PRL environment to refer to prototypes.   The environment value to use for Prototypes is:  P2UXAppCreator_Opt_Env_Recent  This setting will fetch the most recent  Public  version of the Application bundle regardless of whether it is in the  Prototype ,  Staged , or  Production  environments. Every time the application is published publicly, it becomes the most recent version and is available to developer builds of the application.   Prototypes aren't meant for Release!  Using a  Prototype  bundle with dynamic updates in a native application is supported by P2UX, but NOT recommended for applications released to the public. It is meant for developer builds try out features quickly and test your custom code. Be aware that every time a public pubish is performed on the application, the native application will pick up the changes when it restarts which means every change made to the application and published as a public  Prototype  would be pushed to your users!    The following code examples set the environment to  P2UXAppCreator_Opt_Env_Recent  for developer testing and debugging purposes.", 
            "title": "Prototype"
        }, 
        {
            "location": "/general/envandpublish/#iostvos", 
            "text": "In Objective-C, edit  AppDelegate.m :  #import  AppDelegate.h  @interface   AppDelegate   ()  @end  @implementation   AppDelegate  -   ( BOOL ) application: ( UIApplication   * ) application   didFinishLaunchingWithOptions: ( NSDictionary   * ) launchOptions   { \n     NSString *   appKey ; \n     appKey   =   @ xxxxx ; \n     NSDictionary   * opts ;  #if DEBUG       opts   =   @{ P2UXAppCreator_Opt_Env :   P2UXAppCreator_Opt_Env_Recent } ;  #endif     \n\n     [ P2UXAppCreator   createApplicationWithKey : appKey   opts : opts   resources : resources   delegate : self ]; \n     return   YES ;  }   In Swift, edit  AppDelegate.swift :  import   UIKit  import   P2UXApp  @UIApplicationMain  class   AppDelegate :   UIResponder ,   UIApplicationDelegate ,   P2UXAppCreatorDelegate   { \n     var   window :   UIWindow ? \n     func   application ( _   application :   UIApplication ,   didFinishLaunchingWithOptions   launchOptions :   [ UIApplicationLaunchOptionsKey :   Any ]?)   -   Bool   { \n         let   appKey   =   xxxxx ; \n         var   opts   :   [ AnyHashable   :   Any ];  #if   DEBUG \n         opts   =   [               P2UXAppCreator_Opt_Env :   P2UXAppCreator_Opt_Env_Recent ,           ]  #endif \n         P2UXAppCreator . createApplication ( withKey :   appKey ,   opts :   opts , \n             resources :   resources ,   delegate :   self ) \n     } \n     func   createBehavior ( forApplication   appid :   String )   -   P2UXAppBehavior   { \n         return   SampleBehavior (); \n     }  }", 
            "title": "iOS/tvOS"
        }, 
        {
            "location": "/general/envandpublish/#android", 
            "text": "Edit  MainActivity.java :  @Override  public   void   onCreate ( Bundle   savedInstanceState )  { \n    mAppKey   =   xxxxx ;       \n    if   (( getApplicationInfo (). flags     ApplicationInfo . FLAG_DEBUGGABLE )   ==   ApplicationInfo . FLAG_DEBUGGABLE )   { \n        if   ( savedInstanceState   ==   null )   { \n            savedInstanceState   =   new   Bundle (); \n        }          savedInstanceState . putString ( P2UXAppCreator . P2UXAppCreator_Opt_Env ,   P2UXAppCreator . P2UXAppCreator_Opt_Env_Recent );      } \n\n    super . onCreate ( savedInstanceState );  }", 
            "title": "Android"
        }, 
        {
            "location": "/general/envandpublish/#stage", 
            "text": "The  Stage  environment is intended for testing an application prior to its release to production. Once application content is staged, it will NOT pick up any changes from subsequent publishes of the application as a  Prototype . Staged application content will also NOT be delivered to native applications using  Production  content.  To make application content available to the  Stage  environment in  Builder :   Click the  Publish  menu dropdown and select  Make it real  from the menu.  Make sure you are in the  Prototypes  tab at the top of the  Make it Real  dialog  Click the  Stage App  button next to the Prototype application bundle.   Click  OK  from the  Stage App Confirmation  to finish the staging.   To use  Stage  content in a native application, the developer needs to setup the PRL environment to refer to staged content.   The environment value to use for Prototypes is:  P2UXAppCreator_Opt_Env_Stage  This setting will fetch the staged version of the Application bundle when the application starts if it doesn't already have the most recent version of the bundle.    Staged content is for testing  Using a  Staged  bundle with dynamic updates in a native application is not recommended for applications released to the public. It is meant for testing an application's content changes prior to release.   The following code examples set the environment to  P2UXAppCreator_Opt_Env_Stage  for developer testing and debugging purposes.", 
            "title": "Stage"
        }, 
        {
            "location": "/general/envandpublish/#iostvos_1", 
            "text": "In Objective-C, edit  AppDelegate.m :  #import  AppDelegate.h  @interface   AppDelegate   ()  @end  @implementation   AppDelegate  -   ( BOOL ) application: ( UIApplication   * ) application   didFinishLaunchingWithOptions: ( NSDictionary   * ) launchOptions   { \n     NSString *   appKey ; \n     appKey   =   @ xxxxx ; \n     NSDictionary   * opts ;  #if DEBUG       opts   =   @{ P2UXAppCreator_Opt_Env :   P2UXAppCreator_Opt_Env_Stage } ;  #endif     \n\n     [ P2UXAppCreator   createApplicationWithKey : appKey   opts : opts   resources : resources   delegate : self ]; \n     return   YES ;  }   In Swift, edit  AppDelegate.swift :  import   UIKit  import   P2UXApp  @UIApplicationMain  class   AppDelegate :   UIResponder ,   UIApplicationDelegate ,   P2UXAppCreatorDelegate   { \n     var   window :   UIWindow ? \n     func   application ( _   application :   UIApplication ,   didFinishLaunchingWithOptions   launchOptions :   [ UIApplicationLaunchOptionsKey :   Any ]?)   -   Bool   { \n         let   appKey   =   xxxxx ; \n         var   opts   :   [ AnyHashable   :   Any ];  #if   DEBUG \n         opts   =   [               P2UXAppCreator_Opt_Env :   P2UXAppCreator_Opt_Env_Stage ,           ]  #endif \n         P2UXAppCreator . createApplication ( withKey :   appKey ,   opts :   opts , \n             resources :   resources ,   delegate :   self ) \n     } \n     func   createBehavior ( forApplication   appid :   String )   -   P2UXAppBehavior   { \n         return   SampleBehavior (); \n     }  }", 
            "title": "iOS/tvOS"
        }, 
        {
            "location": "/general/envandpublish/#android_1", 
            "text": "Edit  MainActivity.java :  @Override  public   void   onCreate ( Bundle   savedInstanceState )  { \n    mAppKey   =   xxxxx ;       \n    if   (( getApplicationInfo (). flags     ApplicationInfo . FLAG_DEBUGGABLE )   ==   ApplicationInfo . FLAG_DEBUGGABLE )   { \n        if   ( savedInstanceState   ==   null )   { \n            savedInstanceState   =   new   Bundle (); \n        }          savedInstanceState . putString ( P2UXAppCreator . P2UXAppCreator_Opt_Env ,   P2UXAppCreator . P2UXAppCreator_Opt_Env_Stage );      } \n\n    super . onCreate ( savedInstanceState );  }", 
            "title": "Android"
        }, 
        {
            "location": "/general/envandpublish/#production-deployed", 
            "text": "The  Production  environment is intended for use in the released production application. This is the default setting for the PRL when no specific environment setting is provided. Application content can only be moved into  Production  after first being moved to the  Stage  environment. Once application content is deployed to production, it will NOT pick up any changes from subsequent publishes of the application as a  Prototype  or from content moved into the  Stage  environment.   To make application content available to the  Production  environment in  Builder :   Click the  Publish  menu dropdown and select  Make it real  from the menu.  Click on the  Apps  tab at the top of the  Make it Real  dialog  Click the  Deploy  button next to the Staged application bundle.    To use a  Production  in a native application, the developer needs to setup the PRL environment to refer to deployed content.   The environment value to use for Prototypes is:  P2UXAppCreator_Opt_Env_Production  This setting will fetch the deployed version of the Application bundle when the application starts if it doesn't have the most recent deployed version of the bundle.   To set the PRL to the  Production  environment, either omit the  P2UXAppCreator_Opt_Env  value from the options at startup or explicitly set it to  P2UXAppCreator_Opt_Env_Production . The previous code examples would work as is for using the  Production  environment for released applications as the other environment alternatives are only set when debugging the application.", 
            "title": "Production (Deployed)"
        }, 
        {
            "location": "/general/startupscreen/", 
            "text": "Introduction\n\n\nWhen using application bundles as live dynamic resources, P2UX will show a loading screen the first time your application runs and doesn't have an application bundle.", 
            "title": "Customizing Startup Screen"
        }, 
        {
            "location": "/general/startupscreen/#introduction", 
            "text": "When using application bundles as live dynamic resources, P2UX will show a loading screen the first time your application runs and doesn't have an application bundle.", 
            "title": "Introduction"
        }, 
        {
            "location": "/datasources/overview/", 
            "text": "Introduction\n\n\nThe P2UX platform offers app creators the unique ability to go beyond simple prototyping by allowing them to integrate external data into their applications. Most importantly, this feature makes it possible to include information in the app that resides outside of the user interface. This data can then be \u201clinked\u201d to properties of the app\u2019s UI components to dynamically change the way the app looks or even works.\n\n\nExternal app data can come from a number of different sources. It may be statically bundled with the app. It may be data that are read and modified locally on the device while the app is running. It may even be obtained from an external source such as a web-based service.\n\n\nThe P2UX platform handles data-related features through the use of Data Sources. Data Sources provide a powerful mechanism that lets app creators model, bundle and access data within their app. Using P2UX, developers and designers can actively define how data will be represented in their user interfaces. For example, it is possible to make an app that integrates data from an external news feed. When the app runs it would request the list of stories from the feed and then link them to the content of a List Component in the UI. This content could, in turn, be used to display the headline and a short summary of the news story. All of this can be accomplished directly in the P2UX Builder visual design tool using Data Sources.\n\n\nP2UX includes three main types of Data Sources that can be defined and used in apps created with the design tool. These are: Static App Data for bundling data directly into the app, Local Device Databases for storing and retrieving data on the device during the running of the app and RESTful Web Services for requesting data from and submitting data to remote services. In addition, the platform employs some built-in Data Sources for integrating device data such as media information and location data. Finally, it is possible to create a custom Data Source in code that can be used in the same manner as the system supported ones. This feature makes it possible to integrate custom data, application functions or services that don\u2019t fit into one of the existing Data Source types.\n\n\nData Source Functionality\n\n\nMost apps will use one or more different Data Sources. For example, an app may use Static data to include some pre-defined set or sets of information. (These might be text for help messages or collections of color values for supporting UI themes.) An app could include a Local Database for storing and retrieving sets of user preferences. Finally, an app might access one or more RESTful Services if the app was, for instance, designed as a front-end to an online service, or if the app creator wanted to include information from third-party services such as Facebook, Twitter or Instagram.\n\n\nRequests\n\n\nP2UX allows app creators to retrieve information from a Data Source via a \u201crequest.\u201d\n \n\n\nA request specification defines how the data from a particular Data Source inquiry will be retrieved or updated. The request can also define arguments to be supplied to the data when the request is made. Additionally, the details of the request specification allow app creators to define whether retrieved data will persist on the device and for how long. \n\n\nApp creators should keep in mind that a Data Source can represent multiple collections of information. How the data are retrieved lies in the hands of the creator and in the details of the request specification. For a Static or Local Data Source, each data request maps directly to a different set of data. With a RESTful Data Source, requests are used to define queries or commands within the service.\n\n\nSchema\n\n\nRequests for data must conform to a specific structure. This structure is defined by use of a \u201cschema.\u201d\n\n\nAny data retrieved from a Data Source will be validated against a creator-defined schema. The P2UX Builder tool also uses the schema when linking parts of the requested data to component properties in the UI. The schema can also include filters and transformations for performing rudimentary changes to the data upon retrieval. These transformations can be simple changes in capitalization of strings or mathematical functions on numbers. They can also provide filtering or sorting of data in an Array.\n\n\nStatic Data Sources\n\n\nStatic Data Sources are a way to include pre-defined sets of data into your application.\n\n\nHow Static Data Works\n\n\nEach request to a Static Data Source includes the complete data for that particular request. However, the data may be \u201cparameterized,\u201d meaning that distinct sets of data can be retrieved depending on the supplied arguments in the request. \n\n\nCommon Uses\n\n\nApp creators frequently use Static data to provide a complex data set that can be queried by the application and, in turn, used to show results to the end user. Common examples of this include help data or catalogs. Another typical use for Static data is as a \u201cplaceholder\u201d model for other, more dynamic, sources of data accessed during the prototyping phase. \n\n\nLocal Data Sources\n\n\nLocal Data Sources work like a small database that resides on a particular device.\n\n\nHow Local Data Works\n\n\nThe creator can retrieve, replace, update or delete local data for a particular request by supplying commands as arguments to the request. (In some cases, an app creator may also include initial \u201cseed\u201d data in a request specification.) In the case of data based on an Array schema type, the request may include arguments for inserting, appending or removing an entry within the Array of data.\n\n\nMuch like app variables in the P2UX platform, changes to Local Data Source requests persist across multiple application runs. However, they provide a mechanism for the addition of more rich and flexible data types.\n\n\nCommon Uses\n\n\nA typical use for Local data is to store user preferences within an app. These might be stored based on user selections the first time the app runs and then retrieved and used on each subsequent invocation to retain the user\u2019s chosen settings. Another common use is for storing data while an app is offline in order to send it to a service at a later time.\n\n\nRESTful Data Sources\n\n\nRESTful Data Sources allow access to data provided by web-based services.\n\n\nHow RESTful Data Works\n\n\nA request within a RESTful Data Source models one of the standard REST method types (GET, PUT, POST, DELETE).  Currently the only supported format for RESTful data on the P2UX platform is JSON. \n\n\nDepending on the method type and the request specification, arguments to a REST request may serve to construct the URL for the request. The arguments may also act as query parameters or be included as \u201cpost\u201d data supplied in the body of the request. Numerous other options can be configured for a RESTful request, including mechanisms for retry and polling requests. \n\n\nCommon Uses\n\n\nFor an app that acts as the front-end UI to a service, a custom RESTful Data Source would be defined that included requests for all of the queries and operations of that service. These operations would then be linked to the app UI when, for example, submitting form-type data or displaying service information on a screen.\n\n\nThe Builder tool also features a number of pre-made RESTful Data Sources for use with common sites including Facebook, Twitter, Instagram and Google services.\n\n\nAuthentication\n\n\nOne key feature unique to RESTful Data Sources is their ability to require authentication.\n\n\nAuthentication allows for the integration of services that require credentialed access. Defined at the Data Source level, authentication works across all requests. However, specific aspects of authentication may be overridden on a per-request basis. P2UX recognizes three primary authentication methods: Basic, Login and OAuth (complying to the OAuth2 authorization protocol).\n\n\nBasic Authentication\n\n\nThis form of authentication supports the HTTP Basic Authentication protocol. The specification can include a username and password for testing, but typically this information would be embedded in custom business logic code. Using basic authentication methods will cause the \u201cAuthorization\u201d header to be included on each request.\n\n\nLogin Authentication\n\n\nLogin Authentication is for traditional user/password submission that uses an HTTP POST method for login. The fields used for login, as well as those returned in the response, can be customized via a schema. The developer would then supply the credentials for the login authentication via custom business logic. \n\n\nOnce login is completed, this method typically relies on session data (i.e. cookies) to retain the authorization. (An advantage of using session data is that the P2UX platform need not add anything additional to the request.)\n\n\nOAuth\n\n\nOauth is the most complex and flexible method of configuring authentication on a RESTful Data Source.\n\n\nThe OAuth method complies with the \nOAuth2 Standard\n. To be precise, OAuth is a collection of authentication methods each defined by a \u201cgrant type.\u201d The P2UX platform supports grant types of AuthCode, Password and Client. Each of these uses a different underlying mechanism to obtain an Authorization Token. The token is then sent along with the individual RESTful requests. With OAuth, client credentials such as \u201cclient id\u201d and \u201cclient secret\u201d are generally managed via static application values or custom business logic.\n\n\nAuthCode Grant Type\n\n\nAuthCode is the authorization grant type used primarily for third-party authorization.\n\n\nFor example, the AuthCode Grant Type would be used to integrate the Facebook API into your application. In such a case, P2UX will provide an embedded web-browser for that is directed to the facebook URL as supplied in the Data Source specification. The user will then authorize access to their Facebook account. Then, the platform re-directs an authorization code back to the application for obtaining the Authorization Token.\n\n\nClient Grant Type\n\n\nClient Grant Type uses a supplied client id and client secret to authorize application access to the service and obtain the Authorization Token.\n\n\nGenerally, Client Grant Type is used to access public APIs or public portions of APIs where the application makes queries directly, rather than on behalf of any user. \n\n\nPassword Grant Type\n\n\nPassword Grant Type provides a way to directly authenticate a user via username and password to acquire the Authorization Token.\n\n\nThis grant type allows authorization of the client application as well. Depending on the services involved, these credentials may be embedded in the custom business logic or they may be obtained via P2UX UI elements that are designed to fit directly into the app\u2019s user interface.", 
            "title": "Overview"
        }, 
        {
            "location": "/datasources/overview/#introduction", 
            "text": "The P2UX platform offers app creators the unique ability to go beyond simple prototyping by allowing them to integrate external data into their applications. Most importantly, this feature makes it possible to include information in the app that resides outside of the user interface. This data can then be \u201clinked\u201d to properties of the app\u2019s UI components to dynamically change the way the app looks or even works.  External app data can come from a number of different sources. It may be statically bundled with the app. It may be data that are read and modified locally on the device while the app is running. It may even be obtained from an external source such as a web-based service.  The P2UX platform handles data-related features through the use of Data Sources. Data Sources provide a powerful mechanism that lets app creators model, bundle and access data within their app. Using P2UX, developers and designers can actively define how data will be represented in their user interfaces. For example, it is possible to make an app that integrates data from an external news feed. When the app runs it would request the list of stories from the feed and then link them to the content of a List Component in the UI. This content could, in turn, be used to display the headline and a short summary of the news story. All of this can be accomplished directly in the P2UX Builder visual design tool using Data Sources.  P2UX includes three main types of Data Sources that can be defined and used in apps created with the design tool. These are: Static App Data for bundling data directly into the app, Local Device Databases for storing and retrieving data on the device during the running of the app and RESTful Web Services for requesting data from and submitting data to remote services. In addition, the platform employs some built-in Data Sources for integrating device data such as media information and location data. Finally, it is possible to create a custom Data Source in code that can be used in the same manner as the system supported ones. This feature makes it possible to integrate custom data, application functions or services that don\u2019t fit into one of the existing Data Source types.", 
            "title": "Introduction"
        }, 
        {
            "location": "/datasources/overview/#data-source-functionality", 
            "text": "Most apps will use one or more different Data Sources. For example, an app may use Static data to include some pre-defined set or sets of information. (These might be text for help messages or collections of color values for supporting UI themes.) An app could include a Local Database for storing and retrieving sets of user preferences. Finally, an app might access one or more RESTful Services if the app was, for instance, designed as a front-end to an online service, or if the app creator wanted to include information from third-party services such as Facebook, Twitter or Instagram.", 
            "title": "Data Source Functionality"
        }, 
        {
            "location": "/datasources/overview/#requests", 
            "text": "P2UX allows app creators to retrieve information from a Data Source via a \u201crequest.\u201d    A request specification defines how the data from a particular Data Source inquiry will be retrieved or updated. The request can also define arguments to be supplied to the data when the request is made. Additionally, the details of the request specification allow app creators to define whether retrieved data will persist on the device and for how long.   App creators should keep in mind that a Data Source can represent multiple collections of information. How the data are retrieved lies in the hands of the creator and in the details of the request specification. For a Static or Local Data Source, each data request maps directly to a different set of data. With a RESTful Data Source, requests are used to define queries or commands within the service.", 
            "title": "Requests"
        }, 
        {
            "location": "/datasources/overview/#schema", 
            "text": "Requests for data must conform to a specific structure. This structure is defined by use of a \u201cschema.\u201d  Any data retrieved from a Data Source will be validated against a creator-defined schema. The P2UX Builder tool also uses the schema when linking parts of the requested data to component properties in the UI. The schema can also include filters and transformations for performing rudimentary changes to the data upon retrieval. These transformations can be simple changes in capitalization of strings or mathematical functions on numbers. They can also provide filtering or sorting of data in an Array.", 
            "title": "Schema"
        }, 
        {
            "location": "/datasources/overview/#static-data-sources", 
            "text": "Static Data Sources are a way to include pre-defined sets of data into your application.", 
            "title": "Static Data Sources"
        }, 
        {
            "location": "/datasources/overview/#how-static-data-works", 
            "text": "Each request to a Static Data Source includes the complete data for that particular request. However, the data may be \u201cparameterized,\u201d meaning that distinct sets of data can be retrieved depending on the supplied arguments in the request.", 
            "title": "How Static Data Works"
        }, 
        {
            "location": "/datasources/overview/#common-uses", 
            "text": "App creators frequently use Static data to provide a complex data set that can be queried by the application and, in turn, used to show results to the end user. Common examples of this include help data or catalogs. Another typical use for Static data is as a \u201cplaceholder\u201d model for other, more dynamic, sources of data accessed during the prototyping phase.", 
            "title": "Common Uses"
        }, 
        {
            "location": "/datasources/overview/#local-data-sources", 
            "text": "Local Data Sources work like a small database that resides on a particular device.", 
            "title": "Local Data Sources"
        }, 
        {
            "location": "/datasources/overview/#how-local-data-works", 
            "text": "The creator can retrieve, replace, update or delete local data for a particular request by supplying commands as arguments to the request. (In some cases, an app creator may also include initial \u201cseed\u201d data in a request specification.) In the case of data based on an Array schema type, the request may include arguments for inserting, appending or removing an entry within the Array of data.  Much like app variables in the P2UX platform, changes to Local Data Source requests persist across multiple application runs. However, they provide a mechanism for the addition of more rich and flexible data types.", 
            "title": "How Local Data Works"
        }, 
        {
            "location": "/datasources/overview/#common-uses_1", 
            "text": "A typical use for Local data is to store user preferences within an app. These might be stored based on user selections the first time the app runs and then retrieved and used on each subsequent invocation to retain the user\u2019s chosen settings. Another common use is for storing data while an app is offline in order to send it to a service at a later time.", 
            "title": "Common Uses"
        }, 
        {
            "location": "/datasources/overview/#restful-data-sources", 
            "text": "RESTful Data Sources allow access to data provided by web-based services.", 
            "title": "RESTful Data Sources"
        }, 
        {
            "location": "/datasources/overview/#how-restful-data-works", 
            "text": "A request within a RESTful Data Source models one of the standard REST method types (GET, PUT, POST, DELETE).  Currently the only supported format for RESTful data on the P2UX platform is JSON.   Depending on the method type and the request specification, arguments to a REST request may serve to construct the URL for the request. The arguments may also act as query parameters or be included as \u201cpost\u201d data supplied in the body of the request. Numerous other options can be configured for a RESTful request, including mechanisms for retry and polling requests.", 
            "title": "How RESTful Data Works"
        }, 
        {
            "location": "/datasources/overview/#common-uses_2", 
            "text": "For an app that acts as the front-end UI to a service, a custom RESTful Data Source would be defined that included requests for all of the queries and operations of that service. These operations would then be linked to the app UI when, for example, submitting form-type data or displaying service information on a screen.  The Builder tool also features a number of pre-made RESTful Data Sources for use with common sites including Facebook, Twitter, Instagram and Google services.", 
            "title": "Common Uses"
        }, 
        {
            "location": "/datasources/overview/#authentication", 
            "text": "One key feature unique to RESTful Data Sources is their ability to require authentication.  Authentication allows for the integration of services that require credentialed access. Defined at the Data Source level, authentication works across all requests. However, specific aspects of authentication may be overridden on a per-request basis. P2UX recognizes three primary authentication methods: Basic, Login and OAuth (complying to the OAuth2 authorization protocol).", 
            "title": "Authentication"
        }, 
        {
            "location": "/datasources/overview/#basic-authentication", 
            "text": "This form of authentication supports the HTTP Basic Authentication protocol. The specification can include a username and password for testing, but typically this information would be embedded in custom business logic code. Using basic authentication methods will cause the \u201cAuthorization\u201d header to be included on each request.", 
            "title": "Basic Authentication"
        }, 
        {
            "location": "/datasources/overview/#login-authentication", 
            "text": "Login Authentication is for traditional user/password submission that uses an HTTP POST method for login. The fields used for login, as well as those returned in the response, can be customized via a schema. The developer would then supply the credentials for the login authentication via custom business logic.   Once login is completed, this method typically relies on session data (i.e. cookies) to retain the authorization. (An advantage of using session data is that the P2UX platform need not add anything additional to the request.)", 
            "title": "Login Authentication"
        }, 
        {
            "location": "/datasources/overview/#oauth", 
            "text": "Oauth is the most complex and flexible method of configuring authentication on a RESTful Data Source.  The OAuth method complies with the  OAuth2 Standard . To be precise, OAuth is a collection of authentication methods each defined by a \u201cgrant type.\u201d The P2UX platform supports grant types of AuthCode, Password and Client. Each of these uses a different underlying mechanism to obtain an Authorization Token. The token is then sent along with the individual RESTful requests. With OAuth, client credentials such as \u201cclient id\u201d and \u201cclient secret\u201d are generally managed via static application values or custom business logic.", 
            "title": "OAuth"
        }, 
        {
            "location": "/datasources/overview/#authcode-grant-type", 
            "text": "AuthCode is the authorization grant type used primarily for third-party authorization.  For example, the AuthCode Grant Type would be used to integrate the Facebook API into your application. In such a case, P2UX will provide an embedded web-browser for that is directed to the facebook URL as supplied in the Data Source specification. The user will then authorize access to their Facebook account. Then, the platform re-directs an authorization code back to the application for obtaining the Authorization Token.", 
            "title": "AuthCode Grant Type"
        }, 
        {
            "location": "/datasources/overview/#client-grant-type", 
            "text": "Client Grant Type uses a supplied client id and client secret to authorize application access to the service and obtain the Authorization Token.  Generally, Client Grant Type is used to access public APIs or public portions of APIs where the application makes queries directly, rather than on behalf of any user.", 
            "title": "Client Grant Type"
        }, 
        {
            "location": "/datasources/overview/#password-grant-type", 
            "text": "Password Grant Type provides a way to directly authenticate a user via username and password to acquire the Authorization Token.  This grant type allows authorization of the client application as well. Depending on the services involved, these credentials may be embedded in the custom business logic or they may be obtained via P2UX UI elements that are designed to fit directly into the app\u2019s user interface.", 
            "title": "Password Grant Type"
        }
    ]
}