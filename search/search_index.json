{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to the P2UX Developer Site\n\n\nWe are working on bringing more documentation and samples for developers. Check back often for updates.\n\n\nClient Libraries for Android and iOS/tvOS\n\n\nClient libraries for both Android and iOS/tvOS are available for building native applications. To learn more about how to use the P2UX client libraries, try our Quick Start guide for \niOS\n or \nAndroid\n.\n\n\nBelow are links to the latest client library releases available from GitHub.\n\n\nLatest Official Release:\n\n\n1.1.4.82\n\n\n\n\nLots of bug fixes\n\n\nSome optimization of list controls\n\n\n\n\nFeeling Brave?\n\n\nTry the next release on deck (Currently Being Tested):\n\n\n1.1.5.84\n\n\nMore Docs Coming Soon!\n\n\nWe are working hard to bring more documents and examples to the site. If you have any questions that aren't available in the existing docs, please contact", 
            "title": "Latest News"
        }, 
        {
            "location": "/#welcome-to-the-p2ux-developer-site", 
            "text": "We are working on bringing more documentation and samples for developers. Check back often for updates.", 
            "title": "Welcome to the P2UX Developer Site"
        }, 
        {
            "location": "/#client-libraries-for-android-and-iostvos", 
            "text": "Client libraries for both Android and iOS/tvOS are available for building native applications. To learn more about how to use the P2UX client libraries, try our Quick Start guide for  iOS  or  Android .  Below are links to the latest client library releases available from GitHub.", 
            "title": "Client Libraries for Android and iOS/tvOS"
        }, 
        {
            "location": "/#latest-official-release", 
            "text": "1.1.4.82   Lots of bug fixes  Some optimization of list controls", 
            "title": "Latest Official Release:"
        }, 
        {
            "location": "/#feeling-brave", 
            "text": "Try the next release on deck (Currently Being Tested):  1.1.5.84", 
            "title": "Feeling Brave?"
        }, 
        {
            "location": "/#more-docs-coming-soon", 
            "text": "We are working hard to bring more documents and examples to the site. If you have any questions that aren't available in the existing docs, please contact", 
            "title": "More Docs Coming Soon!"
        }, 
        {
            "location": "/ios/quickstart/", 
            "text": "Introduction\n\n\nWhat follows is a detailed tutorial that walks developers through all of the steps involved in creating a customizable iOS or tvOS application using P2UX. Developers should be familiar with the Xcode integrated development environment for MacOS and either the Swift or the Objective-C programming languages for custom coding.\n\n\n\n\nTerminology\n\n\nThroughout the P2UX documentation the \u201cdeveloper\u201d refers to you, the reader who is developing an app with P2UX. The \u201cdesigner\u201d refers to the individual whose principal job is to create the appearance and style of the app and its visual components. \u201cPRL\u201d refers to the P2UX Rendering Library for iOS, which controls the creation and workflow of content created for the P2UX platform.\n\n\n\n\n\n\nCoding examples and code additions\n\n\nIn the coding examples below and throughout the documentation, changes and additions to be made by the developer are rendered with a blue highlight.\n\n\n\n\nP2UX versus the standard Xcode environment\n\n\nP2UX based applications for iOS are easy to customize and extend. Since the P2UX iOS rendering library is based on the native UIKit and other iOS primitives, writing custom business logic and integrating custom controls works much the same as it does when writing iOS applications using Xcode.\nWith the P2UX platform, Storyboards and XIB based User Interface (UI) definitions are no longer required. Instead, applications use P2UX Portable UX Bundles (PUB) either as embedded or dynamically accessed resources. Additionally, P2UX provides hooks to developers that allow them access to all of the components of P2UX, as well as the ability to fully customize instances of the application.\n\n\nGetting Started with P2UX and Xcode\n\n\nObjective-C or Swift\n\n\nP2UX native rendering libraries for iOS can be extended using either Objective-C or Swift. Developers are free to choose one or the other of these coding languages at any stage during the development process. The instructions below provide explicit reference to the proper use of either language in each applicable step that follows.\n\n\nCreating a new application\n\n\nFrom the Xcode environment:\n\n\n\n\nStart the Xcode new project wizard by selecting File-\nNew-\nProject.\n\n\nFrom the new project wizard select \u201cSingle View Application\u201d as the starting point for your app.\n\n\n\nThe rest of the options in the new project wizard are dependent on your application and the selection of either Swift or Objective-C.\n\n\n\n\nConnecting the PUB. Defining assets and custom behaviors\n\n\nNow that the initial project is set up, make the necessary changes to include the PUB for the application.\n\n\n\n\nRemove the Storyboard\n\n\n\n\nWhen Xcode creates a new project, it automatically generates a blank storyboard file called \nMain.storyboard\n. Rather than using storyboards to create the UI for your app, your app will use a PUB. To accomplish this, simply remove the \nMain.storyboard\n file from your project.\n\n\nFirst, delete the file itself from your project (move to trash).\n\n\n\nNext, in \nInfo.plist\n, remove the key \nMain storyboard file base name\n.\n\n\n\n\nSelect the Info.plist file from the project navigator.\n\n\nFrom the editor on the right side, select the \nMain storyboard file base name\n row.\n\n\nDouble click on the word \nMain\n from that row to edit it and delete the text, leaving the \nValue\n field empty.\n\n\nSave the modified \nInfo.plist\n file.\n\n\n\n\n\nFinally, in the project navigator under \u201cDeployment Info,\u201d delete the text from \u201cMain Interface\u201d so that the text field is blank.\n\n\n\n\nSelect the application name from the project navigator.\n\n\nFrom the right side editor, select the application target.\n\n\nSelect the \nGeneral\n tab (shown highlighted in blue in the example screenshot)\n\n\nIn the section titled \nDeployment Info\n, select the text in the \nMain Interface\n field and delete the text, leaving the field empty.\n\n\nSave the project changes.\n\n\nNow, your app runs without a storyboard.\n\n\n\n\nEnabling P2UX iOS Frameworks\n\n\nThe next step in developing your project with P2UX is to include the P2UX frameworks for iOS. The latest frameworks can be downloaded from this site (INSERT URL ONCE AVAILABLE). Once the frameworks are downloaded:\n\n\n\n\nUnzip the framework files.\n\n\nCopy the P2UXCore.framework, P2UXApp.framework and postbuild.sh files into the root of your project directory.\n\n\nAdd the framework files to your project in Xcode.\n\n\nSelect your project in the project navigator on the left side and then click on the \nTarget\n for your project.\n\n\nSelect the \nGeneral\n tab in your project target settings.\n\n\nIn the section labeled \nEmbedded Binaries\n, click the + button, then click the \nAdd Other\u2026\n button from the drop down dialog.\n\n\n\nFind the two framework files you added to your project folder, select them and then click \nOpen\n.\n\n\n\n\n\n\nAdd \npostbuild.sh\n as a Build Phases script.\n\n\nSelect your project in the project navigator on the left side and then click on the \nTarget\n for your project.\n\n\nSelect the \nBuild Phases\n tab for your project.\n\n\nClick the + button in the Build Phases window to add a new build step and select \nNew Run Script Phase\n from the drop down menu\n\n\n\nIn the new \nRun Script\n phase, click in the shell script area and paste in the text \n./postbuild.sh\n. This assumes you copied the \npostbuild.sh\n file from the earlier step into the root of your project.\n\n\n\n\n\n\n\n\n\nRemoving unused binaries by running the\n \npostbuild.sh\n \nscript\n\n\nThe step above removes unused binaries from the P2UX frameworks for the current architecture. By default, P2UX frameworks are built as fat binaries, that is, they have compiled support (binaries) for actual iOS devices and for mac-based simulators all in the same framework bundle. This means that both Xcode simulators and real iOS devices use the same framework files when running the application.\n\n\nThe \npostbuild.sh\n script will now run at the end of the build process and remove the extra binary (depending on the target device for your build) from the framework bundled into your application. This step is required for submission of an application to iTunes.\n\n\nMoving the app from Builder to Xcode\n\n\n\n\nApp License and AppDelegate\n\n\n\n\nFirst, edit the AppDelegate files. Xcode automatically generates AppDelegate files when you create a project. These files are AppDelegate.h and AppDelegate.m if you are using Objective-C. The file is AppDelegate.swift if you are using Swift.\n\n\n(Note, additions to be made to your code are rendered here and throughout the document in blue font.)\n\n\nIf your project is written in Objective-C, edit the \nAppDelegate.h\n file to look like this:\n\n\n#import \nUIKit/UIKit.h\n\n\n@\nimport\n \nP2UXApp\n;\n\n\n@interface\n \nAppDelegate\n : \nUIResponder\n \nUIApplicationDelegate\n,\n \nP2UXAppCreatorDelegate\n\n\n@property\n \n(\nstrong\n,\n \nnonatomic\n)\n \nUIWindow\n \n*\nwindow\n;\n\n\n@end\n\n\n\n\n\n\nEdit the \nAppDelegate.m\n file to look like this:\n\n\n#import \nAppDelegate.h\n\n\n@interface\n \nAppDelegate\n \n()\n\n\n@end\n\n\n@implementation\n \nAppDelegate\n\n\n-\n \n(\nBOOL\n)\napplication:\n(\nUIApplication\n \n*\n)\napplication\n \ndidFinishLaunchingWithOptions:\n(\nNSDictionary\n \n*\n)\nlaunchOptions\n \n{\n\n\n    \nNSString\n*\n \nappKey\n \n=\n \n@\nxxxxx\n;\n\n\n    \nNSDictionary\n*\n \nopts\n;\n\n\n#if DEBUG\n\n\n    \nopts\n \n=\n \n@{\nP2UXAppCreator_Opt_Env\n:\n \nP2UXAppCreator_Opt_Env_Stage\n}\n;\n\n\n#endif\n\n\n    \n[\nP2UXAppCreator\n \ncreateApplicationWithKey\n:\nappKey\n \nopts\n:\nopts\n \nresources\n:\nnil\n \ndelegate\n:\nself\n];\n\n\n    \nreturn\n \nYES\n;\n\n\n}\n\n\n...\n\n\n@end\n\n\n\n\n\n\nIf your project is written in Swift, edit the \nAppDelegate.swift\n file to look like this:\n\n\nimport\n \nUIKit\n\n\nimport\n \nP2UXApp\n\n\n@UIApplicationMain\n\n\nclass\n \nAppDelegate\n:\n \nUIResponder\n,\n \nUIApplicationDelegate\n,\n \nP2UXAppCreatorDelegate\n \n{\n\n    \nvar\n \nwindow\n:\n \nUIWindow\n?\n\n    \nfunc\n \napplication\n(\n_\n \napplication\n:\n \nUIApplication\n,\n \ndidFinishLaunchingWithOptions\n \nlaunchOptions\n:\n \n[\nUIApplicationLaunchOptionsKey\n:\n \nAny\n]\n?\n)\n \n-\n \nBool\n \n{\n\n\n        \nlet\n \nappKey\n \n=\n \nxxxxx\n;\n\n\n        \nvar\n \nopts\n \n:\n \n[\nAnyHashable\n \n:\n \nAny\n];\n\n\n#if DEBUG\n\n\n        \nopts\n \n=\n \n[\n\n\n            \nP2UXAppCreator_Opt_Env\n:\n \nP2UXAppCreator_Opt_Env_Prototype\n]\n\n\n#endif\n\n\n        \nP2UXAppCreator\n.\ncreateApplication\n(\nwithKey\n:\n \nappKey\n,\n \nopts\n:\n \nopts\n,\n \nresources\n:\n \nnil\n,\n \ndelegate\n:\n \nself\n)\n\n\n        \nreturn\n \ntrue\n\n    \n}\n\n    \n...\n\n\n}\n\n\n\n\n\n\nThe AppDelegate calls the \nP2UXAppCreator\n method \ncreateApplication\n using the appKey, which initializes the PRL with the application information. In this example, options are supplied to the \ncreateApplication\n method to use the prototype version of the application when the application is compiled for debugging. To use the production version of the application for debugging, remove the options.\n\n\nNext, retrieve the app\u2019s license. In Builder, to the right of the publish button are further options in a drop-down menu. Select \nGet App License\n from the menu and a window will pop up with your app\u2019s license. Copy the license.\n\n\nIn AppDelegate, replace the \nxxxxx\n in the line that reads \nappKey = @\u201dxxxxx\";\n with your app\u2019s license (retrieved earlier from Builder.)\n\n\n\n\nNote\n\n\nAt this point the application setup is complete and the app should run successfully.\n\n\n\n\nThe PUB and network connectivity\n\n\nThe next step in the  process requires developer awareness of the default PUB status and access to a network.\n\n\nBy default, the application accesses the PUB dynamically. This means that when the application is first installed, the P2UX rendering library (PRL) will authenticate the application key and then download the PUB before running the application content.\n\n\nThe first run of an application requires network connectivity. Otherwise, P2UX will return an error. The PUB\u2019s default update policy is automatic. This means that the PRL will automatically check for updates each time the application runs. The library will also download any updates that are available, and then notify the user that the application will restart to apply any updates.\n\n\nStatic Assets\n\n\nIn some cases, a developer may opt to use only static assets rather than require network access for an app. In this situation, the PUB can be added to the application as a collection of static assets. To achieve this, follow these steps:\n\n\n\n\nNote\n\n\nThis feature requires downloading your application PUB from Builder. This feature will be integrated as part of the P2UX Coordinator application for Mac OS\n\n\n\n\n\n\nIn Builder, download the published PUB for application\n\n\nSteps to download PUB will go here\n\n\n\n\n\n\nUnzip the PUB files and copy the assets into a folder inside your project directory.\n\n\nIn Xcode, add the folder to the project.\n\n\nFrom the project navigator, select the group folder with your application name.\n\n\nRight click and select \nAdd Files to \u2018app name\u2019\n\n\n\n\nFrom the dialog, click the \nOptions\n button in the bottom left corner and select \nCreate folder References\n from the \nAdded folders\n option\n\n\n\nSelect the folder containing the PUB assets and click the \nAdd\n button to add them to your project.\n\n\n\n\n\n\n\n\nIn the example, this folder is called \nphone_pub\n.\n\n\nIn order to incorporate these files into your project, as well as to adjust the resource use settings, you must change the AppDelegate file.\n\n\nFor projects in Objective-C, edit the \nAppDelegate.m\n file to look like this:   \n\n\n#import \nAppDelegate.h\n\n\n#import \nSampleBehavior.h\n\n\n@interface\n \nAppDelegate\n \n()\n\n\n@end\n\n\n@implementation\n \nAppDelegate\n\n\n-\n \n(\nBOOL\n)\napplication:\n(\nUIApplication\n \n*\n)\napplication\n \ndidFinishLaunchingWithOptions:\n(\nNSDictionary\n \n*\n)\nlaunchOptions\n \n{\n\n\n    \nNSString\n*\n \nappKey\n \n=\n \n@\nxxxxx\n;\n\n    \nNSDictionary\n \n*\nopts\n;\n\n\n#if DEBUG\n\n    \nopts\n \n=\n \n@{\nP2UXAppCreator_Opt_Env\n:\n \nP2UXAppCreator_Opt_Env_Prototype\n}\n;\n\n\n#endif    \n\n\n    \nNSDictionary\n \n*\nresources\n \n=\n \n@[\n\n\n        \n@{\nP2UXApp_PackageAttrib_FormFactor\n:\n \n[\nNSNumber\n \nnumberWithInteger\n:\nP2UXFormFactor_Phone\n],\n \n\n          \nP2UXApp_PackageAttrib_Type\n:\nP2UXApp_PackageType_Static\n,\n \n\n          \nP2UXApp_PackageAttrib_Package\n:\n@\nphone_pub\n,\n\n\n          \nP2UXApp_PackageAttrib_Update\n:\nP2UXApp_PackageUpdate_None\n}]\n;\n\n\n\n    \n[\nP2UXAppCreator\n \ncreateApplicationWithKey\n:\nappKey\n \nopts\n:\nopts\n \nresources\n:\nresources\n \ndelegate\n:\nself\n];\n\n    \nreturn\n \nYES\n;\n\n\n}\n\n\n@end\n\n\n\n\n\n\nFor projects in Swift, edit the \nAppDelegate.swift\n file to look like this:\n\n\nimport\n \nUIKit\n\n\nimport\n \nP2UXApp\n\n\n@UIApplicationMain\n\n\nclass\n \nAppDelegate\n:\n \nUIResponder\n,\n \nUIApplicationDelegate\n,\n \nP2UXAppCreatorDelegate\n \n{\n\n    \nvar\n \nwindow\n:\n \nUIWindow\n?\n\n    \nfunc\n \napplication\n(\n_\n \napplication\n:\n \nUIApplication\n,\n \ndidFinishLaunchingWithOptions\n \nlaunchOptions\n:\n \n[\nUIApplicationLaunchOptionsKey\n:\n \nAny\n]\n?\n)\n \n-\n \nBool\n \n{\n\n        \nlet\n \nappKey\n \n=\n \nxxxxx\n;\n\n        \nvar\n \nopts\n \n:\n \n[\nAnyHashable\n \n:\n \nAny\n];\n\n\n#if DEBUG\n\n        \nopts\n \n=\n \n[\n\n            \nP2UXAppCreator_Opt_Env\n:\n \nP2UXAppCreator_Opt_Env_Prototype\n\n        \n]\n\n\n#endif\n\n\n        \nvar\n \nphoneResources\n:\n \n[\nAnyHashable\n \n:\n \nAny\n]\n \n=\n \n[\n\n\n            \nP2UXApp_PackageAttrib_FormFactor\n:\n \nP2UXFormFactor\n.\nphone\n,\n\n\n            \nP2UXApp_PackageAttrib_Type\n:\n \nP2UXApp_PackageType_Static\n,\n\n\n            \nP2UXApp_PackageAttrib_Package\n:\n \nphone_pub\n,\n\n\n            \nP2UXApp_PackageAttrib_Update\n:\n \nP2UXApp_PackageUpdate_None\n\n\n        \n]\n\n\n\n        \nvar\n \nresources\n \n:\n \n[\nAny\n]\n \n=\n \n[\n\n            \nphoneResources\n\n        \n]\n\n        \nP2UXAppCreator\n.\ncreateApplication\n(\nwithKey\n:\n \nappKey\n,\n \nopts\n:\n \nopts\n,\n\n        \nresources\n:\n \nresources\n,\n \ndelegate\n:\n \nself\n)\n\n        \nreturn\n \ntrue\n\n    \n}\n\n\n}\n\n\n\n\n\n\nDefining Custom Resource Attributes\n\n\nIf desired, the developer can define specific resource attributes for the app. These attributes define where the assets of the application are located and how those assets are updated.\n\n\nThe resources parameter is an array of objects. Each object in the array defines the PUB usage for a particular form factor (Phone, Tablet, TV) using key value pairs. If the application supports multiple form factors, create an object in the resources array for each form factor.\n\n\nCustomize the resource attributes according to the possibilities below:\n\n\n\n\n\n\n\n\nResource Attribute\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nP2UXApp_PackageAttrib_FormFactor\n\n\nDefines which form factor the attributes reference.\nPossible Values:\nP2UXFormFactor_Phone\nP2UXFormFactor_Tablet\nP2UXFormFactor_TV\n\n\n\n\n\n\nP2UXApp_PackageAttrib_Type\n\n\nDefines the type of resources for the form factor\nPossible Values:\nP2UXApp_PackageType_Static\nP2UXApp_PackageType_Remote\n\n\n\n\n\n\nP2UXApp_PackageAttrib_Package\n\n\nDefines the name of the folder within the application bundle containing assets when the P2UXApp_PackageAttrib_Type is P2UXApp_PackageType_Static.\n\n\n\n\n\n\nP2UXApp_PackageAttrib_Update\n\n\nDefines how to update the application assets\nPossible Values:\nP2UXApp_PackageUpdate_None\nP2UXApp_PackageUpdate_Auto\nP2UXApp_PackageUpdate_Manual\n\n\n\n\n\n\n\n\nAfter defining the resources, change the resources line in the app code from \u201cnil\u201d to \u201cresources\u201d (as highlighted in the example code above).", 
            "title": "Quick Start"
        }, 
        {
            "location": "/ios/quickstart/#introduction", 
            "text": "What follows is a detailed tutorial that walks developers through all of the steps involved in creating a customizable iOS or tvOS application using P2UX. Developers should be familiar with the Xcode integrated development environment for MacOS and either the Swift or the Objective-C programming languages for custom coding.   Terminology  Throughout the P2UX documentation the \u201cdeveloper\u201d refers to you, the reader who is developing an app with P2UX. The \u201cdesigner\u201d refers to the individual whose principal job is to create the appearance and style of the app and its visual components. \u201cPRL\u201d refers to the P2UX Rendering Library for iOS, which controls the creation and workflow of content created for the P2UX platform.    Coding examples and code additions  In the coding examples below and throughout the documentation, changes and additions to be made by the developer are rendered with a blue highlight.   P2UX versus the standard Xcode environment  P2UX based applications for iOS are easy to customize and extend. Since the P2UX iOS rendering library is based on the native UIKit and other iOS primitives, writing custom business logic and integrating custom controls works much the same as it does when writing iOS applications using Xcode.\nWith the P2UX platform, Storyboards and XIB based User Interface (UI) definitions are no longer required. Instead, applications use P2UX Portable UX Bundles (PUB) either as embedded or dynamically accessed resources. Additionally, P2UX provides hooks to developers that allow them access to all of the components of P2UX, as well as the ability to fully customize instances of the application.", 
            "title": "Introduction"
        }, 
        {
            "location": "/ios/quickstart/#getting-started-with-p2ux-and-xcode", 
            "text": "Objective-C or Swift  P2UX native rendering libraries for iOS can be extended using either Objective-C or Swift. Developers are free to choose one or the other of these coding languages at any stage during the development process. The instructions below provide explicit reference to the proper use of either language in each applicable step that follows.", 
            "title": "Getting Started with P2UX and Xcode"
        }, 
        {
            "location": "/ios/quickstart/#creating-a-new-application", 
            "text": "From the Xcode environment:   Start the Xcode new project wizard by selecting File- New- Project.  From the new project wizard select \u201cSingle View Application\u201d as the starting point for your app.  The rest of the options in the new project wizard are dependent on your application and the selection of either Swift or Objective-C.", 
            "title": "Creating a new application"
        }, 
        {
            "location": "/ios/quickstart/#connecting-the-pub-defining-assets-and-custom-behaviors", 
            "text": "Now that the initial project is set up, make the necessary changes to include the PUB for the application.   Remove the Storyboard   When Xcode creates a new project, it automatically generates a blank storyboard file called  Main.storyboard . Rather than using storyboards to create the UI for your app, your app will use a PUB. To accomplish this, simply remove the  Main.storyboard  file from your project.  First, delete the file itself from your project (move to trash).  Next, in  Info.plist , remove the key  Main storyboard file base name .   Select the Info.plist file from the project navigator.  From the editor on the right side, select the  Main storyboard file base name  row.  Double click on the word  Main  from that row to edit it and delete the text, leaving the  Value  field empty.  Save the modified  Info.plist  file.   Finally, in the project navigator under \u201cDeployment Info,\u201d delete the text from \u201cMain Interface\u201d so that the text field is blank.   Select the application name from the project navigator.  From the right side editor, select the application target.  Select the  General  tab (shown highlighted in blue in the example screenshot)  In the section titled  Deployment Info , select the text in the  Main Interface  field and delete the text, leaving the field empty.  Save the project changes. \nNow, your app runs without a storyboard.", 
            "title": "Connecting the PUB. Defining assets and custom behaviors"
        }, 
        {
            "location": "/ios/quickstart/#enabling-p2ux-ios-frameworks", 
            "text": "The next step in developing your project with P2UX is to include the P2UX frameworks for iOS. The latest frameworks can be downloaded from this site (INSERT URL ONCE AVAILABLE). Once the frameworks are downloaded:   Unzip the framework files.  Copy the P2UXCore.framework, P2UXApp.framework and postbuild.sh files into the root of your project directory.  Add the framework files to your project in Xcode.  Select your project in the project navigator on the left side and then click on the  Target  for your project.  Select the  General  tab in your project target settings.  In the section labeled  Embedded Binaries , click the + button, then click the  Add Other\u2026  button from the drop down dialog.  Find the two framework files you added to your project folder, select them and then click  Open .    Add  postbuild.sh  as a Build Phases script.  Select your project in the project navigator on the left side and then click on the  Target  for your project.  Select the  Build Phases  tab for your project.  Click the + button in the Build Phases window to add a new build step and select  New Run Script Phase  from the drop down menu  In the new  Run Script  phase, click in the shell script area and paste in the text  ./postbuild.sh . This assumes you copied the  postbuild.sh  file from the earlier step into the root of your project.     Removing unused binaries by running the   postbuild.sh   script  The step above removes unused binaries from the P2UX frameworks for the current architecture. By default, P2UX frameworks are built as fat binaries, that is, they have compiled support (binaries) for actual iOS devices and for mac-based simulators all in the same framework bundle. This means that both Xcode simulators and real iOS devices use the same framework files when running the application.  The  postbuild.sh  script will now run at the end of the build process and remove the extra binary (depending on the target device for your build) from the framework bundled into your application. This step is required for submission of an application to iTunes.", 
            "title": "Enabling P2UX iOS Frameworks"
        }, 
        {
            "location": "/ios/quickstart/#moving-the-app-from-builder-to-xcode", 
            "text": "App License and AppDelegate   First, edit the AppDelegate files. Xcode automatically generates AppDelegate files when you create a project. These files are AppDelegate.h and AppDelegate.m if you are using Objective-C. The file is AppDelegate.swift if you are using Swift.  (Note, additions to be made to your code are rendered here and throughout the document in blue font.)  If your project is written in Objective-C, edit the  AppDelegate.h  file to look like this:  #import  UIKit/UIKit.h  @ import   P2UXApp ;  @interface   AppDelegate  :  UIResponder   UIApplicationDelegate ,   P2UXAppCreatorDelegate  @property   ( strong ,   nonatomic )   UIWindow   * window ;  @end   Edit the  AppDelegate.m  file to look like this:  #import  AppDelegate.h  @interface   AppDelegate   ()  @end  @implementation   AppDelegate  -   ( BOOL ) application: ( UIApplication   * ) application   didFinishLaunchingWithOptions: ( NSDictionary   * ) launchOptions   {       NSString *   appKey   =   @ xxxxx ;       NSDictionary *   opts ;  #if DEBUG       opts   =   @{ P2UXAppCreator_Opt_Env :   P2UXAppCreator_Opt_Env_Stage } ;  #endif       [ P2UXAppCreator   createApplicationWithKey : appKey   opts : opts   resources : nil   delegate : self ];       return   YES ;  }  ...  @end   If your project is written in Swift, edit the  AppDelegate.swift  file to look like this:  import   UIKit  import   P2UXApp  @UIApplicationMain  class   AppDelegate :   UIResponder ,   UIApplicationDelegate ,   P2UXAppCreatorDelegate   { \n     var   window :   UIWindow ? \n     func   application ( _   application :   UIApplication ,   didFinishLaunchingWithOptions   launchOptions :   [ UIApplicationLaunchOptionsKey :   Any ] ? )   -   Bool   {           let   appKey   =   xxxxx ;           var   opts   :   [ AnyHashable   :   Any ];  #if DEBUG           opts   =   [               P2UXAppCreator_Opt_Env :   P2UXAppCreator_Opt_Env_Prototype ]  #endif           P2UXAppCreator . createApplication ( withKey :   appKey ,   opts :   opts ,   resources :   nil ,   delegate :   self )           return   true \n     } \n     ...  }   The AppDelegate calls the  P2UXAppCreator  method  createApplication  using the appKey, which initializes the PRL with the application information. In this example, options are supplied to the  createApplication  method to use the prototype version of the application when the application is compiled for debugging. To use the production version of the application for debugging, remove the options.  Next, retrieve the app\u2019s license. In Builder, to the right of the publish button are further options in a drop-down menu. Select  Get App License  from the menu and a window will pop up with your app\u2019s license. Copy the license. \nIn AppDelegate, replace the  xxxxx  in the line that reads  appKey = @\u201dxxxxx\";  with your app\u2019s license (retrieved earlier from Builder.)   Note  At this point the application setup is complete and the app should run successfully.", 
            "title": "Moving the app from Builder to Xcode"
        }, 
        {
            "location": "/ios/quickstart/#the-pub-and-network-connectivity", 
            "text": "The next step in the  process requires developer awareness of the default PUB status and access to a network.  By default, the application accesses the PUB dynamically. This means that when the application is first installed, the P2UX rendering library (PRL) will authenticate the application key and then download the PUB before running the application content.  The first run of an application requires network connectivity. Otherwise, P2UX will return an error. The PUB\u2019s default update policy is automatic. This means that the PRL will automatically check for updates each time the application runs. The library will also download any updates that are available, and then notify the user that the application will restart to apply any updates.", 
            "title": "The PUB and network connectivity"
        }, 
        {
            "location": "/ios/quickstart/#static-assets", 
            "text": "In some cases, a developer may opt to use only static assets rather than require network access for an app. In this situation, the PUB can be added to the application as a collection of static assets. To achieve this, follow these steps:   Note  This feature requires downloading your application PUB from Builder. This feature will be integrated as part of the P2UX Coordinator application for Mac OS    In Builder, download the published PUB for application  Steps to download PUB will go here    Unzip the PUB files and copy the assets into a folder inside your project directory.  In Xcode, add the folder to the project.  From the project navigator, select the group folder with your application name.  Right click and select  Add Files to \u2018app name\u2019   From the dialog, click the  Options  button in the bottom left corner and select  Create folder References  from the  Added folders  option  Select the folder containing the PUB assets and click the  Add  button to add them to your project.     In the example, this folder is called  phone_pub .  In order to incorporate these files into your project, as well as to adjust the resource use settings, you must change the AppDelegate file.  For projects in Objective-C, edit the  AppDelegate.m  file to look like this:     #import  AppDelegate.h  #import  SampleBehavior.h  @interface   AppDelegate   ()  @end  @implementation   AppDelegate  -   ( BOOL ) application: ( UIApplication   * ) application   didFinishLaunchingWithOptions: ( NSDictionary   * ) launchOptions   { \n\n     NSString *   appKey   =   @ xxxxx ; \n     NSDictionary   * opts ;  #if DEBUG \n     opts   =   @{ P2UXAppCreator_Opt_Env :   P2UXAppCreator_Opt_Env_Prototype } ;  #endif           NSDictionary   * resources   =   @[           @{ P2UXApp_PackageAttrib_FormFactor :   [ NSNumber   numberWithInteger : P2UXFormFactor_Phone ],              P2UXApp_PackageAttrib_Type : P2UXApp_PackageType_Static ,              P2UXApp_PackageAttrib_Package : @ phone_pub ,             P2UXApp_PackageAttrib_Update : P2UXApp_PackageUpdate_None }] ;  \n     [ P2UXAppCreator   createApplicationWithKey : appKey   opts : opts   resources : resources   delegate : self ]; \n     return   YES ;  }  @end   For projects in Swift, edit the  AppDelegate.swift  file to look like this:  import   UIKit  import   P2UXApp  @UIApplicationMain  class   AppDelegate :   UIResponder ,   UIApplicationDelegate ,   P2UXAppCreatorDelegate   { \n     var   window :   UIWindow ? \n     func   application ( _   application :   UIApplication ,   didFinishLaunchingWithOptions   launchOptions :   [ UIApplicationLaunchOptionsKey :   Any ] ? )   -   Bool   { \n         let   appKey   =   xxxxx ; \n         var   opts   :   [ AnyHashable   :   Any ];  #if DEBUG \n         opts   =   [ \n             P2UXAppCreator_Opt_Env :   P2UXAppCreator_Opt_Env_Prototype \n         ]  #endif           var   phoneResources :   [ AnyHashable   :   Any ]   =   [               P2UXApp_PackageAttrib_FormFactor :   P2UXFormFactor . phone ,               P2UXApp_PackageAttrib_Type :   P2UXApp_PackageType_Static ,               P2UXApp_PackageAttrib_Package :   phone_pub ,               P2UXApp_PackageAttrib_Update :   P2UXApp_PackageUpdate_None           ]  \n         var   resources   :   [ Any ]   =   [ \n             phoneResources \n         ] \n         P2UXAppCreator . createApplication ( withKey :   appKey ,   opts :   opts , \n         resources :   resources ,   delegate :   self ) \n         return   true \n     }  }", 
            "title": "Static Assets"
        }, 
        {
            "location": "/ios/quickstart/#defining-custom-resource-attributes", 
            "text": "If desired, the developer can define specific resource attributes for the app. These attributes define where the assets of the application are located and how those assets are updated.  The resources parameter is an array of objects. Each object in the array defines the PUB usage for a particular form factor (Phone, Tablet, TV) using key value pairs. If the application supports multiple form factors, create an object in the resources array for each form factor.  Customize the resource attributes according to the possibilities below:     Resource Attribute  Description      P2UXApp_PackageAttrib_FormFactor  Defines which form factor the attributes reference. Possible Values: P2UXFormFactor_Phone P2UXFormFactor_Tablet P2UXFormFactor_TV    P2UXApp_PackageAttrib_Type  Defines the type of resources for the form factor Possible Values: P2UXApp_PackageType_Static P2UXApp_PackageType_Remote    P2UXApp_PackageAttrib_Package  Defines the name of the folder within the application bundle containing assets when the P2UXApp_PackageAttrib_Type is P2UXApp_PackageType_Static.    P2UXApp_PackageAttrib_Update  Defines how to update the application assets Possible Values: P2UXApp_PackageUpdate_None P2UXApp_PackageUpdate_Auto P2UXApp_PackageUpdate_Manual     After defining the resources, change the resources line in the app code from \u201cnil\u201d to \u201cresources\u201d (as highlighted in the example code above).", 
            "title": "Defining Custom Resource Attributes"
        }, 
        {
            "location": "/ios/customcode/", 
            "text": "Introduction\n\n\nWhat follows is a tutorial that walks developers through the steps of writing custom code for an iOS or tvOS application using P2UX. Developers should be familiar with the Xcode integrated development environment for MacOS and either the Swift or the Objective-C programming languages for custom coding.\n\n\nTopics include customizable View Controllers, UI controls, and Screens/Panels.\n\n\n\n\nTerminology\n\n\nThroughout the P2UX documentation the \u201cdeveloper\u201d refers to you, the reader who is developing an app with P2UX. The \u201cdesigner\u201d refers to the individual whose principal job is to create the appearance and style of the app and its visual components. \u201cPRL\u201d refers to the P2UX Rendering Library for iOS, which controls the creation and workflow of content created for the P2UX platform.\n\n\n\n\n\n\nCoding examples and code additions\n\n\nIn the coding examples below and throughout the documentation, changes and additions to be made by the developer are rendered with a blue highlight.\n\n\n\n\nP2UX versus the standard Xcode environment\n\n\nP2UX based applications for iOS are easy to customize and extend. Since the P2UX iOS rendering library is based on the native UIKit and other iOS primitives, writing custom business logic and integrating custom controls works much the same as it does when writing iOS applications using Xcode.\nWith the P2UX platform, Storyboards and XIB based User Interface (UI) definitions are no longer required. Instead, applications use P2UX Portable UX Bundles (PUB) either as embedded or dynamically accessed resources. Additionally, P2UX provides hooks to developers that allow them access to all of the components of P2UX, as well as the ability to fully customize instances of the application.\n\n\n\n\nCreate a P2UX enabled project first\n\n\nThis document assumes a P2UX enabled Xcode project has already been created. See \nQuick Start\n for steps to create a project.\n\n\n\n\nP2UX and Xcode\n\n\nObjective-C or Swift\n\n\nP2UX native rendering libraries for iOS can be extended using either Objective-C or Swift. Developers are free to choose one or the other of these coding languages at any stage during the development process. The instructions below provide explicit reference to the proper use of either language in each applicable step that follows.\n\n\nAdding Custom Behaviors\n\n\nIf desired, customizable behaviors can be added to the project code.\n\n\nA subclass of the \nP2UXAppBehavior\n class is the starting point for customizing the behavior of the application. From this class, all other parts of the application can be customized. (Common customized behaviors include creation of a Custom Control or overriding a particular View Controller.)\n\n\nIn Objective-C, create a header and module file for your project to store the customized behaviors. The easiest way to do is by making a \nNew File\n in your project \u2013  a \nCocoa Touch Class\n, which in this example is called \nSampleBehavior\n.  In Xcode, create a new class from the drop down box labeled \nSubclass of:\n and enter \nP2UXAppBehavior\n in the field. \n\n\nThis will create two files: \nSampleBehavior.h\n and \nSampleBehavior.m\n.\n\n\n@\nimport\n \nP2UXApp\n;\n\n\n@interface\n \nSampleBehavior\n : \nP2UXAppBehavior\n\n\n@end\n\n\n\n\n\n\nPut any customized behaviors within the implementation here. (Behaviors available for customization are found within the P2UXApp framework, under the file \nP2UXAppBehavior\n.)\n\n\nIn addition, update \nAppDelegate.m\n to include the custom behaviors.\n\n\nTo do this, \nAppDelegate\n must include an instance of the method createBehavior from \nP2UXAppCreatorDelegate\n protocol. (This will override any default behaviors.) Also, import the \nSampleBehavior.h\n file so that this class can be instantiated.\n\n\nEdit \nAppDelegate.m\n to look like this:\n\n\n#import \nAppDelegate.h\n\n\n#import \nSampleBehavior.h\n\n\n@interface\n \nAppDelegate\n \n()\n\n\n@end\n\n\n@implementation\n \nAppDelegate\n\n\n-\n \n(\nBOOL\n)\napplication:\n(\nUIApplication\n \n*\n)\napplication\n \ndidFinishLaunchingWithOptions:\n(\nNSDictionary\n \n*\n)\nlaunchOptions\n \n{\n\n    \nNSString\n*\n \nappKey\n;\n\n    \nappKey\n \n=\n \n@\nxxxxx\n;\n\n    \nNSDictionary\n \n*\nopts\n;\n\n\n#if DEBUG\n\n    \nopts\n \n=\n \n@{\nP2UXAppCreator_Opt_Env\n:\n \nP2UXAppCreator_Opt_Env_Stage\n}\n;\n\n\n#endif    \n\n    \nNSDictionary\n \n*\nresources\n \n=\n \n@[@{\nP2UXApp_PackageAttrib_FormFactor\n:\n \n[\nNSNumber\n \nnumberWithInteger\n:\nP2UXFormFactor_Phone\n],\n \nP2UXApp_PackageAttrib_Type\n:\nP2UXApp_PackageType_Static\n,\n \nP2UXApp_PackageAttrib_Package\n:\n@\nphone_pub\n,\nP2UXApp_PackageAttrib_Update\n:\nP2UXApp_PackageUpdate_None\n}]\n;\n\n\n    \n[\nP2UXAppCreator\n \ncreateApplicationWithKey\n:\nappKey\n \nopts\n:\nopts\n \nresources\n:\nresources\n \ndelegate\n:\nself\n];\n\n    \nreturn\n \nYES\n;\n\n\n}\n\n\n\n-\n \n(\nP2UXAppBehavior\n*\n)\n \ncreateBehaviorForApplication:\n(\nNSString\n \n*\n)\nappid\n\n\n{\n\n\n    \nreturn\n \n[[\nSampleBehavior\n \nalloc\n]\n \ninit\n];\n\n\n}\n\n\n@end\n\n\n\n\n\n\nIf working in Swift, create a swift file for your project to store new behaviors.\n\n\nCreate a \nNew File\n in your project \u2013 a \nSwift File\n, in this example called \nSampleBehavior\n. In Xcode, create a new class from the drop down box labeled \nSubclass of:\n and enter \nP2UXAppBehavior\n in the field. \n\n\nEdit the \nSampleBehavior.swift\n file to look like this:\n\n\nimport\n \nUIKit\n\n\nimport\n \nP2UXApp\n\n\nclass\n \nSampleBehavior\n:\n \nP2UXAppBehavior\n \n{\n\n\n\n//\n \noverride\n \nmethods\n \nhere\n\n\n\n}\n\n\n\n\n\n\nPlace any customized behaviors within the implementation. Behaviors available for customization are found within the P2UXApp framework, under the file \nP2UXAppBehavior\n.\n\n\nNext, update \nAppDelegate.swift\n to include the custom behaviors. \n\n\nTo do this, \nAppDelegate\n must must include an instance of the method \ncreateBehavior\n from the \nP2UXAppCreatorDelegate\n protocol. (This will override any default behaviors.)\n\n\nEdit \nAppDelegate.swift\n to look like this:\n\n\nimport\n \nUIKit\n\n\nimport\n \nP2UXApp\n\n\n@UIApplicationMain\n\n\nclass\n \nAppDelegate\n:\n \nUIResponder\n,\n \nUIApplicationDelegate\n,\n \nP2UXAppCreatorDelegate\n \n{\n\n    \nvar\n \nwindow\n:\n \nUIWindow\n?\n\n    \nfunc\n \napplication\n(\n_\n \napplication\n:\n \nUIApplication\n,\n \ndidFinishLaunchingWithOptions\n \nlaunchOptions\n:\n \n[\nUIApplicationLaunchOptionsKey\n:\n \nAny\n]\n?\n)\n \n-\n \nBool\n \n{\n\n        \nlet\n \nappKey\n \n=\n \nxxxxx\n;\n\n        \nvar\n \nopts\n \n:\n \n[\nAnyHashable\n \n:\n \nAny\n];\n\n\n#if DEBUG\n\n        \nopts\n \n=\n \n[\n\n            \nP2UXAppCreator_Opt_Env\n:\n \nP2UXAppCreator_Opt_Env_Stage\n,\n\n            \nP2UXAppCreator_Opt_LogLevel\n:\n \nP2UXCoreLogLevel\n.\nverbose\n.\nrawValue\n \nas\n  \n            \nNSNumber\n\n        \n]\n\n\n#endif\n\n        \nvar\n \nphoneResources\n:\n \n[\nAnyHashable\n \n:\n \nAny\n]\n \n=\n \n[\n\n            \nP2UXApp_PackageAttrib_FormFactor\n:\n \nP2UXFormFactor\n.\nphone\n,\n\n            \nP2UXApp_PackageAttrib_Type\n:\n \nP2UXApp_PackageType_Static\n,\n\n            \nP2UXApp_PackageAttrib_Package\n:\n \nphone_pub\n,\n\n            \nP2UXApp_PackageAttrib_Update\n:\n \nP2UXApp_PackageUpdate_None\n\n        \n]\n\n\n        \nvar\n \nresources\n \n:\n \n[\nAny\n]\n \n=\n \n[\n\n            \nphoneResources\n\n        \n]\n\n        \nP2UXAppCreator\n.\ncreateApplication\n(\nwithKey\n:\n \nappKey\n,\n \nopts\n:\n \nopts\n,\n\n        \nresources\n:\n \nresources\n,\n \ndelegate\n:\n \nself\n)\n\n    \n}\n\n\n    \nfunc\n \ncreateBehavior\n(\nforApplication\n \nappid\n:\n \nString\n)\n \n-\n \nP2UXAppBehavior\n \n{\n\n\n        \nreturn\n \nSampleBehavior\n();\n\n\n    \n}\n\n\n}\n\n\n\n\n\n\nAdding Custom View Controllers\n\n\nJust like writing traditional Storyboard based iOS applications, writing custom code to interact with the User Interface is done using a subclass of \nUIViewController\n. Instead of subclassing directly from \nUIViewController\n, P2UX provides the class \nP2UXViewController\n, which itself is a subclass of \nUIViewController\n with a few added helper methods that interface with P2UX generated controls and events.\n\n\nThe \nP2UXViewController\n subclass\n\n\nSince the P2UX UI is not based on Storyboards, connecting custom methods for each button click action is unnecessary. Instead, the user can override the methods of the \nP2UXViewController\n class to handle button click and other UI events. (In all other respects, writing code for customized Screen and Panel behavior is the same as for Storyboard-based content.)\n\n\nThe name of a chosen View Controller, such as a Screen or Panel, is the value used to identify the item when the P2UX rendering library creates an instance of this object. (To create an instance of a \nP2UXViewController\n for a Screen, for example, override the \nP2UXAppBehavior\n method \ncreateViewControllerWithDef\n.) The \ndef\n parameter passed to this method contains the member variable \nsystemType\n that identifies the Screen that is being created. From this object, the developer determines the requested Screen and the specific \nP2UXViewController\n subclass to be instantiated. \n\n\nObjective-C example: creating a custom \nP2UXViewController\n\n\n#import \nSampleBehavior.h\n\n\n#import \nSampleViewController.h\n\n\n@\nimport\n \nP2UXApp\n;\n\n\n\n@implementation\n \nSampleBehavior\n\n\n\n-\n \n(\nP2UXViewController\n*\n)\n \ncreateViewControllerWithDef:\n(\nP2UXDefinition\n*\n)\ndef\n\n         \ncache:\n(\nBOOL\n)\ncache\n \nindex:\n(\nid\n)\nindex\n \ndata:\n(\nid\n)\ndata\n\n         \nviewDelegate:\n(\nid\nP2UXViewContainerDelegate\n)\nviewDelegate\n  \n{\n\n\n    \n// Determine which screen is being requested, the systemType of the P2UXDefinition class has the name of the screen as given in Builder\n\n    \nif\n \n([\ndef\n.\nsystemType\n \nisEqualToString\n:@\n\u201d\nhome\n\u201d\n])\n\n    \n{\n\n        \n// This is our custom home screen controller instance\n\n        \nreturn\n \n[[\nMyHomeController\n \nalloc\n]\n \ninitWithView\n:\ndef\n \nbehavior\n:\nself\n \ncache\n:\ncache\n \nindex\n:\nindex\n \ndata\n:\ndata\n \nviewDelegate\n:\nviewDelegate\n];\n\n    \n}\n\n    \n// Make sure to call the superclass if a instance is not created\n\n    \nreturn\n \n[\nsuper\n \ncreateViewControllerWithDef\n:\ndef\n \ncache\n:\ncache\n \nindex\n:\nindex\n \ndata\n:\ndata\n \nviewDelegate\n:\nviewDelegate\n];\n\n\n}\n\n\n@end\n\n\n\n\n\n\nSwift example: creating a custom \nP2UXViewController\n\n\noverride\n \nfunc\n \ncreateViewController\n(\nwithDef\n \ndef\n:\n \nP2UXDefinition\n!,\n \ncache\n:\n \nBool\n,\n \nindex\n:\n \nAny\n!,\n \ndata\n:\n \nAny\n!,\n \nviewDelegate\n:\n \nP2UXViewContainerDelegate\n!)\n \n-\n \nP2UXViewController\n!\n \n{\n\n\n    \n// Determine which screen is being requested, the systemType of the P2UXDefinition class has the name of the screen as given in Builder\n\n    \nif\n \ndef\n.\nsystemType\n \n==\n \nhome\n \n{\n\n        \n// This is our custom home screen controller instance\n\n        \nreturn\n \nMyHomeController\n(\nview\n:\n \ndef\n,\n \nbehavior\n:\n \nself\n,\n \ncache\n:\n \ncache\n,\n \nindex\n:\n \nindex\n,\n \ndata\n:\n \ndata\n,\n \nviewDelegate\n:\n \nviewDelegate\n)\n\n    \n}\n        \n    \n// Make sure to call the superclass if a instance is not created\n\n    \nreturn\n \nsuper\n.\ncreateViewController\n(\nwithDef\n:\n \ndef\n,\n \ncache\n:\n \ncache\n,\n \nindex\n:\n \nindex\n,\n \ndata\n:\n \ndata\n,\n \nviewDelegate\n:\n \nviewDelegate\n);\n\n\n}\n\n\n\n\n\n\nThe \nP2UXViewController\n view instance managed by your controller is created automatically based on the \nP2UXDefinition\n.\n\n\nJust as Screens can have custom \nUIViewController\n instances to override their behavior, so too can Panels. The \nUIViewController\n based subclass \nP2UXPanelController\n manages Panel instances. To create a custom \nP2UXPanelController\n instance, override the \nP2UXAppBehavior\n method \ncreatePanelControllerWithDef\n and return an instance of a \nP2UXPanelController\n subclass.\n\n\nObjective-C example: creating a custom P2UXPanelController\n\n\n-\n \n(\nP2UXViewController\n*\n)\n \ncreatePanelControllerWithDef:\n(\nP2UXDefinition\n*\n)\ndef\n\n      \ncache:\n(\nBOOL\n)\ncache\n \nindex:\n(\nid\n)\nindex\n \ndata:\n(\nid\n)\ndata\n\n      \nviewDelegate:\n(\nid\nP2UXViewContainerDelegate\n)\nviewDelegate\n \n{\n\n\n   \n// Determine which screen is being requested, the systemType of the P2UXDefinition class has the name of the screen as given in Builder\n\n   \nif\n \n([\ndef\n.\nsystemType\n \nisEqualToString\n:@\n\u201d\nuserprofile\n\u201d\n])\n \n{\n\n      \n// This is our custom panel controller instance\n\n      \nreturn\n \n[[\nUserProfilePanelController\n \nalloc\n]\n \ninitWithView\n:\ndef\n \nbehavior\n:\nself\n \ncache\n:\ncache\n \nindex\n:\nindex\n \ndata\n:\ndata\n \nviewDelegate\n:\nviewDelegate\n];\n\n   \n}\n\n   \n// Make sure to call the superclass if a instance is not created\n\n   \nreturn\n \n[\nsuper\n \ncreatePanelControllerWithDef\n:\ndef\n \ncache\n:\ncache\n \n      \nindex\n:\nindex\n \ndata\n:\ndata\n \nviewDelegate\n:\nviewDelegate\n];\n\n\n}\n\n\n\n\n\n\nSwift example: creating a custom P2UXPanelController\n\n\noverride\n \nfunc\n \ncreatePanelController\n(\nwithDef\n \ndef\n:\n \nP2UXDefinition\n!,\n \n      \ncache\n:\n \nBool\n,\n \nindex\n:\n \nAny\n!,\n \ndata\n:\n \nAny\n!,\n \n      \nviewDelegate\n:\n \nP2UXViewContainerDelegate\n!)\n \n-\n \nP2UXViewController\n!\n \n{\n\n\n   \n// Determine which screen is being requested, the systemType of the\n\n   \n// P2UXDefinition class has the name of the screen as given in Builder\n\n   \nif\n \ndef\n.\nsystemType\n \n==\n \nuserprofile\n \n{\n\n       \n// This is our custom panel controller instance\n\n       \nreturn\n \nUserProfilePanelController\n(\nview\n:\n \ndef\n,\n \nbehavior\n:\n \nself\n,\n \ncache\n:\n \ncache\n,\n \nindex\n:\n \nindex\n,\n \ndata\n:\n \ndata\n,\n \nviewDelegate\n:\n \nviewDelegate\n)\n\n   \n}\n\n\n   \nreturn\n \nsuper\n.\ncreatePanelController\n(\nwithDef\n:\n \ndef\n,\n \ncache\n:\n \ncache\n,\n \nindex\n:\n \nindex\n,\n \ndata\n:\n \ndata\n,\n \nviewDelegate\n:\n \nviewDelegate\n);\n\n\n}\n\n\n\n\n\n\nAccessing Control Instances from \nP2UXViewController\n\n\nTo access instances of controls, \nP2UXViewController\n provides a helper method, \ncontrolWithElementSystemTypeOrId\n. This method takes the name or ID of the desired control and returns access to the control instance.\n\n\nUpon creating a new control, such as a new Button, Builder assigns it a \u201csystem type.\u201d (Builder generates the system type from the designer\u2019s name for the Button.) Later, the designer might decide to create an alternative variation of the Button. To prevent altering any existing controls, the developer should refer to the new version of the Button by its system type to eliminate overwriting or rewriting any code.\n\n\nObjective-C example: accessing a control in a \nP2UXViewController\n\n\n-(\nvoid\n)\n \nviewDidLoad\n \n{\n\n   \n[\nsuper\n \nviewDidLoad\n];\n\n\n   \nUIButton\n*\n \nbtn\n \n=\n \n(\nUIButton\n*\n)[\nself\n \ncontrolWithElementSystemTypeOrId\n:@\n\u201d\nshow\n \nbtn\n\u201d\n];\n\n   \nif\n \n(\nbtn\n \n!=\n \nnil\n)\n \n{\n\n      \nbtn\n.\nenabled\n \n=\n \nNO\n;\n\n   \n}\n\n\n}\n\n\n\n\n\n\nSwift example: accessing a control in a \nP2UXViewController\n\n\noverride\n \nfunc\n \nviewDidLoad\n()\n \n{\n\n   \nsuper\n.\nviewDidLoad\n()\n\n\n   \nif\n \nlet\n \nbtn\n \n=\n \nself\n.\ncontrol\n(\nwithElementSystemTypeOrId\n:\n \nshow btn\n)\n \nas\n?\n \nUIButton\n \n{\n\n      \nbtn\n.\nisEnabled\n \n=\n \nfalse\n;\n\n   \n}\n\n\n}\n\n\n\n\n\n\nHandling Events from P2UXViewController\n\n\nEnd-users of a completed app will interact with controls in a Screen or Panel to generate events. These interactions will, in turn, trigger actions. Typically the PRL handles events directly through event interactions set up in Builder. In some cases, additional custom code may be needed to trigger actions not directly supported by P2UX.\n\n\nThe PRL provides a chain of event handlers that propagate an event through different components. Handling events at any point in the propagation chain provides a way to trigger custom code and also (optionally) to stop the propagation of the event at any specific handler.\n\n\nEvent propagation follows a set pattern.\n\n\nFirst, events are relayed to the \nP2UXViewController\n for the current Screen or Panel. Next, they pass to \nP2UXAppBehavior\n. Finally, events are handled by the custom instance of the \nUIView\n itself. If none of these components halt event propagation, the PRL will then handle any interactions defined for the event in Builder.\n\n\nThe \nP2UXViewController\n contains helper methods that handle a variety of events when they occur. These methods give the developer a chance to integrate any custom code needed from the basic event level without triggering any custom actions.\n\n\nMost standard control events are routed through the \nP2UXViewController\n instance. Handling these events is a matter of overriding the appropriate event method in your \nP2UXViewController\n subclass. Event propagation can be allowed to continue or not depending on the return value from the event handler methods.\n\n\nObjective-C example: handling a Button press event in \nP2UXViewController\n subclass\n\n\n-\n \n(\nBOOL\n)\n \nhandleButtonClick:\n(\nid\n)\nsender\n \nelement:\n(\nP2UXElementInstance\n \n*\n)\nelement\n \n{\n\n    \nif\n \n([\nelement\n.\nsystemType\n \nisEqualToString\n:\n@\nokbtn\n])\n \n{\n\n        \n// take some custom action here for the \nokbtn\n\n\n        \n// return YES to indicate the event was handled and propagation \n\n        \n// shouldn\nt continue\n\n        \nreturn\n \nYES\n;\n\n    \n}\n\n    \nreturn\n \nNO\n;\n\n\n}\n\n\n\n\n\n\nSwift example: handling a Button press event in \nP2UXViewController\n subclass\n\n\noverride\n \nfunc\n \nhandleButtonClick\n(\n_\n \nsender\n:\n \nAny\n!,\n \nelement\n:\n \nP2UXElementInstance\n!)\n \n-\n \nBool\n \n{\n\n    \nif\n \nelement\n.\nsystemType\n \n==\n \nokbtn\n \n{\n\n        \n// take some custom action here for the \nokbtn\n\n\n        \n// return true to indicate the event was handled and propagation \n\n        \n// shouldn\nt continue\n\n        \nreturn\n \ntrue\n;\n\n    \n}\n\n    \nreturn\n \nfalse\n;\n\n\n}\n\n\n\n\n\n\nAdding Custom UI Controls\n\n\nUI Controls are the visual components of a Screen or Panel created in the Builder tool. These can be interactive, like Buttons or Sliders, or non-interactive, like Shapes or Text. Although P2UX offers many different UI Controls directly creatable and usable in Builder, a specific application may require developer-defined UI controls. Builder provides a Custom Control component that can be added to a Screen or Panel and then replaced using custom code.\n\n\nAny \nUIView\n based control can be injected into your Screens and Panels via a Custom Control. This allows for existing custom controls or third party custom controls to be used with your P2UX based applications.\n\n\nThe PRL manages the size and position of any custom controls defined using Builder. To provide an instance of a custom control, override the method \ncreateControlWithType\n in your \nP2UXAppBehavior\n subclass and return the \nUIView\n subclassed instance of your control. The first parameter passed to this method, type, is the name of the control set when you created the custom control in Builder. P2UX will pass you the initial size to use with your Custom Control as well as a few other components that can be used to access any custom information created with your control in Builder.\n\n\nThe \nelementInstance\n parameter contains all the parameters specified using Builder for the control via its \nitemSpec\n member. Even though the parent \nUIView\n is passed to the create method, you should not add the instance of your \nUIView\n control to the parent as this is managed by P2UX when you return the instance of the control.\n\n\nObjective-C example: creating a custom control in \nP2UXAppBehavior\n subclass:\n\n\n-\n \n(\nUIView\n*\n)\n \ncreateControlWithType:\n(\nNSString\n \n*\n)\ntype\n \nelementInstance:\n(\nP2UXElementInstance\n \n*\n)\nelementInstance\n \nframe:\n(\nCGRect\n)\nframe\n \nviewDelegate:\n(\nid\nP2UXViewContainerDelegate\n)\nviewDelegate\n \nindex:\n(\nid\n)\nindex\n \ndata:\n(\nid\n)\ndata\n \nparent:\n(\nUIView\n \n*\n)\nparent\n \n{\n\n\n    \nif\n \n([\ntype\n \nisEqualToString\n:\n@\ngraphcontrol\n])\n \n{\n\n\n        \nCustomGraph\n*\n \ngraph\n \n=\n \n[[\nCustomGraph\n \nalloc\n]\n \ninitWithFrame\n:\nframe\n];\n\n        \nNSDictionary\n*\n \ngraphOpts\n \n=\n \n[\nelementInstance\n.\nitemSpec\n \nobjectForKey\n:\n@\ngraphopts\n];\n\n        \nif\n \n(\ngraphOpts\n \n!=\n \nnil\n)\n \n{\n\n            \n// handle extra parameters here, for this example we defined an object\n\n            \n// in the itemspec of the control\n\n            \n// in Builder named \ngraphopts\n which has information specific to \n\n            \n// our graph object\n\n            \ngraph\n.\nopts\n \n=\n \ngraphOpts\n;\n\n        \n}\n\n        \nreturn\n \ngraph\n;\n\n    \n}\n\n    \nreturn\n \n[\nsuper\n \ncreateControlWithType\n:\ntype\n \nelementInstance\n:\nelementInstance\n \nframe\n:\nframe\n \nviewDelegate\n:\nviewDelegate\n \nindex\n:\nindex\n \ndata\n:\ndata\n \nparent\n:\nparent\n];\n\n\n}\n\n\n\n\n\n\nSwift example: creating a custom control in \nP2UXAppBehavior\n subclass:\n\n\noverride\n \nfunc\n \ncreateControl\n(\nwithType\n \ntype\n:\n \nString\n!,\n \nelementInstance\n:\n \nP2UXElementInstance\n!,\n \nframe\n:\n \nCGRect\n,\n \nviewDelegate\n:\n \nP2UXViewContainerDelegate\n!,\n \nindex\n:\n \nAny\n!,\n \ndata\n:\n \nAny\n!,\n \nparent\n:\n \nUIView\n!)\n \n-\n \nUIView\n!\n \n{\n\n\n    \nif\n \ntype\n \n==\n \ngraphcontrol\n \n{\n\n        \nlet\n \ngraph\n \n:\n \nCustomGraph\n \n=\n \nCustomGraph\n(\nframe\n:\n \nframe\n);\n\n        \nif\n \nlet\n \ngraphOpts\n \n=\n \nelementInstance\n.\nitemSpec\n[\ngraphopts\n]\n \nas\n?\n \nNSDictionary\n \n{\n\n            \n// handle extra parameters here, for this example we defined an object \n\n            \n// in the itemspec of the control\n\n            \n// in Builder named \ngraphopts\n which has information specific to \n\n            \n// our graph object\n\n            \ngraph\n.\nopts\n \n=\n \ngraphOpts\n;\n\n        \n}\n\n        \nreturn\n \ngraph\n;\n\n    \n}\n\n    \nreturn\n \nsuper\n.\ncreateControl\n(\nwithType\n:\n \ntype\n,\n \nelementInstance\n:\n \nelementInstance\n,\n \nframe\n:\n \nframe\n,\n \nviewDelegate\n:\n \nviewDelegate\n,\n \nindex\n:\n \nindex\n,\n \ndata\n:\n \ndata\n,\n \nparent\n:\n \nparent\n);\n\n\n}\n\n\n\n\n\n\nAdding Custom Screens/Panels\n\n\nIn addition to using a \nUIViewController\n based class to override behavior for an application Screen or Panel, the actual Screen or Panel instance can also be overridden to provide any custom code needed for the hosted \nUIView\n itself.\n\n\nP2UX will request an instance from \nP2UXAppBehavior\n when the Screen or Panel is created. If no instance is provided, P2UX will generate a standard instance of the Screen or Panel.\n\n\nTo provide a custom Screen instance, override the method \ncreateScreenWithDef\n from a \nP2UXAppBehavior\n subclass and return an instance of \nP2UXScreen\n. To provide a custom Panel instance, override the method \ncreatePanelWithDef\n and return an instance of \nP2UXPanel\n. (Both \nP2UXScreen\n and \nP2UXPanel\n are \nUIView\n based subclasses that add some additional helper methods. These methods make it easier to access screen components.)\n\n\nObjective-C example: creating a custom Screen or Panel instance in P2UXAppBehavior subclass\n\n\n// For custom Screen instances\n\n\n-(\nP2UXScreen\n*\n)\n \ncreateScreenWithDef:\n(\nP2UXDefinition\n \n*\n)\ndef\n \nrect:\n(\nCGRect\n)\nrect\n \nindex:\n(\nid\n)\nindex\n \ndata:\n(\nid\n)\ndata\n \nviewDelegate:\n(\nid\nP2UXViewContainerDelegate\n)\nviewDelegate\n \n{\n\n\n    \n// If the screen \u201csystemType\u201d matches the name of the screen, return\n\n    \n// the custom screen instance\n\n    \nif\n \n([\ndef\n.\nsystemType\n \nisEqualToString\n:\n@\nhome\n])\n \n{\n\n        \n// Here we return an instance of HomeScreen which is a \n\n        \n// subclass of P2UXScreen\n\n        \nreturn\n \n[[\nHomeScreen\n \nalloc\n]\n \ninitWithFrame\n:\nrect\n \ncontents\n:\ndef\n \nviewDelegate\n:\nviewDelegate\n \nindex\n:\nindex\n \ndata\n:\ndata\n];\n\n    \n}\n\n    \nreturn\n \n[\nsuper\n \ncreateScreenWithDef\n:\ndef\n \nrect\n:\nrect\n \nindex\n:\nindex\n \ndata\n:\ndata\n \nviewDelegate\n:\nviewDelegate\n];\n\n\n}\n\n\n\n// For custom panel instances\n\n\n-\n \n(\nP2UXPanel\n*\n)\n \ncreatePanelWithDef:\n(\nP2UXDefinition\n \n*\n)\ndef\n \nrect:\n(\nCGRect\n)\nrect\n \nindex:\n(\nid\n)\nindex\n \ndata:\n(\nid\n)\ndata\n \nviewDelegate:\n(\nid\nP2UXViewContainerDelegate\n)\nviewDelegate\n \n{\n\n\n    \n// if this is the userinfo panel, return the custom UserInfoPanel instance\n\n    \nif\n \n([\ndef\n.\nsystemType\n \nisEqualToString\n:\n@\nuserinfo\n])\n \n{\n\n        \nreturn\n \n[[\nUserInfoPanel\n \nalloc\n]\n \ninitWithFrame\n:\nrect\n \ncontents\n:\ndef\n \nviewDelegate\n:\nviewDelegate\n \nindex\n:\nindex\n \ndata\n:\ndata\n];\n\n    \n}\n\n    \nreturn\n \n[\nsuper\n \ncreatePanelWithDef\n:\ndef\n \nrect\n:\nrect\n \nindex\n:\nindex\n \ndata\n:\ndata\n \nviewDelegate\n:\nviewDelegate\n];\n\n\n}\n\n\n\n\n\n\nSwift example: creating a custom Screen or Panel instance in \nP2UXAppBehavior\n subclass\n\n\n// For custom Screen instances\n\n\noverride\n \nfunc\n \ncreateScreen\n(\nwithDef\n \ndef\n:\n \nP2UXDefinition\n!,\n \nrect\n:\n \nCGRect\n,\n \nindex\n:\n \nAny\n!,\n \ndata\n:\n \nAny\n!,\n \nviewDelegate\n:\n \nP2UXViewContainerDelegate\n!)\n \n-\n \nP2UXScreen\n!\n \n{\n\n\n    \n// If the screen \u201csystemType\u201d matches the name of the screen, return\n\n    \n// the custom screen instance.\n\n    \nif\n \ndef\n.\nsystemType\n \n==\n \nhome\n \n{\n   \n       \n// Here we return an instance of HomeScreen which is a \n\n       \n// subclass of P2UXScreen\n\n       \nreturn\n \nHomeScreen\n(\nframe\n:\n \nrect\n,\n \ncontents\n:\n \ndef\n,\n \nviewDelegate\n:\n \nviewDelegate\n,\n \nindex\n:\n \nindex\n,\n \ndata\n:\n \ndata\n);\n\n    \n}\n\n    \nreturn\n \nsuper\n.\ncreateScreen\n(\nwithDef\n:\n \ndef\n,\n \nrect\n:\n \nrect\n,\n \nindex\n:\n \nindex\n,\n \ndata\n:\n \ndata\n,\n \nviewDelegate\n:\n \nviewDelegate\n);\n\n\n}\n\n\n\n// For custom panel instances\n\n\noverride\n \nfunc\n \ncreatePanel\n(\nwithDef\n \ndef\n:\n \nP2UXDefinition\n!,\n \nrect\n:\n \nCGRect\n,\n \nindex\n:\n \nAny\n!,\n \ndata\n:\n \nAny\n!,\n \nviewDelegate\n:\n \nP2UXViewContainerDelegate\n!)\n \n-\n \nP2UXPanel\n!\n \n{\n\n\n    \n// If the panel \u201csystemType\u201d matches the name of the screen, return\n\n    \n// the custom panel instance.\n\n    \nif\n \ndef\n.\nsystemType\n \n==\n \nuserinfo\n \n{\n\n           \n// Here we return an instance of HomeScreen which is a \n\n           \n// subclass of P2UXScreen\n\n           \nreturn\n \nUserInfoPanel\n(\nframe\n:\n \nrect\n,\n \ncontents\n:\n \ndef\n,\n \nviewDelegate\n:\n \nviewDelegate\n,\n \nindex\n:\n \nindex\n,\n \ndata\n:\n \ndata\n);\n\n    \n}\n\n    \nreturn\n \nsuper\n.\ncreatePanel\n(\nwithDef\n:\n \ndef\n,\n \nrect\n:\n \nrect\n,\n \nindex\n:\n \nindex\n,\n \ndata\n:\n \ndata\n,\n \nviewDelegate\n:\n \nviewDelegate\n);\n\n\n}", 
            "title": "Custom Code"
        }, 
        {
            "location": "/ios/customcode/#introduction", 
            "text": "What follows is a tutorial that walks developers through the steps of writing custom code for an iOS or tvOS application using P2UX. Developers should be familiar with the Xcode integrated development environment for MacOS and either the Swift or the Objective-C programming languages for custom coding.  Topics include customizable View Controllers, UI controls, and Screens/Panels.   Terminology  Throughout the P2UX documentation the \u201cdeveloper\u201d refers to you, the reader who is developing an app with P2UX. The \u201cdesigner\u201d refers to the individual whose principal job is to create the appearance and style of the app and its visual components. \u201cPRL\u201d refers to the P2UX Rendering Library for iOS, which controls the creation and workflow of content created for the P2UX platform.    Coding examples and code additions  In the coding examples below and throughout the documentation, changes and additions to be made by the developer are rendered with a blue highlight.   P2UX versus the standard Xcode environment  P2UX based applications for iOS are easy to customize and extend. Since the P2UX iOS rendering library is based on the native UIKit and other iOS primitives, writing custom business logic and integrating custom controls works much the same as it does when writing iOS applications using Xcode.\nWith the P2UX platform, Storyboards and XIB based User Interface (UI) definitions are no longer required. Instead, applications use P2UX Portable UX Bundles (PUB) either as embedded or dynamically accessed resources. Additionally, P2UX provides hooks to developers that allow them access to all of the components of P2UX, as well as the ability to fully customize instances of the application.   Create a P2UX enabled project first  This document assumes a P2UX enabled Xcode project has already been created. See  Quick Start  for steps to create a project.", 
            "title": "Introduction"
        }, 
        {
            "location": "/ios/customcode/#p2ux-and-xcode", 
            "text": "Objective-C or Swift  P2UX native rendering libraries for iOS can be extended using either Objective-C or Swift. Developers are free to choose one or the other of these coding languages at any stage during the development process. The instructions below provide explicit reference to the proper use of either language in each applicable step that follows.", 
            "title": "P2UX and Xcode"
        }, 
        {
            "location": "/ios/customcode/#adding-custom-behaviors", 
            "text": "If desired, customizable behaviors can be added to the project code.  A subclass of the  P2UXAppBehavior  class is the starting point for customizing the behavior of the application. From this class, all other parts of the application can be customized. (Common customized behaviors include creation of a Custom Control or overriding a particular View Controller.)  In Objective-C, create a header and module file for your project to store the customized behaviors. The easiest way to do is by making a  New File  in your project \u2013  a  Cocoa Touch Class , which in this example is called  SampleBehavior .  In Xcode, create a new class from the drop down box labeled  Subclass of:  and enter  P2UXAppBehavior  in the field.  \nThis will create two files:  SampleBehavior.h  and  SampleBehavior.m .  @ import   P2UXApp ;  @interface   SampleBehavior  :  P2UXAppBehavior  @end   Put any customized behaviors within the implementation here. (Behaviors available for customization are found within the P2UXApp framework, under the file  P2UXAppBehavior .)  In addition, update  AppDelegate.m  to include the custom behaviors.  To do this,  AppDelegate  must include an instance of the method createBehavior from  P2UXAppCreatorDelegate  protocol. (This will override any default behaviors.) Also, import the  SampleBehavior.h  file so that this class can be instantiated.  Edit  AppDelegate.m  to look like this:  #import  AppDelegate.h  #import  SampleBehavior.h  @interface   AppDelegate   ()  @end  @implementation   AppDelegate  -   ( BOOL ) application: ( UIApplication   * ) application   didFinishLaunchingWithOptions: ( NSDictionary   * ) launchOptions   { \n     NSString *   appKey ; \n     appKey   =   @ xxxxx ; \n     NSDictionary   * opts ;  #if DEBUG \n     opts   =   @{ P2UXAppCreator_Opt_Env :   P2UXAppCreator_Opt_Env_Stage } ;  #endif     \n     NSDictionary   * resources   =   @[@{ P2UXApp_PackageAttrib_FormFactor :   [ NSNumber   numberWithInteger : P2UXFormFactor_Phone ],   P2UXApp_PackageAttrib_Type : P2UXApp_PackageType_Static ,   P2UXApp_PackageAttrib_Package : @ phone_pub , P2UXApp_PackageAttrib_Update : P2UXApp_PackageUpdate_None }] ; \n\n     [ P2UXAppCreator   createApplicationWithKey : appKey   opts : opts   resources : resources   delegate : self ]; \n     return   YES ;  }  -   ( P2UXAppBehavior * )   createBehaviorForApplication: ( NSString   * ) appid  {       return   [[ SampleBehavior   alloc ]   init ];  }  @end   If working in Swift, create a swift file for your project to store new behaviors.  Create a  New File  in your project \u2013 a  Swift File , in this example called  SampleBehavior . In Xcode, create a new class from the drop down box labeled  Subclass of:  and enter  P2UXAppBehavior  in the field.   Edit the  SampleBehavior.swift  file to look like this:  import   UIKit  import   P2UXApp  class   SampleBehavior :   P2UXAppBehavior   {  //   override   methods   here  }   Place any customized behaviors within the implementation. Behaviors available for customization are found within the P2UXApp framework, under the file  P2UXAppBehavior .  Next, update  AppDelegate.swift  to include the custom behaviors.   To do this,  AppDelegate  must must include an instance of the method  createBehavior  from the  P2UXAppCreatorDelegate  protocol. (This will override any default behaviors.)  Edit  AppDelegate.swift  to look like this:  import   UIKit  import   P2UXApp  @UIApplicationMain  class   AppDelegate :   UIResponder ,   UIApplicationDelegate ,   P2UXAppCreatorDelegate   { \n     var   window :   UIWindow ? \n     func   application ( _   application :   UIApplication ,   didFinishLaunchingWithOptions   launchOptions :   [ UIApplicationLaunchOptionsKey :   Any ] ? )   -   Bool   { \n         let   appKey   =   xxxxx ; \n         var   opts   :   [ AnyHashable   :   Any ];  #if DEBUG \n         opts   =   [ \n             P2UXAppCreator_Opt_Env :   P2UXAppCreator_Opt_Env_Stage , \n             P2UXAppCreator_Opt_LogLevel :   P2UXCoreLogLevel . verbose . rawValue   as   \n             NSNumber \n         ]  #endif \n         var   phoneResources :   [ AnyHashable   :   Any ]   =   [ \n             P2UXApp_PackageAttrib_FormFactor :   P2UXFormFactor . phone , \n             P2UXApp_PackageAttrib_Type :   P2UXApp_PackageType_Static , \n             P2UXApp_PackageAttrib_Package :   phone_pub , \n             P2UXApp_PackageAttrib_Update :   P2UXApp_PackageUpdate_None \n         ] \n\n         var   resources   :   [ Any ]   =   [ \n             phoneResources \n         ] \n         P2UXAppCreator . createApplication ( withKey :   appKey ,   opts :   opts , \n         resources :   resources ,   delegate :   self ) \n     }       func   createBehavior ( forApplication   appid :   String )   -   P2UXAppBehavior   {           return   SampleBehavior ();       }  }", 
            "title": "Adding Custom Behaviors"
        }, 
        {
            "location": "/ios/customcode/#adding-custom-view-controllers", 
            "text": "Just like writing traditional Storyboard based iOS applications, writing custom code to interact with the User Interface is done using a subclass of  UIViewController . Instead of subclassing directly from  UIViewController , P2UX provides the class  P2UXViewController , which itself is a subclass of  UIViewController  with a few added helper methods that interface with P2UX generated controls and events.  The  P2UXViewController  subclass  Since the P2UX UI is not based on Storyboards, connecting custom methods for each button click action is unnecessary. Instead, the user can override the methods of the  P2UXViewController  class to handle button click and other UI events. (In all other respects, writing code for customized Screen and Panel behavior is the same as for Storyboard-based content.)  The name of a chosen View Controller, such as a Screen or Panel, is the value used to identify the item when the P2UX rendering library creates an instance of this object. (To create an instance of a  P2UXViewController  for a Screen, for example, override the  P2UXAppBehavior  method  createViewControllerWithDef .) The  def  parameter passed to this method contains the member variable  systemType  that identifies the Screen that is being created. From this object, the developer determines the requested Screen and the specific  P2UXViewController  subclass to be instantiated.   Objective-C example: creating a custom  P2UXViewController  #import  SampleBehavior.h  #import  SampleViewController.h  @ import   P2UXApp ;  @implementation   SampleBehavior  -   ( P2UXViewController * )   createViewControllerWithDef: ( P2UXDefinition * ) def \n          cache: ( BOOL ) cache   index: ( id ) index   data: ( id ) data \n          viewDelegate: ( id P2UXViewContainerDelegate ) viewDelegate    { \n\n     // Determine which screen is being requested, the systemType of the P2UXDefinition class has the name of the screen as given in Builder \n     if   ([ def . systemType   isEqualToString :@ \u201d home \u201d ]) \n     { \n         // This is our custom home screen controller instance \n         return   [[ MyHomeController   alloc ]   initWithView : def   behavior : self   cache : cache   index : index   data : data   viewDelegate : viewDelegate ]; \n     } \n     // Make sure to call the superclass if a instance is not created \n     return   [ super   createViewControllerWithDef : def   cache : cache   index : index   data : data   viewDelegate : viewDelegate ];  }  @end   Swift example: creating a custom  P2UXViewController  override   func   createViewController ( withDef   def :   P2UXDefinition !,   cache :   Bool ,   index :   Any !,   data :   Any !,   viewDelegate :   P2UXViewContainerDelegate !)   -   P2UXViewController !   { \n\n     // Determine which screen is being requested, the systemType of the P2UXDefinition class has the name of the screen as given in Builder \n     if   def . systemType   ==   home   { \n         // This is our custom home screen controller instance \n         return   MyHomeController ( view :   def ,   behavior :   self ,   cache :   cache ,   index :   index ,   data :   data ,   viewDelegate :   viewDelegate ) \n     }         \n     // Make sure to call the superclass if a instance is not created \n     return   super . createViewController ( withDef :   def ,   cache :   cache ,   index :   index ,   data :   data ,   viewDelegate :   viewDelegate );  }   The  P2UXViewController  view instance managed by your controller is created automatically based on the  P2UXDefinition .  Just as Screens can have custom  UIViewController  instances to override their behavior, so too can Panels. The  UIViewController  based subclass  P2UXPanelController  manages Panel instances. To create a custom  P2UXPanelController  instance, override the  P2UXAppBehavior  method  createPanelControllerWithDef  and return an instance of a  P2UXPanelController  subclass.  Objective-C example: creating a custom P2UXPanelController  -   ( P2UXViewController * )   createPanelControllerWithDef: ( P2UXDefinition * ) def \n       cache: ( BOOL ) cache   index: ( id ) index   data: ( id ) data \n       viewDelegate: ( id P2UXViewContainerDelegate ) viewDelegate   { \n\n    // Determine which screen is being requested, the systemType of the P2UXDefinition class has the name of the screen as given in Builder \n    if   ([ def . systemType   isEqualToString :@ \u201d userprofile \u201d ])   { \n       // This is our custom panel controller instance \n       return   [[ UserProfilePanelController   alloc ]   initWithView : def   behavior : self   cache : cache   index : index   data : data   viewDelegate : viewDelegate ]; \n    } \n    // Make sure to call the superclass if a instance is not created \n    return   [ super   createPanelControllerWithDef : def   cache : cache  \n       index : index   data : data   viewDelegate : viewDelegate ];  }   Swift example: creating a custom P2UXPanelController  override   func   createPanelController ( withDef   def :   P2UXDefinition !,  \n       cache :   Bool ,   index :   Any !,   data :   Any !,  \n       viewDelegate :   P2UXViewContainerDelegate !)   -   P2UXViewController !   { \n\n    // Determine which screen is being requested, the systemType of the \n    // P2UXDefinition class has the name of the screen as given in Builder \n    if   def . systemType   ==   userprofile   { \n        // This is our custom panel controller instance \n        return   UserProfilePanelController ( view :   def ,   behavior :   self ,   cache :   cache ,   index :   index ,   data :   data ,   viewDelegate :   viewDelegate ) \n    } \n\n    return   super . createPanelController ( withDef :   def ,   cache :   cache ,   index :   index ,   data :   data ,   viewDelegate :   viewDelegate );  }", 
            "title": "Adding Custom View Controllers"
        }, 
        {
            "location": "/ios/customcode/#accessing-control-instances-from-p2uxviewcontroller", 
            "text": "To access instances of controls,  P2UXViewController  provides a helper method,  controlWithElementSystemTypeOrId . This method takes the name or ID of the desired control and returns access to the control instance.  Upon creating a new control, such as a new Button, Builder assigns it a \u201csystem type.\u201d (Builder generates the system type from the designer\u2019s name for the Button.) Later, the designer might decide to create an alternative variation of the Button. To prevent altering any existing controls, the developer should refer to the new version of the Button by its system type to eliminate overwriting or rewriting any code.  Objective-C example: accessing a control in a  P2UXViewController  -( void )   viewDidLoad   { \n    [ super   viewDidLoad ]; \n\n    UIButton *   btn   =   ( UIButton * )[ self   controlWithElementSystemTypeOrId :@ \u201d show   btn \u201d ]; \n    if   ( btn   !=   nil )   { \n       btn . enabled   =   NO ; \n    }  }   Swift example: accessing a control in a  P2UXViewController  override   func   viewDidLoad ()   { \n    super . viewDidLoad () \n\n    if   let   btn   =   self . control ( withElementSystemTypeOrId :   show btn )   as ?   UIButton   { \n       btn . isEnabled   =   false ; \n    }  }", 
            "title": "Accessing Control Instances from P2UXViewController"
        }, 
        {
            "location": "/ios/customcode/#handling-events-from-p2uxviewcontroller", 
            "text": "End-users of a completed app will interact with controls in a Screen or Panel to generate events. These interactions will, in turn, trigger actions. Typically the PRL handles events directly through event interactions set up in Builder. In some cases, additional custom code may be needed to trigger actions not directly supported by P2UX.  The PRL provides a chain of event handlers that propagate an event through different components. Handling events at any point in the propagation chain provides a way to trigger custom code and also (optionally) to stop the propagation of the event at any specific handler.  Event propagation follows a set pattern.  First, events are relayed to the  P2UXViewController  for the current Screen or Panel. Next, they pass to  P2UXAppBehavior . Finally, events are handled by the custom instance of the  UIView  itself. If none of these components halt event propagation, the PRL will then handle any interactions defined for the event in Builder.  The  P2UXViewController  contains helper methods that handle a variety of events when they occur. These methods give the developer a chance to integrate any custom code needed from the basic event level without triggering any custom actions.  Most standard control events are routed through the  P2UXViewController  instance. Handling these events is a matter of overriding the appropriate event method in your  P2UXViewController  subclass. Event propagation can be allowed to continue or not depending on the return value from the event handler methods.  Objective-C example: handling a Button press event in  P2UXViewController  subclass  -   ( BOOL )   handleButtonClick: ( id ) sender   element: ( P2UXElementInstance   * ) element   { \n     if   ([ element . systemType   isEqualToString : @ okbtn ])   { \n         // take some custom action here for the  okbtn \n\n         // return YES to indicate the event was handled and propagation  \n         // shouldn t continue \n         return   YES ; \n     } \n     return   NO ;  }   Swift example: handling a Button press event in  P2UXViewController  subclass  override   func   handleButtonClick ( _   sender :   Any !,   element :   P2UXElementInstance !)   -   Bool   { \n     if   element . systemType   ==   okbtn   { \n         // take some custom action here for the  okbtn \n\n         // return true to indicate the event was handled and propagation  \n         // shouldn t continue \n         return   true ; \n     } \n     return   false ;  }", 
            "title": "Handling Events from P2UXViewController"
        }, 
        {
            "location": "/ios/customcode/#adding-custom-ui-controls", 
            "text": "UI Controls are the visual components of a Screen or Panel created in the Builder tool. These can be interactive, like Buttons or Sliders, or non-interactive, like Shapes or Text. Although P2UX offers many different UI Controls directly creatable and usable in Builder, a specific application may require developer-defined UI controls. Builder provides a Custom Control component that can be added to a Screen or Panel and then replaced using custom code.  Any  UIView  based control can be injected into your Screens and Panels via a Custom Control. This allows for existing custom controls or third party custom controls to be used with your P2UX based applications.  The PRL manages the size and position of any custom controls defined using Builder. To provide an instance of a custom control, override the method  createControlWithType  in your  P2UXAppBehavior  subclass and return the  UIView  subclassed instance of your control. The first parameter passed to this method, type, is the name of the control set when you created the custom control in Builder. P2UX will pass you the initial size to use with your Custom Control as well as a few other components that can be used to access any custom information created with your control in Builder.  The  elementInstance  parameter contains all the parameters specified using Builder for the control via its  itemSpec  member. Even though the parent  UIView  is passed to the create method, you should not add the instance of your  UIView  control to the parent as this is managed by P2UX when you return the instance of the control.  Objective-C example: creating a custom control in  P2UXAppBehavior  subclass:  -   ( UIView * )   createControlWithType: ( NSString   * ) type   elementInstance: ( P2UXElementInstance   * ) elementInstance   frame: ( CGRect ) frame   viewDelegate: ( id P2UXViewContainerDelegate ) viewDelegate   index: ( id ) index   data: ( id ) data   parent: ( UIView   * ) parent   { \n\n     if   ([ type   isEqualToString : @ graphcontrol ])   { \n\n         CustomGraph *   graph   =   [[ CustomGraph   alloc ]   initWithFrame : frame ]; \n         NSDictionary *   graphOpts   =   [ elementInstance . itemSpec   objectForKey : @ graphopts ]; \n         if   ( graphOpts   !=   nil )   { \n             // handle extra parameters here, for this example we defined an object \n             // in the itemspec of the control \n             // in Builder named  graphopts  which has information specific to  \n             // our graph object \n             graph . opts   =   graphOpts ; \n         } \n         return   graph ; \n     } \n     return   [ super   createControlWithType : type   elementInstance : elementInstance   frame : frame   viewDelegate : viewDelegate   index : index   data : data   parent : parent ];  }   Swift example: creating a custom control in  P2UXAppBehavior  subclass:  override   func   createControl ( withType   type :   String !,   elementInstance :   P2UXElementInstance !,   frame :   CGRect ,   viewDelegate :   P2UXViewContainerDelegate !,   index :   Any !,   data :   Any !,   parent :   UIView !)   -   UIView !   { \n\n     if   type   ==   graphcontrol   { \n         let   graph   :   CustomGraph   =   CustomGraph ( frame :   frame ); \n         if   let   graphOpts   =   elementInstance . itemSpec [ graphopts ]   as ?   NSDictionary   { \n             // handle extra parameters here, for this example we defined an object  \n             // in the itemspec of the control \n             // in Builder named  graphopts  which has information specific to  \n             // our graph object \n             graph . opts   =   graphOpts ; \n         } \n         return   graph ; \n     } \n     return   super . createControl ( withType :   type ,   elementInstance :   elementInstance ,   frame :   frame ,   viewDelegate :   viewDelegate ,   index :   index ,   data :   data ,   parent :   parent );  }", 
            "title": "Adding Custom UI Controls"
        }, 
        {
            "location": "/ios/customcode/#adding-custom-screenspanels", 
            "text": "In addition to using a  UIViewController  based class to override behavior for an application Screen or Panel, the actual Screen or Panel instance can also be overridden to provide any custom code needed for the hosted  UIView  itself.  P2UX will request an instance from  P2UXAppBehavior  when the Screen or Panel is created. If no instance is provided, P2UX will generate a standard instance of the Screen or Panel.  To provide a custom Screen instance, override the method  createScreenWithDef  from a  P2UXAppBehavior  subclass and return an instance of  P2UXScreen . To provide a custom Panel instance, override the method  createPanelWithDef  and return an instance of  P2UXPanel . (Both  P2UXScreen  and  P2UXPanel  are  UIView  based subclasses that add some additional helper methods. These methods make it easier to access screen components.)  Objective-C example: creating a custom Screen or Panel instance in P2UXAppBehavior subclass  // For custom Screen instances  -( P2UXScreen * )   createScreenWithDef: ( P2UXDefinition   * ) def   rect: ( CGRect ) rect   index: ( id ) index   data: ( id ) data   viewDelegate: ( id P2UXViewContainerDelegate ) viewDelegate   { \n\n     // If the screen \u201csystemType\u201d matches the name of the screen, return \n     // the custom screen instance \n     if   ([ def . systemType   isEqualToString : @ home ])   { \n         // Here we return an instance of HomeScreen which is a  \n         // subclass of P2UXScreen \n         return   [[ HomeScreen   alloc ]   initWithFrame : rect   contents : def   viewDelegate : viewDelegate   index : index   data : data ]; \n     } \n     return   [ super   createScreenWithDef : def   rect : rect   index : index   data : data   viewDelegate : viewDelegate ];  }  // For custom panel instances  -   ( P2UXPanel * )   createPanelWithDef: ( P2UXDefinition   * ) def   rect: ( CGRect ) rect   index: ( id ) index   data: ( id ) data   viewDelegate: ( id P2UXViewContainerDelegate ) viewDelegate   { \n\n     // if this is the userinfo panel, return the custom UserInfoPanel instance \n     if   ([ def . systemType   isEqualToString : @ userinfo ])   { \n         return   [[ UserInfoPanel   alloc ]   initWithFrame : rect   contents : def   viewDelegate : viewDelegate   index : index   data : data ]; \n     } \n     return   [ super   createPanelWithDef : def   rect : rect   index : index   data : data   viewDelegate : viewDelegate ];  }   Swift example: creating a custom Screen or Panel instance in  P2UXAppBehavior  subclass  // For custom Screen instances  override   func   createScreen ( withDef   def :   P2UXDefinition !,   rect :   CGRect ,   index :   Any !,   data :   Any !,   viewDelegate :   P2UXViewContainerDelegate !)   -   P2UXScreen !   { \n\n     // If the screen \u201csystemType\u201d matches the name of the screen, return \n     // the custom screen instance. \n     if   def . systemType   ==   home   {    \n        // Here we return an instance of HomeScreen which is a  \n        // subclass of P2UXScreen \n        return   HomeScreen ( frame :   rect ,   contents :   def ,   viewDelegate :   viewDelegate ,   index :   index ,   data :   data ); \n     } \n     return   super . createScreen ( withDef :   def ,   rect :   rect ,   index :   index ,   data :   data ,   viewDelegate :   viewDelegate );  }  // For custom panel instances  override   func   createPanel ( withDef   def :   P2UXDefinition !,   rect :   CGRect ,   index :   Any !,   data :   Any !,   viewDelegate :   P2UXViewContainerDelegate !)   -   P2UXPanel !   { \n\n     // If the panel \u201csystemType\u201d matches the name of the screen, return \n     // the custom panel instance. \n     if   def . systemType   ==   userinfo   { \n            // Here we return an instance of HomeScreen which is a  \n            // subclass of P2UXScreen \n            return   UserInfoPanel ( frame :   rect ,   contents :   def ,   viewDelegate :   viewDelegate ,   index :   index ,   data :   data ); \n     } \n     return   super . createPanel ( withDef :   def ,   rect :   rect ,   index :   index ,   data :   data ,   viewDelegate :   viewDelegate );  }", 
            "title": "Adding Custom Screens/Panels"
        }, 
        {
            "location": "/android/quickstart/", 
            "text": "Introduction\n\n\nWhat follows is a detailed tutorial that walks developers through all of the steps involved in creating a customizable Android application using P2UX. Developers should be familiar with the Android Studio integrated development environment and the Java programming language for custom coding.\n\n\n\n\nTerminology\n\n\nThroughout the P2UX documentation the \u201cdeveloper\u201d refers to you, the reader who is developing an app with P2UX. The \u201cdesigner\u201d refers to the individual whose principal job is to create the appearance and style of the app and its visual components. \u201cPRL\u201d refers to the P2UX Rendering Library for Android, which controls the creation and workflow of content created for the P2UX platform.\n\n\n\n\n\n\nCoding examples and code additions\n\n\nIn the coding examples below and throughout the documentation, changes and additions to be made by the developer are rendered with a blue highlight.\n\n\n\n\nP2UX versus the standard Android Studio environment\n\n\nP2UX based applications are easy to customize and extend for Android. The P2UX Android rendering library is based on the Android Widget package (android.widget) and other Android primitives. This means that writing custom business logic and integrating custom controls works much the same as it does when writing Android applications using Android Studio.\nWith the P2UX platform, XML Layout files are no longer required for Android development. Instead, applications use P2UX Portable UX Bundles (PUB) either as embedded or dynamically accessed resources. Additionally, P2UX provides hooks to developers that allow them access to all of the components of P2UX as well as the ability to fully customize instances of the application.\n\n\nGetting Started with P2UX and Android Studio\n\n\nJava\n\n\nP2UX native rendering libraries for Android can be extended using the Java programming language. The instructions below provide explicit reference to the proper use of Java coding in each applicable step that follows.\n\n\nCreating a new application\n\n\nFrom Android Studio environment:\n\n\n\n\nStart the Android Studio new project wizard either from the Welcome to Android Studio screen by clicking \u2018Start a new Android Studio project\u2019 or by selecting File-\nNew-\nNew Project.\n\n\nFrom the new project wizard enter your application name, company domain, and project location.\n\n\n\nIn the Target Android Devices window, set the minimum SDK to API 18: Android 4.3 (Jelly Bean).\n\n\nIn the Add an Activity to Mobile window, select the Empty Activity.\n\n\nIn the Customize the Activity window, uncheck the \u2018Generate Layout File\u2019 option.\n\n\n\n\nP2UX libraries download and PUB hook up\n\n\nThe next step in developing your project with P2UX is to include the P2UX libraries (AAR) for Android. The latest libraries can be downloaded from here. After downloading the libraries, make the following changes to hook up the PUB for the application:\n\n\n\n\nUnzip the library file.\n\n\nCreate a subdirectory under the root of your project directory, i.e. \u2018p2ux\u2019\n\n\nCopy P2UXCore.aar and P2UXApp.aar files into the subdirectory, \u2018p2ux\u2019.\n\n\nEdit the app\u2019s build.gradle (Module: app) to look like this:\n\n\n\n\napply plugin: \ncom.android.application\n\n\nandroid {\n   compileSdkVersion 26\n   buildToolsVersion \n26.0.2\n\n   defaultConfig {\n       applicationId \ncom.p2ux.sampleapp\n\n       minSdkVersion 18\n       targetSdkVersion 26\n       versionCode 1\n       versionName \n1.0\n\n       multiDexEnabled true\n   }\n   buildTypes {\n       release {\n           minifyEnabled false\n           proguardFiles getDefaultProguardFile(\nproguard-android.txt\n), \nproguard-rules.pro\n\n       }\n   }\n}\n\nrepositories {\n   mavenCentral()\n\n   flatDir { dirs \n../p2ux\n }   // Replace this directory with the location of P2UX libraries\n\n}\n\ndependencies {\n   compile fileTree(dir: \nlibs\n, include: [\n*.jar\n])\n   compile \ncom.android.support:appcompat-v7:26.1.0\n\n\n\n   compile(name: \nP2UXCore\n, ext: \naar\n)\n\n   compile(name: \nP2UXApp\n, ext: \naar\n)\n\n   compile \ncom.android.support:recyclerview-v7:26.1.0\n\n\n   // If Google Maps are required for your app, add the following 4 Google Play \n   // Services dependencies\n\n   compile \ncom.google.android.gms:play-services-maps:11.6.2\n\n\n   compile \ncom.google.android.gms:play-services-ads:11.6.2\n\n\n   compile \ncom.google.android.gms:play-services-identity:11.6.2\n\n\n   compile \ncom.google.android.gms:play-services-gcm:11.6.2\n\n\n   compile \ncom.madgag.spongycastle:core:1.54.0.0\n\n\n   compile \ncom.madgag.spongycastle:prov:1.54.0.0\n\n\n}\n\n\n\n\n\nMoving the app from Builder to Android Studio\n\n\n\n\nApp License and Android App Activity class\n\n\n\n\nAndroid Studio automatically generates an app activity class when you create a project. Unless you rename the file, the app activity file is named \nMainActivity\n. \nEdit the \nMainActivity\n file to look like this:\n\n\nimport\n \nandroid.os.Bundle\n;\n\n\n\nimport\n \ncom.p2ux.app.P2UXAppCreator\n;\n\n\nimport\n \ncom.p2ux.app.P2UXAppFragmentActivity\n;\n\n\nimport\n \ncom.p2ux.app.components.P2UXAppBehavior\n;\n\n\nimport\n \ncom.p2ux.core.utils.P2UXLog\n;\n\n\n\n\nimport\n \njava.util.ArrayList\n;\n\n\nimport\n \njava.util.HashMap\n;\n\n\n\npublic\n \nclass\n \nMainActivity\n \nextends\n \nP2UXAppFragmentActivity\n\n\n{\n\n   \n@Override\n\n   \npublic\n \nvoid\n \nonCreate\n(\nBundle\n \nsavedInstanceState\n)\n\n\n   \n{\n\n\n        \nsuper\n.\nonCreate\n(\nsavedInstanceState\n);\n\n\n        \n// You can get the app key or license key from builder for your app. This is required to link your builder up to your local app\n\n\n        \n// This is the key generated from Builder for the application. This key is needed to initialize the P2UX rendering framework.\n\n\n        \nString\n \nappKey\n \n=\n \nxxxxx\n;\n \n\n        \nHashMap\nString\n,\n \nObject\n \noptions\n \n=\n \nnew\n \nHashMap\n();\n\n\n        \nif\n \n((\ngetApplicationInfo\n().\nflags\n \n \nApplicationInfo\n.\nFLAG_DEBUGGABLE\n)\n \n==\n \nApplicationInfo\n.\nFLAG_DEBUGGABLE\n)\n \n{\n\n\n        \noptions\n.\nput\n(\nP2UXAppCreator\n.\nP2UXAppCreator_Opt_Env\n,\n \nP2UXAppCreator\n.\nP2UXAppCreator_Opt_Env_Recent\n);\n\n\n            \noptions\n.\nput\n(\nP2UXAppCreator\n.\nP2UXAppCreator_Opt_LogLevel\n,\n \nP2UXLog\n.\nP2UXCoreLogFlagVerbose\n);\n\n        \n}\n\n        \nsuper\n.\nsetupApp\n(\nsavedInstanceState\n,\n \nappKey\n,\n \noptions\n,\n \nnull\n);\n\n   \n}\n\n\n}\n\n\n\n\n\n\nNext, retrieve the app\u2019s license. In Builder, to the right of the publish button are further options in a drop-down menu. Select \n\u201cGet App License\u201d\n from the menu and a window will pop up with your app\u2019s license. Copy the license. The \nMainActivity\n calls the super.OnCreate() with the \nmAppKey\n. This initializes the PRL with the application information. In this example, options supplied to the savedInstanceState variable use the prototype version of the application when the application is compiled for debugging. To use the production version of the application, remove the section that checks for \nFLAG_DEBUGGABLE\n.\n\n\n\nIn \nMainActivity\n, replace the \n\u201cxxxxxx\u201d\n in the line that reads \n\u201cmAppKey = \u201cxxxxxx\u201d;\n with the app\u2019s license you just retrieved from Builder to finalize the initial app setup in P2UX.\n\n\n\n\nNote\n\n\nAt this point the application setup is complete and the app should run successfully.\n\n\n\n\nThe PUB and network connectivity\n\n\nThe next step in the process requires developer awareness of the default PUB status and access to a network.\n\n\nBy default, the application accesses the PUB dynamically. This means that when the application is first installed, the P2UX rendering library (PRL) will authenticate the application key and then download the PUB before running the application content.\n\n\nThe first run of an application requires network connectivity. Otherwise, P2UX will return an error. The PUB\u2019s default update policy is automatic. This means that the PRL will automatically check for updates each time the application runs. The library will also download any updates that are available, and then notify the user that the application will restart to apply any updates.\n\n\nStatic Assets\n\n\nIn some cases, a developer may opt to use only static assets rather than require network access for an app. In this situation, the PUB can be added to the application as a collection of static assets. Additionally, other static assets usable by the app can be added to an Android project. To achieve this, follow these steps:\n\n\n\n\nNote\n\n\nThis feature requires downloading your application PUB from Builder. This feature will be integrated as part of the P2UX Coordinator application for Mac OS\n\n\n\n\n\n\nIn Builder, download the published PUB for application\n\n\nSteps to download PUB will go here\n\n\n\n\n\n\nUnzip the PUB files and copy the assets into a folder inside your project directory.\n\n\nIn Android Studio, add the assets folder to the project.\n\n\nFrom the Android project navigator, select the app module folder.\n\n\nRight click and select \nNew-\nFolder-\nAssets\n Folder.\n\n\n\nFrom the \nConfigure Component\n dialog, click \nFinish\n. This creates a folder named \nassets\n under your app main folder.\n\n\n\nRename the folder containing the PUB assets to something more readable such as \nphone_pub\n.\n\n\nMove the \u2018phone_pub\u2019 folder to the \u2018assets\u2019 folder.\n\n\n\n\n\n\n\n\nIn order to incorporate these files into your project, as well as to adjust the resource use settings, you must change the Activity file. Edit the \nMainActivity\n file to look like this:\n\n\n@Override\n\n\npublic\n \nvoid\n \nonCreate\n(\nBundle\n \nsavedInstanceState\n)\n\n\n{\n\n    \nsuper\n.\nonCreate\n(\nsavedInstanceState\n);\n\n\n\n    \nString\n \nappKey\n \n=\n \nxxxxx\n;\n \n\n    \nArrayList\nHashMap\nString\n,\n \nObject\n \nresources\n \n=\n \nnew\n \nArrayList\n();\n\n\n    \n// Set up external resource\n\n\n    \nHashMap\nString\n,\n \nObject\n \nphoneRes\n \n=\n \nnew\n \nHashMap\n();\n\n\n    \nphoneRes\n.\nput\n(\nP2UXAppTypes\n.\nP2UXApp_PackageAttrib_FormFactor\n,\n \n0\n);\n\n\n    \nphoneRes\n.\nput\n(\nP2UXAppTypes\n.\nP2UXApp_PackageAttrib_Type\n,\n \nP2UXAppTypes\n.\nP2UXApp_PackageType_Static\n);\n\n\n    \nphoneRes\n.\nput\n(\nP2UXAppTypes\n.\nP2UXApp_PackageAttrib_Package\n,\n \nshellui_phone\n);\n\n\n    \nphoneRes\n.\nput\n(\nP2UXAppTypes\n.\nP2UXApp_PackageAttrib_Update\n,\n \nP2UXAppTypes\n.\nP2UXApp_PackageUpdate_None\n);\n\n\n    \nresources\n.\nadd\n(\nphoneRes\n);\n\n\n    \nsuper\n.\nsetupApp\n(\nsavedInstanceState\n,\n \nappKey\n,\n \noptions\n,\n \nnull\n);\n\n\n}\n\n\n\n\n\n\nDefining Custom Resource Attributes\n\n\nIf desired, the developer can define specific resource attributes for the app.\n\n\nThe resources parameter is an array of objects. Each object in the array defines the PUB usage for a particular form factor (Phone, Tablet, TV) using key value pairs. If the application supports multiple form factors, create an object in the resources array for each form factor.\n\n\nCustomize the resource attributes according to the possibilities below:\n\n\n\n\n\n\n\n\nResource Attribute\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nP2UXApp_PackageAttrib_FormFactor\n\n\nDefines which form factor the attributes reference.\nPossible Values:\nP2UXFormFactor_Phone\nP2UXFormFactor_Tablet\nP2UXFormFactor_TV\n\n\n\n\n\n\nP2UXApp_PackageAttrib_Type\n\n\nDefines the type of resources for the form factor\nPossible Values:\nP2UXApp_PackageType_Static\nP2UXApp_PackageType_Remote\n\n\n\n\n\n\nP2UXApp_PackageAttrib_Package\n\n\nDefines the name of the folder within the application bundle containing assets when the P2UXApp_PackageAttrib_Type is P2UXApp_PackageType_Static.\n\n\n\n\n\n\nP2UXApp_PackageAttrib_Update\n\n\nDefines how to update the application assets\nPossible Values:\nP2UXApp_PackageUpdate_None\nP2UXApp_PackageUpdate_Auto\nP2UXApp_PackageUpdate_Manual", 
            "title": "Quick Start"
        }, 
        {
            "location": "/android/quickstart/#introduction", 
            "text": "What follows is a detailed tutorial that walks developers through all of the steps involved in creating a customizable Android application using P2UX. Developers should be familiar with the Android Studio integrated development environment and the Java programming language for custom coding.   Terminology  Throughout the P2UX documentation the \u201cdeveloper\u201d refers to you, the reader who is developing an app with P2UX. The \u201cdesigner\u201d refers to the individual whose principal job is to create the appearance and style of the app and its visual components. \u201cPRL\u201d refers to the P2UX Rendering Library for Android, which controls the creation and workflow of content created for the P2UX platform.    Coding examples and code additions  In the coding examples below and throughout the documentation, changes and additions to be made by the developer are rendered with a blue highlight.   P2UX versus the standard Android Studio environment  P2UX based applications are easy to customize and extend for Android. The P2UX Android rendering library is based on the Android Widget package (android.widget) and other Android primitives. This means that writing custom business logic and integrating custom controls works much the same as it does when writing Android applications using Android Studio.\nWith the P2UX platform, XML Layout files are no longer required for Android development. Instead, applications use P2UX Portable UX Bundles (PUB) either as embedded or dynamically accessed resources. Additionally, P2UX provides hooks to developers that allow them access to all of the components of P2UX as well as the ability to fully customize instances of the application.", 
            "title": "Introduction"
        }, 
        {
            "location": "/android/quickstart/#getting-started-with-p2ux-and-android-studio", 
            "text": "Java  P2UX native rendering libraries for Android can be extended using the Java programming language. The instructions below provide explicit reference to the proper use of Java coding in each applicable step that follows.", 
            "title": "Getting Started with P2UX and Android Studio"
        }, 
        {
            "location": "/android/quickstart/#creating-a-new-application", 
            "text": "From Android Studio environment:   Start the Android Studio new project wizard either from the Welcome to Android Studio screen by clicking \u2018Start a new Android Studio project\u2019 or by selecting File- New- New Project.  From the new project wizard enter your application name, company domain, and project location.  In the Target Android Devices window, set the minimum SDK to API 18: Android 4.3 (Jelly Bean).  In the Add an Activity to Mobile window, select the Empty Activity.  In the Customize the Activity window, uncheck the \u2018Generate Layout File\u2019 option.", 
            "title": "Creating a new application"
        }, 
        {
            "location": "/android/quickstart/#p2ux-libraries-download-and-pub-hook-up", 
            "text": "The next step in developing your project with P2UX is to include the P2UX libraries (AAR) for Android. The latest libraries can be downloaded from here. After downloading the libraries, make the following changes to hook up the PUB for the application:   Unzip the library file.  Create a subdirectory under the root of your project directory, i.e. \u2018p2ux\u2019  Copy P2UXCore.aar and P2UXApp.aar files into the subdirectory, \u2018p2ux\u2019.  Edit the app\u2019s build.gradle (Module: app) to look like this:   apply plugin:  com.android.application \n\nandroid {\n   compileSdkVersion 26\n   buildToolsVersion  26.0.2 \n   defaultConfig {\n       applicationId  com.p2ux.sampleapp \n       minSdkVersion 18\n       targetSdkVersion 26\n       versionCode 1\n       versionName  1.0 \n       multiDexEnabled true\n   }\n   buildTypes {\n       release {\n           minifyEnabled false\n           proguardFiles getDefaultProguardFile( proguard-android.txt ),  proguard-rules.pro \n       }\n   }\n}\n\nrepositories {\n   mavenCentral()    flatDir { dirs  ../p2ux  }   // Replace this directory with the location of P2UX libraries }\n\ndependencies {\n   compile fileTree(dir:  libs , include: [ *.jar ])\n   compile  com.android.support:appcompat-v7:26.1.0     compile(name:  P2UXCore , ext:  aar )    compile(name:  P2UXApp , ext:  aar )    compile  com.android.support:recyclerview-v7:26.1.0     // If Google Maps are required for your app, add the following 4 Google Play \n   // Services dependencies    compile  com.google.android.gms:play-services-maps:11.6.2     compile  com.google.android.gms:play-services-ads:11.6.2     compile  com.google.android.gms:play-services-identity:11.6.2     compile  com.google.android.gms:play-services-gcm:11.6.2     compile  com.madgag.spongycastle:core:1.54.0.0     compile  com.madgag.spongycastle:prov:1.54.0.0  }", 
            "title": "P2UX libraries download and PUB hook up"
        }, 
        {
            "location": "/android/quickstart/#moving-the-app-from-builder-to-android-studio", 
            "text": "App License and Android App Activity class   Android Studio automatically generates an app activity class when you create a project. Unless you rename the file, the app activity file is named  MainActivity . \nEdit the  MainActivity  file to look like this:  import   android.os.Bundle ;  import   com.p2ux.app.P2UXAppCreator ;  import   com.p2ux.app.P2UXAppFragmentActivity ;  import   com.p2ux.app.components.P2UXAppBehavior ;  import   com.p2ux.core.utils.P2UXLog ;   import   java.util.ArrayList ;  import   java.util.HashMap ;  public   class   MainActivity   extends   P2UXAppFragmentActivity  { \n    @Override \n    public   void   onCreate ( Bundle   savedInstanceState )      {           super . onCreate ( savedInstanceState );           // You can get the app key or license key from builder for your app. This is required to link your builder up to your local app           // This is the key generated from Builder for the application. This key is needed to initialize the P2UX rendering framework.           String   appKey   =   xxxxx ;            HashMap String ,   Object   options   =   new   HashMap ();           if   (( getApplicationInfo (). flags     ApplicationInfo . FLAG_DEBUGGABLE )   ==   ApplicationInfo . FLAG_DEBUGGABLE )   {           options . put ( P2UXAppCreator . P2UXAppCreator_Opt_Env ,   P2UXAppCreator . P2UXAppCreator_Opt_Env_Recent );               options . put ( P2UXAppCreator . P2UXAppCreator_Opt_LogLevel ,   P2UXLog . P2UXCoreLogFlagVerbose ); \n         } \n         super . setupApp ( savedInstanceState ,   appKey ,   options ,   null ); \n    }  }   Next, retrieve the app\u2019s license. In Builder, to the right of the publish button are further options in a drop-down menu. Select  \u201cGet App License\u201d  from the menu and a window will pop up with your app\u2019s license. Copy the license. The  MainActivity  calls the super.OnCreate() with the  mAppKey . This initializes the PRL with the application information. In this example, options supplied to the savedInstanceState variable use the prototype version of the application when the application is compiled for debugging. To use the production version of the application, remove the section that checks for  FLAG_DEBUGGABLE .  In  MainActivity , replace the  \u201cxxxxxx\u201d  in the line that reads  \u201cmAppKey = \u201cxxxxxx\u201d;  with the app\u2019s license you just retrieved from Builder to finalize the initial app setup in P2UX.   Note  At this point the application setup is complete and the app should run successfully.", 
            "title": "Moving the app from Builder to Android Studio"
        }, 
        {
            "location": "/android/quickstart/#the-pub-and-network-connectivity", 
            "text": "The next step in the process requires developer awareness of the default PUB status and access to a network.  By default, the application accesses the PUB dynamically. This means that when the application is first installed, the P2UX rendering library (PRL) will authenticate the application key and then download the PUB before running the application content.  The first run of an application requires network connectivity. Otherwise, P2UX will return an error. The PUB\u2019s default update policy is automatic. This means that the PRL will automatically check for updates each time the application runs. The library will also download any updates that are available, and then notify the user that the application will restart to apply any updates.", 
            "title": "The PUB and network connectivity"
        }, 
        {
            "location": "/android/quickstart/#static-assets", 
            "text": "In some cases, a developer may opt to use only static assets rather than require network access for an app. In this situation, the PUB can be added to the application as a collection of static assets. Additionally, other static assets usable by the app can be added to an Android project. To achieve this, follow these steps:   Note  This feature requires downloading your application PUB from Builder. This feature will be integrated as part of the P2UX Coordinator application for Mac OS    In Builder, download the published PUB for application  Steps to download PUB will go here    Unzip the PUB files and copy the assets into a folder inside your project directory.  In Android Studio, add the assets folder to the project.  From the Android project navigator, select the app module folder.  Right click and select  New- Folder- Assets  Folder.  From the  Configure Component  dialog, click  Finish . This creates a folder named  assets  under your app main folder.  Rename the folder containing the PUB assets to something more readable such as  phone_pub .  Move the \u2018phone_pub\u2019 folder to the \u2018assets\u2019 folder.     In order to incorporate these files into your project, as well as to adjust the resource use settings, you must change the Activity file. Edit the  MainActivity  file to look like this:  @Override  public   void   onCreate ( Bundle   savedInstanceState )  { \n     super . onCreate ( savedInstanceState );       String   appKey   =   xxxxx ;        ArrayList HashMap String ,   Object   resources   =   new   ArrayList ();       // Set up external resource       HashMap String ,   Object   phoneRes   =   new   HashMap ();       phoneRes . put ( P2UXAppTypes . P2UXApp_PackageAttrib_FormFactor ,   0 );       phoneRes . put ( P2UXAppTypes . P2UXApp_PackageAttrib_Type ,   P2UXAppTypes . P2UXApp_PackageType_Static );       phoneRes . put ( P2UXAppTypes . P2UXApp_PackageAttrib_Package ,   shellui_phone );       phoneRes . put ( P2UXAppTypes . P2UXApp_PackageAttrib_Update ,   P2UXAppTypes . P2UXApp_PackageUpdate_None );       resources . add ( phoneRes );       super . setupApp ( savedInstanceState ,   appKey ,   options ,   null );  }", 
            "title": "Static Assets"
        }, 
        {
            "location": "/android/quickstart/#defining-custom-resource-attributes", 
            "text": "If desired, the developer can define specific resource attributes for the app.  The resources parameter is an array of objects. Each object in the array defines the PUB usage for a particular form factor (Phone, Tablet, TV) using key value pairs. If the application supports multiple form factors, create an object in the resources array for each form factor.  Customize the resource attributes according to the possibilities below:     Resource Attribute  Description      P2UXApp_PackageAttrib_FormFactor  Defines which form factor the attributes reference. Possible Values: P2UXFormFactor_Phone P2UXFormFactor_Tablet P2UXFormFactor_TV    P2UXApp_PackageAttrib_Type  Defines the type of resources for the form factor Possible Values: P2UXApp_PackageType_Static P2UXApp_PackageType_Remote    P2UXApp_PackageAttrib_Package  Defines the name of the folder within the application bundle containing assets when the P2UXApp_PackageAttrib_Type is P2UXApp_PackageType_Static.    P2UXApp_PackageAttrib_Update  Defines how to update the application assets Possible Values: P2UXApp_PackageUpdate_None P2UXApp_PackageUpdate_Auto P2UXApp_PackageUpdate_Manual", 
            "title": "Defining Custom Resource Attributes"
        }, 
        {
            "location": "/android/customcode/", 
            "text": "Introduction\n\n\nWhat follows is a detailed tutorial that walks developers through the steps of writing custom code for an Android application using P2UX. Developers should be familiar with the Android Studio integrated development environment for MacOS and the Java programming languages for custom coding. \n\n\nTopics include customizable View and control behaviors, Screen/Panels, and UI controls.\n\n\n\n\nTerminology\n\n\nThroughout the P2UX documentation the \u201cdeveloper\u201d refers to you, the reader who is developing an app with P2UX. The \u201cdesigner\u201d refers to the individual whose principal job is to create the appearance and style of the app and its visual components. \u201cPRL\u201d refers to the P2UX Rendering Library for iOS, which controls the creation and workflow of content created for the P2UX platform.\n\n\n\n\n\n\nCoding examples and code additions\n\n\nIn the coding examples below and throughout the documentation, changes and additions to be made by the developer are rendered with a blue highlight.\n\n\n\n\nP2UX versus the standard Android Studio environment\n\n\nP2UX based applications are easy to customize and extend for Android. The P2UX Android rendering library is based on the Android Widget package (android.widget) and other Android primitives. This means that writing custom business logic and integrating custom controls works much the same as it does when writing Android applications using Android Studio.\nWith the P2UX platform, XML Layout files are no longer required for Android development. Instead, applications use P2UX Portable UX Bundles (PUB) either as embedded or dynamically accessed resources. Additionally, P2UX provides hooks to developers that allow them access to all of the components of P2UX as well as the ability to fully customize instances of the application.\n\n\n\n\nCreate a P2UX enabled project first\n\n\nThis document assumes a P2UX enabled Android Studio project has already been created. See \nQuick Start\n for steps to create a project.\n\n\n\n\nP2UX and Android Studio\n\n\nJava\n\n\nP2UX native rendering libraries for Android can be extended using the Java programming language. The instructions below provide explicit reference to the proper use of Java coding in each applicable step that follows.\n\n\nAdding Custom Behaviors\n\n\nIf desired, customizable behaviors can be added to the project code.\n\n\nA subclass of the \nP2UXAppBehavior\n class is the starting point for customizing the behavior of the application. From this class, all other parts of the application can be customized. (Common customized behaviors include creation of a Custom Control or overriding a particular View.)\n\n\nIn Android Studio, create a class to store the customized behaviors. The easiest way to do is by doing a right click on your project package and selecting \nNew-\nJava Class\n. (This example uses the name \nSampleBehavior\n.) In the \nCreate New Class\n dialog, type in \nP2UXAppBehavior\n in the Superclass field.\n\n\nThis will create \nSampleBehavior\n class. Put any customized behaviors within the implementation here. Below is a list of available customization methods for \nP2UXAppBehavior\n:\n\n\n\n\n\n\n\n\nModifier and Type\n\n\nMethod and Description\n\n\n\n\n\n\n\n\n\n\nP2UXFragment\n\n\ncreateViewFragment(int type, Context context, P2UXDefinition def, P2UXFragment.UXFragmentDelegate fragmentDelegate, RectF rect, boolean cache, Object index, Object data, P2UXViewContainerDelegate viewDelegate)\nCreates a custom fragment\n\n\n\n\n\n\nP2UXScreen\n\n\ncreateScreen(Context context, P2UXDefinition def, RectF rect, Object index, Object data, P2UXViewContainerDelegate viewDelegate)\nCreates a custom screen\n\n\n\n\n\n\nP2UXPanel\n\n\ncreatePanel(Context context, P2UXDefinition def, RectF rect, Object index, Object data, P2UXViewContainerDelegate viewDelegate)\nCreates a custom panel\n\n\n\n\n\n\nView\n\n\ncreateControl(String type, P2UXElementInstance elInstance, RectF rect, P2UXViewContainerDelegate viewDelegate, Object index, Object data)\nCreates a custom control\n\n\n\n\n\n\n\n\nIn addition, update \nMainActivity\n to include the custom behaviors.\n\n\nTo do this,\nMainActivity\n must override the method \ncreateBehavior\n. (This will override any default behaviors.) Edit \nMainActivity\n to look like this:\n\n\n@Override\n\n\npublic\n \nvoid\n \nonCreate\n(\nBundle\n \nsavedInstanceState\n)\n\n\n{\n\n   \nmAppKey\n \n=\n \nxxxxx\n;\n      \n   \ntry\n \n{\n\n       \nmResources\n \n=\n \nnew\n \nJSONArray\n();\n\n       \nJSONObject\n \nresource\n \n=\n \nnew\n \nJSONObject\n();\n\n       \nresource\n.\nput\n(\nP2UXAppTypes\n.\nP2UXApp_PackageAttrib_FormFactor\n,\n \n0\n);\n\n       \nresource\n.\nput\n(\nP2UXAppTypes\n.\nP2UXApp_PackageAttrib_Type\n,\n \nP2UXAppTypes\n.\nP2UXApp_PackageType_Static\n);\n\n       \nresource\n.\nput\n(\nP2UXAppTypes\n.\nP2UXApp_PackageAttrib_Package\n,\n \nshellui_phone\n);\n\n       \nresource\n.\nput\n(\nP2UXAppTypes\n.\nP2UXApp_PackageAttrib_Update\n,\n \nP2UXAppTypes\n.\nP2UXApp_PackageUpdate_None\n);\n\n       \nmResources\n.\nput\n(\nresource\n);\n\n   \n}\n\n   \ncatch\n \n(\nJSONException\n \ne\n)\n\n   \n{\n\n       \nP2UXLog\n.\ne\n(\nTAG\n,\n \nonCreate - \n \n+\n \ne\n.\ngetMessage\n());\n\n   \n}\n\n\n   \nif\n \n((\ngetApplicationInfo\n().\nflags\n \n \nApplicationInfo\n.\nFLAG_DEBUGGABLE\n)\n \n==\n \nApplicationInfo\n.\nFLAG_DEBUGGABLE\n)\n \n{\n\n       \nif\n \n(\nsavedInstanceState\n \n==\n \nnull\n)\n \n{\n\n           \nsavedInstanceState\n \n=\n \nnew\n \nBundle\n();\n\n       \n}\n\n       \nsavedInstanceState\n.\nputString\n(\nP2UXAppCreator\n.\nP2UXAppCreator_Opt_Env\n,\n \nP2UXAppCreator\n.\nP2UXAppCreator_Opt_Env_Prototype\n);\n\n       \nsavedInstanceState\n.\nputLong\n(\nP2UXAppCreator\n.\nP2UXAppCreator_Opt_LogLevel\n,\n \nP2UXLog\n.\nP2UXCoreLogFlagVerbose\n);\n\n   \n}\n\n\n   \nsuper\n.\nonCreate\n(\nsavedInstanceState\n);\n\n   \napplyTranslucentStatusBar\n();\n\n\n}\n\n\n\n@Override\n\n\npublic\n \nP2UXAppBehavior\n \ncreateBehavior\n(\nString\n \nappId\n)\n\n\n{\n\n\n   \nreturn\n \nnew\n \nSampleAppBehavior\n();\n\n\n}\n\n\n\n\n\n\nAdding Custom Fragment\n\n\nDevelopers can override Fragment instances to provide any custom code needed for a fragment lifecycle/behavior and its hosted \nView\n.\n\n\nThe PRL will request an instance from \nP2UXAppBehavior\n when it needs to create a new fragment. If no instance is provided, P2UX will generate a standard instance of the Fragment.\n\n\nTo provide a custom Fragment instance, override the method \ncreateViewFragment\n from a \nP2UXAppBehavior\n subclass and return an instance of \nP2UXFragment\n. \n\n\nTo handle button click action, override the method \nhandleButtonClick\n from \nP2UXAppFragment\n. To access a control in the fragment, override the method \nviewCreated\n from \nP2UXAppFragment\n. \n\n\nThe name of a chosen Fragment is the value used to identify the screen when the PRL creates an instance of this object. The \u201cdef\u201d parameter passed to this method contains the member variable \nsystemType\n that identifies the Screen being created. From this object, the developer determines the requested Screen and the specific \nP2UXFragment\n subclass to instantiate.\n\n\nCreating a custom Fragment instance in a \nP2UXAppBehavior\n subclass\n\n\n@Override\n\n\npublic\n \nP2UXFragment\n \ncreateViewFragment\n(\nint\n \ntype\n,\n \nContext\n \ncontext\n,\n \nP2UXDefinition\n \ndef\n,\n \nP2UXFragment\n.\nUXFragmentDelegate\n \nfragmentDelegate\n,\n \nRectF\n \nrect\n,\n \nboolean\n \ncache\n,\n \nObject\n \nindex\n,\n \nObject\n \ndata\n,\n \nP2UXViewContainerDelegate\n \nviewDelegate\n)\n\n\n{\n\n   \nif\n \n(\ndef\n.\ngetSystemType\n().\nequals\n(\nxxxxx\n))\n \n{\n\n       \n//return a fragment here, for example:\n\n       \nreturn\n \nnew\n \nSampleFragment\n(\ncontext\n,\n \ndef\n,\n \nfragmentDelegate\n,\n \nrect\n,\n \ncache\n,\n \nindex\n,\n \ndata\n,\n \nviewDelegate\n);\n\n   \n}\n\n   \nreturn\n \nsuper\n.\ncreateViewFragment\n(\ntype\n,\n \ncontext\n,\n \ndef\n,\n \nfragmentDelegate\n,\n \nrect\n,\n \ncache\n,\n \nindex\n,\n \ndata\n,\n \nviewDelegate\n);\n\n\n}\n\n\n\n@Override\n\n\npublic\n \nvoid\n \nviewCreated\n()\n\n\n{\n\n    \nsuper\n.\nviewCreated\n();\n\n    \nP2UXButton\n \nbtn\n \n=\n \n(\nP2UXButton\n)\n \ncontrolWithElementSystemTypeOrId\n(\nshow_btn\n);\n\n    \nif\n \n(\nbtn\n \n!=\n \nnull\n)\n \n{\n\n       \nbtn\n.\nsetEnabled\n(\nfalse\n);\n\n    \n}\n\n\n}\n\n\n\n@Override\n\n\npublic\n \nboolean\n \nhandleButtonClick\n(\nView\n \nctrl\n)\n \n\n{\n\n    \nP2UXElementInstance\n \nelementInstance\n \n=\n \nP2UXControlHelper\n.\ngetElementInstance\n(\nctrl\n);\n\n    \nif\n \n(\nelInstance\n \n!=\n \nnull\n \n \nelInstance\n.\ngetSystemType\n.\nequals\n(\nbutton1\n))\n\n    \n{\n\n        \nString\n \nelId\n \n=\n \nelInstance\n.\ngetElId\n();\n\n        \nif\n \n(\nelId\n \n!=\n \nnull\n \n \nelId\n.\nequals\n(\nbutton1\n))\n \n{\n\n           \n// take some custom action here for the \nokbtn\n\n\n           \n// return true to indicate the event was handled and propagation\n\n           \n// shouldn\nt continue\n\n           \nreturn\n \ntrue\n;\n\n        \n}\n\n    \n}\n\n    \nreturn\n \nsuper\n.\nhandleButtonClick\n(\nctrl\n);\n\n\n}\n\n\n\n\n\n\nAdding Custom Screens/Panels\n\n\nDevelopers can override Screen or Panel instances to provide any custom code needed for a hosted \nView\n.\n\n\nSince the P2UX UI is not based on XML Layout, connecting custom methods for each button click action is unnecessary. Instead, the developer can override the methods of the \nP2UXScreen\n class to handle button click and other UI events. (In all other respects, writing code for customized Screen and Panel behavior is the same as for XML layout-based content.)\n\n\nThe PRL will request an instance from \nP2UXAppBehavior\n when it needs to create a new Screen or Panel. If no instance is provided, P2UX will generate a standard instance of the Screen or Panel.\n\n\nTo provide a custom Screen instance, override the method \ncreateScreen\n from a \nP2UXAppBehavior\n subclass and return an instance of \nP2UXScreen\n. To provide a custom Panel instance, override the method \ncreatePanel\n and return an instance of \nP2UXPanel\n. (Both \nP2UXScreen\n and \nP2UXPanel\n are \nView\n based subclasses that add some additional helper methods. These methods make it easier to access screen components.)\n\n\nThe name of a chosen Screen or Panel is the value used to identify the item when the PRL creates an instance of this object. The \u201cdef\u201d parameter passed to this method contains the member variable \nsystemType\n that identifies the Screen being created. From this object, the developer determines the requested Screen and the specific \nP2UXScreen\n or \nP2UXPanel\n subclass to instantiate.\n\n\nCreating a custom Screen or Panel instance in a \nP2UXAppBehavior\n subclass\n\n\n@Override\n\n\npublic\n \nP2UXScreen\n \ncreateScreen\n(\nContext\n \ncontext\n,\n \nP2UXDefinition\n \ndef\n,\n \nRectF\n \nrect\n,\n \nObject\n \nindex\n,\n \nObject\n \ndata\n,\n \nP2UXViewContainerDelegate\n \nviewDelegate\n)\n\n\n{\n\n   \nif\n \n(\ndef\n.\ngetSystemType\n().\nequals\n(\nxxxxx\n))\n \n{\n\n       \n//return some screen here, for example:\n\n       \nreturn\n \nnew\n \nSampleScreen\n(\ncontext\n,\n \nrect\n,\n \ndef\n,\n \nviewDelegate\n,\n \nindex\n,\n \ndata\n);\n\n   \n}\n\n   \nreturn\n \nsuper\n.\ncreateScreen\n(\ncontext\n,\n \ndef\n,\n \nrect\n,\n \nindex\n,\n \ndata\n,\n \nviewDelegate\n);\n\n\n}\n\n\n\n@Override\n\n\npublic\n \nP2UXPanel\n \ncreatePanel\n(\nContext\n \ncontext\n,\n \nP2UXDefinition\n \ndef\n,\n \nRectF\n \nrect\n,\n \nObject\n \nindex\n,\n \nObject\n \ndata\n,\n \nP2UXViewContainerDelegate\n \nviewDelegate\n)\n\n\n{\n\n   \nif\n \n(\ndef\n.\ngetSystemType\n().\nequals\n(\nxxxxx\n))\n \n{\n\n       \n//return some screen here, for example:\n\n       \nreturn\n \nnew\n \nSamplePanel\n(\ncontext\n,\n \nrect\n,\n \ndef\n,\n \nviewDelegate\n,\n \nindex\n,\n \ndata\n);\n\n   \n}\n\n   \nreturn\n \nsuper\n.\ncreatePanel\n(\ncontext\n,\n \ndef\n,\n \nrect\n,\n \nindex\n,\n \ndata\n,\n \nviewDelegate\n);\n\n\n}\n\n\n\n\n\n\nAccessing Control instances from \nP2UXPanel\n or \nP2UXScreen\n\n\nTo access instances of controls, \nP2UXScreen\n provides a helper method, \ncontrolWithElementSystemTypeOrId\n. This method takes the name or id of the control to be accessed and returns a control instance.\n\n\n\u201cSystem type\u201d references\n\n\nAfter creating a control, the developer can set a \u201csystem type\u201d for the control in Builder. This effectively becomes the name for the new control. Referring to the control by its \u201csystem type\u201d means that the developer does not need to change any existing custom code when choosing to create an alternate variation of the same control. (Otherwise, if the developer changes the name of the control in Builder, any custom code to referring to the new name would have to be changed as well.)\n\n\nAccessing a control in a custom instance of \nP2UXScreen\n looks like this:\n\n\n@Override\n\n\npublic\n \nvoid\n \nshowView\n(\nboolean\n \nreload\n)\n\n\n{\n\n   \nsuper\n.\nshowView\n(\nreload\n);\n\n   \nP2UXButton\n \nbtn\n \n=\n \n(\nP2UXButton\n)\n \ncontrolWithElementSystemTypeOrId\n(\nshow_btn\n);\n\n   \nif\n \n(\nbtn\n \n!=\n \nnull\n)\n \n{\n\n       \nbtn\n.\nsetEnabled\n(\nfalse\n);\n\n   \n}\n\n\n}\n\n\n\n\n\n\nHandling Events from P2UXAppController\n\n\nEnd-users of a completed app will interact with controls in a Screen or Panel to generate events. These interactions will, in turn, trigger actions. Typically the PRL handles events directly through event interactions set up in Builder. In some cases, additional custom code may be needed to trigger actions not directly supported by P2UX.\n\n\nThe PRL provides a chain of event handlers that propagate an event through different components. Handling events at any point in the propagation chain provides a way to trigger custom code and also (optionally) to stop the propagation of the event at any specific handler.\n\n\nEvent propagation follows a set pattern.\n\n\nFirst, events are relayed to the \nP2UXScreen\n for the current Screen or Panel. Next, they pass to \nP2UXAppBehavior\n. Finally, events are handled by the custom instance of the \nView\n itself. If none of these components halt event propagation, the PRL will then handle any interactions defined for the event in Builder.\n\n\nThe \nP2UXScreen\n contains helper methods that handle a variety of events when they occur. These methods give the developer a chance to integrate any custom code needed from the basic event level without triggering any custom actions.\n\n\nMost standard control events are routed through the \nP2UXScreen\n instance. Handling these events is a matter of overriding the appropriate event method in your P2UXScreen subclass. Event propagation can be allowed to continue or not depending on the return value from the event handler methods.\n\n\nThe example below illustrates the code that handles a Button press event.\n\n\nHandling a Button press event in P2UXScreen subclass:\n\n\n@Override\n\n\npublic\n \nboolean\n \nhandleButtonClick\n(\nView\n \nctrl\n,\n \nP2UXElementInstance\n \nelInstance\n)\n\n\n{\n\n   \nif\n \n(\nelInstance\n \n!=\n \nnull\n \n \nelInstance\n.\ngetSystemType\n.\nequals\n(\nbutton1\n))\n\n   \n{\n\n       \nString\n \nelId\n \n=\n \nelInstance\n.\ngetElId\n();\n\n       \nif\n \n(\nelId\n \n!=\n \nnull\n \n \nelId\n.\nequals\n(\nbutton1\n))\n \n{\n\n           \n// take some custom action here for the \nokbtn\n\n\n           \n// return true to indicate the event was handled and propagation\n\n           \n// shouldn\nt continue\n\n           \nreturn\n \ntrue\n;\n\n       \n}\n\n   \n}\n\n   \nreturn\n \nsuper\n.\nhandleButtonClick\n(\nctrl\n);\n\n\n}\n\n\n\n\n\n\nAdding Custom UI Controls\n\n\nUI Controls are the visual components of a Screen or Panel created in the Builder tool. These can be interactive, like Buttons or Sliders, or non-interactive, like Shapes or Text. Although P2UX offers many different UI Controls directly creatable and usable in Builder, a specific application may require developer-defined UI controls. Builder provides a Custom Control component that can be added to a Screen or Panel and then replaced using custom code.\n\n\nAny \nView\n based control can be injected into your Screens and Panels via a Custom Control. This allows for existing custom controls or third party custom controls to be used with P2UX based applications.\n\n\nThe PRL manages the size and position of any custom controls defined using Builder. To provide an instance of a custom control, override the method createControl in your \nP2UXAppBehavior\n subclass and return the \nView\n subclassed instance of your control. The first parameter passed to this method, type, is the name of the control set when you created the custom control in Builder. P2UX will pass the initial size to use with your Custom Control, as well as a few other components that can be used to access any custom information created with your control in Builder.\n\n\nThe elementInstance parameter contains all the parameters specified using Builder for the control via its itemSpec member.\n\n\nCreate a custom control in \nP2UXAppBehavior\n subclass like this:\n\n\n@Override\n\n\npublic\n \nView\n \ncreateControl\n(\nString\n \ntype\n,\n \nP2UXElementInstance\n \nelemInstance\n,\n \nRectF\n \nrect\n,\n \nP2UXViewContainerDelegate\n \nviewDelegate\n,\n \nObject\n \nindex\n,\n \nObject\n \ndata\n)\n\n\n{\n\n   \nif\n \n(\ntype\n \n!=\n \nnull\n \n \n!\ntype\n.\nisEmpty\n())\n \n{\n\n       \nif\n \n(\ntype\n.\nequals\n(\ncalendar\n))\n \n{\n\n\n           \n// Below is an example of implementing a calendar using CalendarView\n\n           \nView\n \nctrl\n \n=\n \nnew\n \nCalendarView\n(\nmContext\n);\n\n           \nRelativeLayout\n.\nLayoutParams\n \nparams\n \n=\n \nnew\n \nRelativeLayout\n.\nLayoutParams\n((\nint\n)\nrect\n.\nwidth\n(),\n \n(\nint\n)\nrect\n.\nheight\n());\n\n           \nparams\n.\nleftMargin\n \n=\n \n(\nint\n)\nrect\n.\nleft\n;\n\n           \nparams\n.\ntopMargin\n \n=\n \n(\nint\n)\nrect\n.\ntop\n;\n\n           \nctrl\n.\nsetLayoutParams\n(\nparams\n);\n\n           \n((\nCalendarView\n)\n \nctrl\n).\nsetOnDateChangeListener\n(\nnew\n \nCalendarView\n.\nOnDateChangeListener\n()\n \n{\n\n               \n@Override\n\n               \npublic\n \nvoid\n \nonSelectedDayChange\n(\n@NonNull\n \nCalendarView\n \nview\n,\n \nint\n \nyear\n,\n \nint\n \nmonth\n,\n \nint\n \ndayOfMonth\n)\n \n{\n\n                   \nToast\n.\nmakeText\n(\nmContext\n,\n \nmonth\n+\n1\n \n+\n \n/\n \n+\n \ndayOfMonth\n \n+\n \n/\n \n+\n \nyear\n,\n \nToast\n.\nLENGTH_SHORT\n).\nshow\n();\n\n               \n}\n\n           \n});\n\n           \nreturn\n \nctrl\n;\n\n       \n}\n\n   \n}\n\n   \nreturn\n \nsuper\n.\ncreateControl\n(\ntype\n,\n \nelemInstance\n,\n \nrect\n,\n \nviewDelegate\n,\n \nindex\n,\n \ndata\n);\n\n\n}", 
            "title": "Custom Code"
        }, 
        {
            "location": "/android/customcode/#introduction", 
            "text": "What follows is a detailed tutorial that walks developers through the steps of writing custom code for an Android application using P2UX. Developers should be familiar with the Android Studio integrated development environment for MacOS and the Java programming languages for custom coding.   Topics include customizable View and control behaviors, Screen/Panels, and UI controls.   Terminology  Throughout the P2UX documentation the \u201cdeveloper\u201d refers to you, the reader who is developing an app with P2UX. The \u201cdesigner\u201d refers to the individual whose principal job is to create the appearance and style of the app and its visual components. \u201cPRL\u201d refers to the P2UX Rendering Library for iOS, which controls the creation and workflow of content created for the P2UX platform.    Coding examples and code additions  In the coding examples below and throughout the documentation, changes and additions to be made by the developer are rendered with a blue highlight.   P2UX versus the standard Android Studio environment  P2UX based applications are easy to customize and extend for Android. The P2UX Android rendering library is based on the Android Widget package (android.widget) and other Android primitives. This means that writing custom business logic and integrating custom controls works much the same as it does when writing Android applications using Android Studio.\nWith the P2UX platform, XML Layout files are no longer required for Android development. Instead, applications use P2UX Portable UX Bundles (PUB) either as embedded or dynamically accessed resources. Additionally, P2UX provides hooks to developers that allow them access to all of the components of P2UX as well as the ability to fully customize instances of the application.   Create a P2UX enabled project first  This document assumes a P2UX enabled Android Studio project has already been created. See  Quick Start  for steps to create a project.", 
            "title": "Introduction"
        }, 
        {
            "location": "/android/customcode/#p2ux-and-android-studio", 
            "text": "Java  P2UX native rendering libraries for Android can be extended using the Java programming language. The instructions below provide explicit reference to the proper use of Java coding in each applicable step that follows.", 
            "title": "P2UX and Android Studio"
        }, 
        {
            "location": "/android/customcode/#adding-custom-behaviors", 
            "text": "If desired, customizable behaviors can be added to the project code.  A subclass of the  P2UXAppBehavior  class is the starting point for customizing the behavior of the application. From this class, all other parts of the application can be customized. (Common customized behaviors include creation of a Custom Control or overriding a particular View.)  In Android Studio, create a class to store the customized behaviors. The easiest way to do is by doing a right click on your project package and selecting  New- Java Class . (This example uses the name  SampleBehavior .) In the  Create New Class  dialog, type in  P2UXAppBehavior  in the Superclass field.  This will create  SampleBehavior  class. Put any customized behaviors within the implementation here. Below is a list of available customization methods for  P2UXAppBehavior :     Modifier and Type  Method and Description      P2UXFragment  createViewFragment(int type, Context context, P2UXDefinition def, P2UXFragment.UXFragmentDelegate fragmentDelegate, RectF rect, boolean cache, Object index, Object data, P2UXViewContainerDelegate viewDelegate) Creates a custom fragment    P2UXScreen  createScreen(Context context, P2UXDefinition def, RectF rect, Object index, Object data, P2UXViewContainerDelegate viewDelegate) Creates a custom screen    P2UXPanel  createPanel(Context context, P2UXDefinition def, RectF rect, Object index, Object data, P2UXViewContainerDelegate viewDelegate) Creates a custom panel    View  createControl(String type, P2UXElementInstance elInstance, RectF rect, P2UXViewContainerDelegate viewDelegate, Object index, Object data) Creates a custom control     In addition, update  MainActivity  to include the custom behaviors.  To do this, MainActivity  must override the method  createBehavior . (This will override any default behaviors.) Edit  MainActivity  to look like this:  @Override  public   void   onCreate ( Bundle   savedInstanceState )  { \n    mAppKey   =   xxxxx ;       \n    try   { \n        mResources   =   new   JSONArray (); \n        JSONObject   resource   =   new   JSONObject (); \n        resource . put ( P2UXAppTypes . P2UXApp_PackageAttrib_FormFactor ,   0 ); \n        resource . put ( P2UXAppTypes . P2UXApp_PackageAttrib_Type ,   P2UXAppTypes . P2UXApp_PackageType_Static ); \n        resource . put ( P2UXAppTypes . P2UXApp_PackageAttrib_Package ,   shellui_phone ); \n        resource . put ( P2UXAppTypes . P2UXApp_PackageAttrib_Update ,   P2UXAppTypes . P2UXApp_PackageUpdate_None ); \n        mResources . put ( resource ); \n    } \n    catch   ( JSONException   e ) \n    { \n        P2UXLog . e ( TAG ,   onCreate -    +   e . getMessage ()); \n    } \n\n    if   (( getApplicationInfo (). flags     ApplicationInfo . FLAG_DEBUGGABLE )   ==   ApplicationInfo . FLAG_DEBUGGABLE )   { \n        if   ( savedInstanceState   ==   null )   { \n            savedInstanceState   =   new   Bundle (); \n        } \n        savedInstanceState . putString ( P2UXAppCreator . P2UXAppCreator_Opt_Env ,   P2UXAppCreator . P2UXAppCreator_Opt_Env_Prototype ); \n        savedInstanceState . putLong ( P2UXAppCreator . P2UXAppCreator_Opt_LogLevel ,   P2UXLog . P2UXCoreLogFlagVerbose ); \n    } \n\n    super . onCreate ( savedInstanceState ); \n    applyTranslucentStatusBar ();  }  @Override  public   P2UXAppBehavior   createBehavior ( String   appId )  {      return   new   SampleAppBehavior ();  }", 
            "title": "Adding Custom Behaviors"
        }, 
        {
            "location": "/android/customcode/#adding-custom-fragment", 
            "text": "Developers can override Fragment instances to provide any custom code needed for a fragment lifecycle/behavior and its hosted  View .  The PRL will request an instance from  P2UXAppBehavior  when it needs to create a new fragment. If no instance is provided, P2UX will generate a standard instance of the Fragment.  To provide a custom Fragment instance, override the method  createViewFragment  from a  P2UXAppBehavior  subclass and return an instance of  P2UXFragment .   To handle button click action, override the method  handleButtonClick  from  P2UXAppFragment . To access a control in the fragment, override the method  viewCreated  from  P2UXAppFragment .   The name of a chosen Fragment is the value used to identify the screen when the PRL creates an instance of this object. The \u201cdef\u201d parameter passed to this method contains the member variable  systemType  that identifies the Screen being created. From this object, the developer determines the requested Screen and the specific  P2UXFragment  subclass to instantiate.  Creating a custom Fragment instance in a  P2UXAppBehavior  subclass  @Override  public   P2UXFragment   createViewFragment ( int   type ,   Context   context ,   P2UXDefinition   def ,   P2UXFragment . UXFragmentDelegate   fragmentDelegate ,   RectF   rect ,   boolean   cache ,   Object   index ,   Object   data ,   P2UXViewContainerDelegate   viewDelegate )  { \n    if   ( def . getSystemType (). equals ( xxxxx ))   { \n        //return a fragment here, for example: \n        return   new   SampleFragment ( context ,   def ,   fragmentDelegate ,   rect ,   cache ,   index ,   data ,   viewDelegate ); \n    } \n    return   super . createViewFragment ( type ,   context ,   def ,   fragmentDelegate ,   rect ,   cache ,   index ,   data ,   viewDelegate );  }  @Override  public   void   viewCreated ()  { \n     super . viewCreated (); \n     P2UXButton   btn   =   ( P2UXButton )   controlWithElementSystemTypeOrId ( show_btn ); \n     if   ( btn   !=   null )   { \n        btn . setEnabled ( false ); \n     }  }  @Override  public   boolean   handleButtonClick ( View   ctrl )   { \n     P2UXElementInstance   elementInstance   =   P2UXControlHelper . getElementInstance ( ctrl ); \n     if   ( elInstance   !=   null     elInstance . getSystemType . equals ( button1 )) \n     { \n         String   elId   =   elInstance . getElId (); \n         if   ( elId   !=   null     elId . equals ( button1 ))   { \n            // take some custom action here for the  okbtn \n\n            // return true to indicate the event was handled and propagation \n            // shouldn t continue \n            return   true ; \n         } \n     } \n     return   super . handleButtonClick ( ctrl );  }", 
            "title": "Adding Custom Fragment"
        }, 
        {
            "location": "/android/customcode/#adding-custom-screenspanels", 
            "text": "Developers can override Screen or Panel instances to provide any custom code needed for a hosted  View .  Since the P2UX UI is not based on XML Layout, connecting custom methods for each button click action is unnecessary. Instead, the developer can override the methods of the  P2UXScreen  class to handle button click and other UI events. (In all other respects, writing code for customized Screen and Panel behavior is the same as for XML layout-based content.)  The PRL will request an instance from  P2UXAppBehavior  when it needs to create a new Screen or Panel. If no instance is provided, P2UX will generate a standard instance of the Screen or Panel.  To provide a custom Screen instance, override the method  createScreen  from a  P2UXAppBehavior  subclass and return an instance of  P2UXScreen . To provide a custom Panel instance, override the method  createPanel  and return an instance of  P2UXPanel . (Both  P2UXScreen  and  P2UXPanel  are  View  based subclasses that add some additional helper methods. These methods make it easier to access screen components.)  The name of a chosen Screen or Panel is the value used to identify the item when the PRL creates an instance of this object. The \u201cdef\u201d parameter passed to this method contains the member variable  systemType  that identifies the Screen being created. From this object, the developer determines the requested Screen and the specific  P2UXScreen  or  P2UXPanel  subclass to instantiate.  Creating a custom Screen or Panel instance in a  P2UXAppBehavior  subclass  @Override  public   P2UXScreen   createScreen ( Context   context ,   P2UXDefinition   def ,   RectF   rect ,   Object   index ,   Object   data ,   P2UXViewContainerDelegate   viewDelegate )  { \n    if   ( def . getSystemType (). equals ( xxxxx ))   { \n        //return some screen here, for example: \n        return   new   SampleScreen ( context ,   rect ,   def ,   viewDelegate ,   index ,   data ); \n    } \n    return   super . createScreen ( context ,   def ,   rect ,   index ,   data ,   viewDelegate );  }  @Override  public   P2UXPanel   createPanel ( Context   context ,   P2UXDefinition   def ,   RectF   rect ,   Object   index ,   Object   data ,   P2UXViewContainerDelegate   viewDelegate )  { \n    if   ( def . getSystemType (). equals ( xxxxx ))   { \n        //return some screen here, for example: \n        return   new   SamplePanel ( context ,   rect ,   def ,   viewDelegate ,   index ,   data ); \n    } \n    return   super . createPanel ( context ,   def ,   rect ,   index ,   data ,   viewDelegate );  }", 
            "title": "Adding Custom Screens/Panels"
        }, 
        {
            "location": "/android/customcode/#accessing-control-instances-from-p2uxpanel-or-p2uxscreen", 
            "text": "To access instances of controls,  P2UXScreen  provides a helper method,  controlWithElementSystemTypeOrId . This method takes the name or id of the control to be accessed and returns a control instance.  \u201cSystem type\u201d references  After creating a control, the developer can set a \u201csystem type\u201d for the control in Builder. This effectively becomes the name for the new control. Referring to the control by its \u201csystem type\u201d means that the developer does not need to change any existing custom code when choosing to create an alternate variation of the same control. (Otherwise, if the developer changes the name of the control in Builder, any custom code to referring to the new name would have to be changed as well.)  Accessing a control in a custom instance of  P2UXScreen  looks like this:  @Override  public   void   showView ( boolean   reload )  { \n    super . showView ( reload ); \n    P2UXButton   btn   =   ( P2UXButton )   controlWithElementSystemTypeOrId ( show_btn ); \n    if   ( btn   !=   null )   { \n        btn . setEnabled ( false ); \n    }  }", 
            "title": "Accessing Control instances from P2UXPanel or P2UXScreen"
        }, 
        {
            "location": "/android/customcode/#handling-events-from-p2uxappcontroller", 
            "text": "End-users of a completed app will interact with controls in a Screen or Panel to generate events. These interactions will, in turn, trigger actions. Typically the PRL handles events directly through event interactions set up in Builder. In some cases, additional custom code may be needed to trigger actions not directly supported by P2UX.  The PRL provides a chain of event handlers that propagate an event through different components. Handling events at any point in the propagation chain provides a way to trigger custom code and also (optionally) to stop the propagation of the event at any specific handler.  Event propagation follows a set pattern.  First, events are relayed to the  P2UXScreen  for the current Screen or Panel. Next, they pass to  P2UXAppBehavior . Finally, events are handled by the custom instance of the  View  itself. If none of these components halt event propagation, the PRL will then handle any interactions defined for the event in Builder.  The  P2UXScreen  contains helper methods that handle a variety of events when they occur. These methods give the developer a chance to integrate any custom code needed from the basic event level without triggering any custom actions.  Most standard control events are routed through the  P2UXScreen  instance. Handling these events is a matter of overriding the appropriate event method in your P2UXScreen subclass. Event propagation can be allowed to continue or not depending on the return value from the event handler methods.  The example below illustrates the code that handles a Button press event.  Handling a Button press event in P2UXScreen subclass:  @Override  public   boolean   handleButtonClick ( View   ctrl ,   P2UXElementInstance   elInstance )  { \n    if   ( elInstance   !=   null     elInstance . getSystemType . equals ( button1 )) \n    { \n        String   elId   =   elInstance . getElId (); \n        if   ( elId   !=   null     elId . equals ( button1 ))   { \n            // take some custom action here for the  okbtn \n\n            // return true to indicate the event was handled and propagation \n            // shouldn t continue \n            return   true ; \n        } \n    } \n    return   super . handleButtonClick ( ctrl );  }", 
            "title": "Handling Events from P2UXAppController"
        }, 
        {
            "location": "/android/customcode/#adding-custom-ui-controls", 
            "text": "UI Controls are the visual components of a Screen or Panel created in the Builder tool. These can be interactive, like Buttons or Sliders, or non-interactive, like Shapes or Text. Although P2UX offers many different UI Controls directly creatable and usable in Builder, a specific application may require developer-defined UI controls. Builder provides a Custom Control component that can be added to a Screen or Panel and then replaced using custom code.  Any  View  based control can be injected into your Screens and Panels via a Custom Control. This allows for existing custom controls or third party custom controls to be used with P2UX based applications.  The PRL manages the size and position of any custom controls defined using Builder. To provide an instance of a custom control, override the method createControl in your  P2UXAppBehavior  subclass and return the  View  subclassed instance of your control. The first parameter passed to this method, type, is the name of the control set when you created the custom control in Builder. P2UX will pass the initial size to use with your Custom Control, as well as a few other components that can be used to access any custom information created with your control in Builder.  The elementInstance parameter contains all the parameters specified using Builder for the control via its itemSpec member.  Create a custom control in  P2UXAppBehavior  subclass like this:  @Override  public   View   createControl ( String   type ,   P2UXElementInstance   elemInstance ,   RectF   rect ,   P2UXViewContainerDelegate   viewDelegate ,   Object   index ,   Object   data )  { \n    if   ( type   !=   null     ! type . isEmpty ())   { \n        if   ( type . equals ( calendar ))   { \n\n            // Below is an example of implementing a calendar using CalendarView \n            View   ctrl   =   new   CalendarView ( mContext ); \n            RelativeLayout . LayoutParams   params   =   new   RelativeLayout . LayoutParams (( int ) rect . width (),   ( int ) rect . height ()); \n            params . leftMargin   =   ( int ) rect . left ; \n            params . topMargin   =   ( int ) rect . top ; \n            ctrl . setLayoutParams ( params ); \n            (( CalendarView )   ctrl ). setOnDateChangeListener ( new   CalendarView . OnDateChangeListener ()   { \n                @Override \n                public   void   onSelectedDayChange ( @NonNull   CalendarView   view ,   int   year ,   int   month ,   int   dayOfMonth )   { \n                    Toast . makeText ( mContext ,   month + 1   +   /   +   dayOfMonth   +   /   +   year ,   Toast . LENGTH_SHORT ). show (); \n                } \n            }); \n            return   ctrl ; \n        } \n    } \n    return   super . createControl ( type ,   elemInstance ,   rect ,   viewDelegate ,   index ,   data );  }", 
            "title": "Adding Custom UI Controls"
        }, 
        {
            "location": "/general/applicense/", 
            "text": "Application License\n\n\nAll applications using the \nP2UX Rendering Library (PRL)\n are required to initialize the \nPRL\n with an application license. This license is used to identify the application and authenticate with \nBuilder\n when fetching application bundles. \n\n\nOnline Use\n\n\nThe default method of initializing the \nPRL\n is to provide the application license as a string to the \nP2UXAppCreator\n at startup. When providing the license as a string, the application must contact \nBuilder\n the first time the application is run to authenticate the license and download the details of the license. The license details are stored securely on the device and provide the \nPRL\n the information needed to get an application started. Once the license has been fetched successfully, the PRL does NOT need to authenticate with \nBuilder\n for subsequent launches of the application. It only needs to authenticate once during the installed lifetime of the application.\n\n\nTo retrieve the application license in \nBuilder\n:\n\n\n\n\nFrom the \nPublish\n drop down menu, click the \nGet App License\n menu item.\n\n\n\nA dialog will show with your app\u2019s license. Copy the license.\n\n\n\n\n\n\nCoordinator\n for macOS\n\n\nIf you have created your application with the P2UX \nCoordinator\n application for macOS, this step is not required as the license string is automatically fetched and inserted into your code when the project is created.\n\n\n\n\nOnce the license string is copied, it can be used in the native application code to initialize the \nPRL\n\n\niOS/tvOS\n\n\nObjective-C\n\n\nIn \nAppDelegate.m\n:\n\n\n-\n \n(\nBOOL\n)\napplication:\n(\nUIApplication\n \n*\n)\napplication\n \ndidFinishLaunchingWithOptions:\n(\nNSDictionary\n \n*\n)\nlaunchOptions\n \n{\n\n\n    \n// Include your application license string here\n\n\n    \nNSString\n*\n \nappKey\n \n=\n \n@\n000x.xxxxxxxx\n;\n\n\n    \nNSDictionary\n*\n \nopts\n \n=\n \nnil\n;\n\n\n#ifdef DEBUG\n\n    \nopts\n \n=\n \n@{\nP2UXAppCreator_Opt_Env\n:\n \nP2UXAppCreator_Opt_Env_Stage\n,\n \nP2UXAppCreator_Opt_LogLevel\n:[\nNSNumber\n \nnumberWithInteger\n:\nP2UXCoreLogLevelVerbose\n]\n}\n;\n\n\n#endif\n\n\n    \n[\nP2UXAppCreator\n \ncreateApplicationWithKey\n:\nappKey\n \nopts\n:\nopts\n \nresources\n:\nnil\n \ndelegate\n:\nself\n];\n\n    \nreturn\n \nYES\n;\n\n\n}\n\n\n\n\n\n\nSwift\n\n\nIn \nAppDelegate.swift\n:\n\n\nfunc\n \napplication\n(\n_\n \napplication\n:\n \nUIApplication\n,\n \ndidFinishLaunchingWithOptions\n \nlaunchOptions\n:\n \n[\nUIApplicationLaunchOptionsKey\n:\n \nAny\n]?)\n \n-\n \nBool\n \n{\n\n\n    \n// Include your application license string here  \n\n\n    \nlet\n \nappKey\n \n=\n \n000x.xxxxxxxx\n;\n\n\n\n    \nvar\n \nopts\n \n:\n \n[\nAnyHashable\n \n:\n \nAny\n];\n\n\n#if\n \nDEBUG\n\n    \nopts\n \n=\n \n[\n\n            \nP2UXAppCreator_Opt_Env\n:\n \nP2UXAppCreator_Opt_Env_Stage\n,\n\n            \nP2UXAppCreator_Opt_LogLevel\n:\n \nP2UXCoreLogLevel\n.\nverbose\n.\nrawValue\n \nas\n \nNSNumber\n\n    \n]\n\n\n#endif\n\n\n    \nP2UXAppCreator\n.\ncreateApplication\n(\nwithKey\n:\n \nappKey\n,\n \nopts\n:\n \nopts\n,\n \nresources\n:\n \nnil\n,\n \ndelegate\n:\n \nself\n)\n\n    \nreturn\n \ntrue\n\n\n}\n\n\n\n\n\n\nAndroid\n\n\nIn \nMainActivity.java\n:\n\n\n@Override\n\n\npublic\n \nvoid\n \nonCreate\n(\nBundle\n \nsavedInstanceState\n)\n\n\n{\n\n    \n// Include your application license string here  \n\n\n    \nmAppKey\n \n=\n \n000x.xxxxxxxx\n;\n\n\n\n    \nif\n \n((\ngetApplicationInfo\n().\nflags\n \n \nApplicationInfo\n.\nFLAG_DEBUGGABLE\n)\n \n==\n \nApplicationInfo\n.\nFLAG_DEBUGGABLE\n)\n\n    \n{\n\n        \nif\n \n(\nsavedInstanceState\n \n==\n \nnull\n)\n\n        \n{\n\n            \nsavedInstanceState\n \n=\n \nnew\n \nBundle\n();\n\n        \n}\n\n        \nsavedInstanceState\n.\nputString\n(\nP2UXAppCreator\n.\nP2UXAppCreator_Opt_Env\n,\n \nP2UXAppCreator\n.\nP2UXAppCreator_Opt_Env_Stage\n);\n\n        \nsavedInstanceState\n.\nputLong\n(\nP2UXAppCreator\n.\nP2UXAppCreator_Opt_LogLevel\n,\n \nP2UXLog\n.\nP2UXCoreLogFlagVerbose\n);\n\n    \n}\n\n    \nsuper\n.\nonCreate\n(\nsavedInstanceState\n);\n\n    \napplyTranslucentStatusBar\n();\n\n\n}\n\n\n\n\n\n\nOffline Use\n\n\nFor the case where the developer does not want to require network connectivity on the first run of the application, the application license can be downloaded from \nBuilder\n and embedded into the native application bundle. Once the file is downloaded, it can be added to your project. The \nPRL\n will look for a license file within your application before it attempts to download the license from \nBuilder\n.\n\n\nTo download the application license file from \nBuilder\n:\n\n\n\n\nFrom the \nPublish\n drop down menu, click the \nGet App License\n menu item.\n\n\n\nA dialog will show with your app\u2019s license. From the dialog click the \nDownload\n button.\n\n\nBuilder\n will download a file named \nP2UXLicense.json\n to your computer. \n\n\n\n\n\n\nImportant\n\n\nIf for some reason your browser gives the downloaded license file a different name than \nP2UXLicense.json\n, the file will need to be renamed \nP2UXLicense.json\n before using it \n(the name IS case sensitive)\n. The \nPRL\n will look for a file with this name in the application resources on startup.\n\n\n\n\niOS/tvOS\n\n\n\n\nCopy the \nP2UXLicense.json\n into your project directory.\n\n\nIn Xcode, right click on the project folder and select \nAdd Files to '\n(project name)\n'\n\n\nSelect the \nP2UXLicense.json\n from the file system directory it was copied to.\n\n\n\n\nAndroid\n\n\n\n\nCreate a file system directory named \nassets\n in your project inside the project subdirectory \napp/src/main\n (if it doesn't already exist)\n\n\nCopy the \nP2UXLicense.json\n file into the \nassets\n directory.\n\n\n\n\nErrors with the License\n\n\nIf the license fails to authenticate, the PRL will display an error message at startup. This error message screen can be customized by the developer in native code (See Customizing Error Screens).\n\n\n\n\nPossible Errors:\n\n\n\n\n\n\n\n\nMessage\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nInvalid application license\n\n\nThe provided license string is not valid. Check the value with the license string provided by \nBuilder\n\n\n\n\n\n\nUnable to retrieve license\n\n\nThe \nPRL\n is unable to contact \nBuilder\n to validate the license. Check the connectivity of the device", 
            "title": "Application License"
        }, 
        {
            "location": "/general/applicense/#application-license", 
            "text": "All applications using the  P2UX Rendering Library (PRL)  are required to initialize the  PRL  with an application license. This license is used to identify the application and authenticate with  Builder  when fetching application bundles.", 
            "title": "Application License"
        }, 
        {
            "location": "/general/applicense/#online-use", 
            "text": "The default method of initializing the  PRL  is to provide the application license as a string to the  P2UXAppCreator  at startup. When providing the license as a string, the application must contact  Builder  the first time the application is run to authenticate the license and download the details of the license. The license details are stored securely on the device and provide the  PRL  the information needed to get an application started. Once the license has been fetched successfully, the PRL does NOT need to authenticate with  Builder  for subsequent launches of the application. It only needs to authenticate once during the installed lifetime of the application.  To retrieve the application license in  Builder :   From the  Publish  drop down menu, click the  Get App License  menu item.  A dialog will show with your app\u2019s license. Copy the license.    Coordinator  for macOS  If you have created your application with the P2UX  Coordinator  application for macOS, this step is not required as the license string is automatically fetched and inserted into your code when the project is created.   Once the license string is copied, it can be used in the native application code to initialize the  PRL", 
            "title": "Online Use"
        }, 
        {
            "location": "/general/applicense/#iostvos", 
            "text": "", 
            "title": "iOS/tvOS"
        }, 
        {
            "location": "/general/applicense/#objective-c", 
            "text": "In  AppDelegate.m :  -   ( BOOL ) application: ( UIApplication   * ) application   didFinishLaunchingWithOptions: ( NSDictionary   * ) launchOptions   { \n\n     // Include your application license string here       NSString *   appKey   =   @ 000x.xxxxxxxx ;       NSDictionary *   opts   =   nil ;  #ifdef DEBUG \n     opts   =   @{ P2UXAppCreator_Opt_Env :   P2UXAppCreator_Opt_Env_Stage ,   P2UXAppCreator_Opt_LogLevel :[ NSNumber   numberWithInteger : P2UXCoreLogLevelVerbose ] } ;  #endif \n\n     [ P2UXAppCreator   createApplicationWithKey : appKey   opts : opts   resources : nil   delegate : self ]; \n     return   YES ;  }", 
            "title": "Objective-C"
        }, 
        {
            "location": "/general/applicense/#swift", 
            "text": "In  AppDelegate.swift :  func   application ( _   application :   UIApplication ,   didFinishLaunchingWithOptions   launchOptions :   [ UIApplicationLaunchOptionsKey :   Any ]?)   -   Bool   { \n\n     // Include your application license string here         let   appKey   =   000x.xxxxxxxx ;  \n     var   opts   :   [ AnyHashable   :   Any ];  #if   DEBUG \n     opts   =   [ \n             P2UXAppCreator_Opt_Env :   P2UXAppCreator_Opt_Env_Stage , \n             P2UXAppCreator_Opt_LogLevel :   P2UXCoreLogLevel . verbose . rawValue   as   NSNumber \n     ]  #endif \n\n     P2UXAppCreator . createApplication ( withKey :   appKey ,   opts :   opts ,   resources :   nil ,   delegate :   self ) \n     return   true  }", 
            "title": "Swift"
        }, 
        {
            "location": "/general/applicense/#android", 
            "text": "In  MainActivity.java :  @Override  public   void   onCreate ( Bundle   savedInstanceState )  { \n     // Include your application license string here         mAppKey   =   000x.xxxxxxxx ;  \n     if   (( getApplicationInfo (). flags     ApplicationInfo . FLAG_DEBUGGABLE )   ==   ApplicationInfo . FLAG_DEBUGGABLE ) \n     { \n         if   ( savedInstanceState   ==   null ) \n         { \n             savedInstanceState   =   new   Bundle (); \n         } \n         savedInstanceState . putString ( P2UXAppCreator . P2UXAppCreator_Opt_Env ,   P2UXAppCreator . P2UXAppCreator_Opt_Env_Stage ); \n         savedInstanceState . putLong ( P2UXAppCreator . P2UXAppCreator_Opt_LogLevel ,   P2UXLog . P2UXCoreLogFlagVerbose ); \n     } \n     super . onCreate ( savedInstanceState ); \n     applyTranslucentStatusBar ();  }", 
            "title": "Android"
        }, 
        {
            "location": "/general/applicense/#offline-use", 
            "text": "For the case where the developer does not want to require network connectivity on the first run of the application, the application license can be downloaded from  Builder  and embedded into the native application bundle. Once the file is downloaded, it can be added to your project. The  PRL  will look for a license file within your application before it attempts to download the license from  Builder .  To download the application license file from  Builder :   From the  Publish  drop down menu, click the  Get App License  menu item.  A dialog will show with your app\u2019s license. From the dialog click the  Download  button.  Builder  will download a file named  P2UXLicense.json  to your computer.     Important  If for some reason your browser gives the downloaded license file a different name than  P2UXLicense.json , the file will need to be renamed  P2UXLicense.json  before using it  (the name IS case sensitive) . The  PRL  will look for a file with this name in the application resources on startup.", 
            "title": "Offline Use"
        }, 
        {
            "location": "/general/applicense/#iostvos_1", 
            "text": "Copy the  P2UXLicense.json  into your project directory.  In Xcode, right click on the project folder and select  Add Files to ' (project name) '  Select the  P2UXLicense.json  from the file system directory it was copied to.", 
            "title": "iOS/tvOS"
        }, 
        {
            "location": "/general/applicense/#android_1", 
            "text": "Create a file system directory named  assets  in your project inside the project subdirectory  app/src/main  (if it doesn't already exist)  Copy the  P2UXLicense.json  file into the  assets  directory.", 
            "title": "Android"
        }, 
        {
            "location": "/general/applicense/#errors-with-the-license", 
            "text": "If the license fails to authenticate, the PRL will display an error message at startup. This error message screen can be customized by the developer in native code (See Customizing Error Screens).   Possible Errors:     Message  Description      Invalid application license  The provided license string is not valid. Check the value with the license string provided by  Builder    Unable to retrieve license  The  PRL  is unable to contact  Builder  to validate the license. Check the connectivity of the device", 
            "title": "Errors with the License"
        }, 
        {
            "location": "/general/envandpublish/", 
            "text": "Application Environments\n\n\n\n\nPublishing applications on the P2UX Platform allows for use in different environments to support prototype testing, staged testing for release to live applications, and deployment of the application content to production native apps. Each environment can be targeted by the native application based on the creation and initialization of the app in native code. The use of these different environments is not enforced by the P2UX rendering libraries (PRL) on the different platforms which allows the developer to decide how they are used.\n\n\nWhen using application bundles as dynamic resources, P2UX based native applications will check for updates to the application bundle on startup of the app.\n\n\nEnvironments\n\n\nThere are three environments for applications to make use of: \nPrototype, Stage, Deployed\n. Applications are promoted from one stage to another via the \nBuilder\n application. Native applications can toggle the environment used programmatically so that the application can be tested using the different environments prior to release to production.\n\n\nPrototype\n\n\nWhen an application is Published via the \nPublish\n menu in \nBuilder\n, the application contents are compressed and bundled into packages for use on the specified platforms and form factors. These published versions of the application are \nPrototypes\n of the application. The primary use of \nPrototypes\n is to try out UI variations, workflow, and even custom code. \n\n\n\n\nPrivate and Public Publishing\n\n\nBuilder\n provides the option to publicly or privately publish prototypes. A private publish of the Prototype is only available to the user that Published the application and will only be usable by the \nP2UX Player\n for Android and iOS/tvOS. A public publish of the application will be available in the \nP2UX Player\n to any user in the same group as the user that published the application as well as being available for use in native application instances.\n\n\n\n\nTo use a \nPrototype\n in a native application, the developer needs to setup the \nPRL\n environment to refer to recent publishes. \n\n\nThe environment value to use for Prototypes is: \nP2UXAppCreator_Opt_Env_Recent\n\n\nThis setting will fetch the most recent \nPublic\n version of the Application bundle regardless of whether it is in the \nPrototype\n, \nStaged\n, or \nProduction\n environments. Every time the application is published publicly, it becomes the most recent version and is available to developer builds of the application.\n\n\n\n\nPrototypes aren't meant for Release!\n\n\nUsing a \nPrototype\n bundle with dynamic updates in a native application is supported by P2UX, but NOT recommended for applications released to the public. It is meant for developer builds to try out features quickly and test custom code. Be aware that every time a public pubish is performed on the application, the native application will pick up the changes when it restarts which means every change made to the application and published as a public \nPrototype\n would be pushed to your users! \n\n\n\n\nThe following code examples set the environment to \nP2UXAppCreator_Opt_Env_Recent\n for developer testing and debugging purposes.\n\n\niOS/tvOS\n\n\nIn Objective-C, edit \nAppDelegate.m\n:\n\n\n#import \nAppDelegate.h\n\n\n@interface\n \nAppDelegate\n \n()\n\n\n@end\n\n\n@implementation\n \nAppDelegate\n\n\n-\n \n(\nBOOL\n)\napplication:\n(\nUIApplication\n \n*\n)\napplication\n \ndidFinishLaunchingWithOptions:\n(\nNSDictionary\n \n*\n)\nlaunchOptions\n \n{\n\n    \nNSString\n*\n \nappKey\n;\n\n    \nappKey\n \n=\n \n@\nxxxxx\n;\n\n    \nNSDictionary\n \n*\nopts\n;\n\n\n#if DEBUG\n\n\n    \nopts\n \n=\n \n@{\nP2UXAppCreator_Opt_Env\n:\n \nP2UXAppCreator_Opt_Env_Recent\n}\n;\n\n\n#endif    \n\n\n    \n[\nP2UXAppCreator\n \ncreateApplicationWithKey\n:\nappKey\n \nopts\n:\nopts\n \nresources\n:\nresources\n \ndelegate\n:\nself\n];\n\n    \nreturn\n \nYES\n;\n\n\n}\n\n\n\n\n\n\nIn Swift, edit \nAppDelegate.swift\n:\n\n\nimport\n \nUIKit\n\n\nimport\n \nP2UXApp\n\n\n\n@UIApplicationMain\n\n\nclass\n \nAppDelegate\n:\n \nUIResponder\n,\n \nUIApplicationDelegate\n,\n \nP2UXAppCreatorDelegate\n \n{\n\n    \nvar\n \nwindow\n:\n \nUIWindow\n?\n\n    \nfunc\n \napplication\n(\n_\n \napplication\n:\n \nUIApplication\n,\n \ndidFinishLaunchingWithOptions\n \nlaunchOptions\n:\n \n[\nUIApplicationLaunchOptionsKey\n:\n \nAny\n]?)\n \n-\n \nBool\n \n{\n\n        \nlet\n \nappKey\n \n=\n \nxxxxx\n;\n\n        \nvar\n \nopts\n \n:\n \n[\nAnyHashable\n \n:\n \nAny\n];\n\n\n#if\n \nDEBUG\n\n        \nopts\n \n=\n \n[\n\n\n            \nP2UXAppCreator_Opt_Env\n:\n \nP2UXAppCreator_Opt_Env_Recent\n,\n\n\n        \n]\n\n\n#endif\n\n        \nP2UXAppCreator\n.\ncreateApplication\n(\nwithKey\n:\n \nappKey\n,\n \nopts\n:\n \nopts\n,\n\n            \nresources\n:\n \nresources\n,\n \ndelegate\n:\n \nself\n)\n\n    \n}\n\n    \nfunc\n \ncreateBehavior\n(\nforApplication\n \nappid\n:\n \nString\n)\n \n-\n \nP2UXAppBehavior\n \n{\n\n        \nreturn\n \nSampleBehavior\n();\n\n    \n}\n\n\n}\n\n\n\n\n\n\nAndroid\n\n\nEdit \nMainActivity.java\n:\n\n\n@Override\n\n\npublic\n \nvoid\n \nonCreate\n(\nBundle\n \nsavedInstanceState\n)\n\n\n{\n\n   \nmAppKey\n \n=\n \nxxxxx\n;\n      \n   \nif\n \n((\ngetApplicationInfo\n().\nflags\n \n \nApplicationInfo\n.\nFLAG_DEBUGGABLE\n)\n \n==\n \nApplicationInfo\n.\nFLAG_DEBUGGABLE\n)\n \n{\n\n       \nif\n \n(\nsavedInstanceState\n \n==\n \nnull\n)\n \n{\n\n           \nsavedInstanceState\n \n=\n \nnew\n \nBundle\n();\n\n       \n}\n\n\n       \nsavedInstanceState\n.\nputString\n(\nP2UXAppCreator\n.\nP2UXAppCreator_Opt_Env\n,\n \nP2UXAppCreator\n.\nP2UXAppCreator_Opt_Env_Recent\n);\n\n\n   \n}\n\n\n   \nsuper\n.\nonCreate\n(\nsavedInstanceState\n);\n\n\n}\n\n\n\n\n\n\nStage\n\n\nThe \nStage\n environment is intended for testing an application prior to its release to production. Once application content is staged, it will NOT pick up any changes from subsequent publishes of the application as a \nPrototype\n. Staged application content will also NOT be delivered to native applications using \nProduction\n content.\n\n\nTo make application content available to the \nStage\n environment in \nBuilder\n:\n\n\n\n\n\n\nClick the \nPublish\n menu dropdown and select \nMake it real\n from the menu.\n\n\n\n\n\n\n\nMake sure you are in the \nPrototypes\n tab at the top of the \nMake it Real\n dialog\n\n\n\n\n\n\n\nClick the \nStage App\n button next to the Prototype application bundle. \n\n\n\n\n\n\n\nClick \nOK\n from the \nStage App Confirmation\n to finish the staging.\n\n\n\n\n\n\n\nTo use \nStage\n content in a native application, the developer needs to setup the \nPRL\n environment to refer to staged content. \n\n\nThe environment value to use for Prototypes is: \nP2UXAppCreator_Opt_Env_Stage\n\n\nThis setting will fetch the staged version of the Application bundle when the application starts if it doesn't already have the most recent version of the bundle. \n\n\n\n\nStaged content is for testing\n\n\nUsing a \nStaged\n bundle with dynamic updates in a native application is not recommended for applications released to the public. It is meant for testing an application's content changes prior to release.\n\n\n\n\nThe following code examples set the environment to \nP2UXAppCreator_Opt_Env_Stage\n for developer testing and debugging purposes.\n\n\niOS/tvOS\n\n\nIn Objective-C, edit \nAppDelegate.m\n:\n\n\n#import \nAppDelegate.h\n\n\n@interface\n \nAppDelegate\n \n()\n\n\n@end\n\n\n@implementation\n \nAppDelegate\n\n\n-\n \n(\nBOOL\n)\napplication:\n(\nUIApplication\n \n*\n)\napplication\n \ndidFinishLaunchingWithOptions:\n(\nNSDictionary\n \n*\n)\nlaunchOptions\n \n{\n\n    \nNSString\n*\n \nappKey\n;\n\n    \nappKey\n \n=\n \n@\nxxxxx\n;\n\n    \nNSDictionary\n \n*\nopts\n;\n\n\n#if DEBUG\n\n\n    \nopts\n \n=\n \n@{\nP2UXAppCreator_Opt_Env\n:\n \nP2UXAppCreator_Opt_Env_Stage\n}\n;\n\n\n#endif    \n\n\n    \n[\nP2UXAppCreator\n \ncreateApplicationWithKey\n:\nappKey\n \nopts\n:\nopts\n \nresources\n:\nresources\n \ndelegate\n:\nself\n];\n\n    \nreturn\n \nYES\n;\n\n\n}\n\n\n\n\n\n\nIn Swift, edit \nAppDelegate.swift\n:\n\n\nimport\n \nUIKit\n\n\nimport\n \nP2UXApp\n\n\n\n@UIApplicationMain\n\n\nclass\n \nAppDelegate\n:\n \nUIResponder\n,\n \nUIApplicationDelegate\n,\n \nP2UXAppCreatorDelegate\n \n{\n\n    \nvar\n \nwindow\n:\n \nUIWindow\n?\n\n    \nfunc\n \napplication\n(\n_\n \napplication\n:\n \nUIApplication\n,\n \ndidFinishLaunchingWithOptions\n \nlaunchOptions\n:\n \n[\nUIApplicationLaunchOptionsKey\n:\n \nAny\n]?)\n \n-\n \nBool\n \n{\n\n        \nlet\n \nappKey\n \n=\n \nxxxxx\n;\n\n        \nvar\n \nopts\n \n:\n \n[\nAnyHashable\n \n:\n \nAny\n];\n\n\n#if\n \nDEBUG\n\n        \nopts\n \n=\n \n[\n\n\n            \nP2UXAppCreator_Opt_Env\n:\n \nP2UXAppCreator_Opt_Env_Stage\n,\n\n\n        \n]\n\n\n#endif\n\n        \nP2UXAppCreator\n.\ncreateApplication\n(\nwithKey\n:\n \nappKey\n,\n \nopts\n:\n \nopts\n,\n\n            \nresources\n:\n \nresources\n,\n \ndelegate\n:\n \nself\n)\n\n    \n}\n\n    \nfunc\n \ncreateBehavior\n(\nforApplication\n \nappid\n:\n \nString\n)\n \n-\n \nP2UXAppBehavior\n \n{\n\n        \nreturn\n \nSampleBehavior\n();\n\n    \n}\n\n\n}\n\n\n\n\n\n\nAndroid\n\n\nEdit \nMainActivity.java\n:\n\n\n@Override\n\n\npublic\n \nvoid\n \nonCreate\n(\nBundle\n \nsavedInstanceState\n)\n\n\n{\n\n   \nmAppKey\n \n=\n \nxxxxx\n;\n      \n   \nif\n \n((\ngetApplicationInfo\n().\nflags\n \n \nApplicationInfo\n.\nFLAG_DEBUGGABLE\n)\n \n==\n \nApplicationInfo\n.\nFLAG_DEBUGGABLE\n)\n \n{\n\n       \nif\n \n(\nsavedInstanceState\n \n==\n \nnull\n)\n \n{\n\n           \nsavedInstanceState\n \n=\n \nnew\n \nBundle\n();\n\n       \n}\n\n\n       \nsavedInstanceState\n.\nputString\n(\nP2UXAppCreator\n.\nP2UXAppCreator_Opt_Env\n,\n \nP2UXAppCreator\n.\nP2UXAppCreator_Opt_Env_Stage\n);\n\n\n   \n}\n\n\n   \nsuper\n.\nonCreate\n(\nsavedInstanceState\n);\n\n\n}\n\n\n\n\n\n\nProduction (Deployed)\n\n\nThe \nProduction\n environment is intended for use in the released production application. This is the default setting for the PRL when no specific environment setting is provided. Application content can only be moved into \nProduction\n after first being moved to the \nStage\n environment. Once application content is deployed to production, it will NOT pick up any changes from subsequent publishes of the application as a \nPrototype\n or from content moved into the \nStage\n environment. \n\n\nTo make application content available to the \nProduction\n environment in \nBuilder\n:\n\n\n\n\n\n\nClick the \nPublish\n menu dropdown and select \nMake it real\n from the menu.\n\n\n\n\n\n\n\nClick on the \nApps\n tab at the top of the \nMake it Real\n dialog\n\n\n\n\n\n\n\nClick the \nDeploy\n button next to the Staged application bundle. \n\n\n\n\n\n\nTo use \nProduction\n content in a native application, the developer needs to setup the PRL environment to refer to deployed content. \n\n\nThe environment value to use for Prototypes is: \nP2UXAppCreator_Opt_Env_Production\n\n\nThis setting will fetch the deployed version of the Application bundle when the application starts if it doesn't have the most recent deployed version of the bundle. \n\n\nTo set the PRL to the \nProduction\n environment, either omit the \nP2UXAppCreator_Opt_Env\n value from the options at startup or explicitly set it to \nP2UXAppCreator_Opt_Env_Production\n. The previous code examples would work as is for using the \nProduction\n environment for released applications as the other environment alternatives are only set when debugging the application.\n\n\nLast Updated: Nov. 21, 2017", 
            "title": "Application Environments"
        }, 
        {
            "location": "/general/envandpublish/#application-environments", 
            "text": "Publishing applications on the P2UX Platform allows for use in different environments to support prototype testing, staged testing for release to live applications, and deployment of the application content to production native apps. Each environment can be targeted by the native application based on the creation and initialization of the app in native code. The use of these different environments is not enforced by the P2UX rendering libraries (PRL) on the different platforms which allows the developer to decide how they are used.  When using application bundles as dynamic resources, P2UX based native applications will check for updates to the application bundle on startup of the app.", 
            "title": "Application Environments"
        }, 
        {
            "location": "/general/envandpublish/#environments", 
            "text": "There are three environments for applications to make use of:  Prototype, Stage, Deployed . Applications are promoted from one stage to another via the  Builder  application. Native applications can toggle the environment used programmatically so that the application can be tested using the different environments prior to release to production.", 
            "title": "Environments"
        }, 
        {
            "location": "/general/envandpublish/#prototype", 
            "text": "When an application is Published via the  Publish  menu in  Builder , the application contents are compressed and bundled into packages for use on the specified platforms and form factors. These published versions of the application are  Prototypes  of the application. The primary use of  Prototypes  is to try out UI variations, workflow, and even custom code.    Private and Public Publishing  Builder  provides the option to publicly or privately publish prototypes. A private publish of the Prototype is only available to the user that Published the application and will only be usable by the  P2UX Player  for Android and iOS/tvOS. A public publish of the application will be available in the  P2UX Player  to any user in the same group as the user that published the application as well as being available for use in native application instances.   To use a  Prototype  in a native application, the developer needs to setup the  PRL  environment to refer to recent publishes.   The environment value to use for Prototypes is:  P2UXAppCreator_Opt_Env_Recent  This setting will fetch the most recent  Public  version of the Application bundle regardless of whether it is in the  Prototype ,  Staged , or  Production  environments. Every time the application is published publicly, it becomes the most recent version and is available to developer builds of the application.   Prototypes aren't meant for Release!  Using a  Prototype  bundle with dynamic updates in a native application is supported by P2UX, but NOT recommended for applications released to the public. It is meant for developer builds to try out features quickly and test custom code. Be aware that every time a public pubish is performed on the application, the native application will pick up the changes when it restarts which means every change made to the application and published as a public  Prototype  would be pushed to your users!    The following code examples set the environment to  P2UXAppCreator_Opt_Env_Recent  for developer testing and debugging purposes.", 
            "title": "Prototype"
        }, 
        {
            "location": "/general/envandpublish/#iostvos", 
            "text": "In Objective-C, edit  AppDelegate.m :  #import  AppDelegate.h  @interface   AppDelegate   ()  @end  @implementation   AppDelegate  -   ( BOOL ) application: ( UIApplication   * ) application   didFinishLaunchingWithOptions: ( NSDictionary   * ) launchOptions   { \n     NSString *   appKey ; \n     appKey   =   @ xxxxx ; \n     NSDictionary   * opts ;  #if DEBUG       opts   =   @{ P2UXAppCreator_Opt_Env :   P2UXAppCreator_Opt_Env_Recent } ;  #endif     \n\n     [ P2UXAppCreator   createApplicationWithKey : appKey   opts : opts   resources : resources   delegate : self ]; \n     return   YES ;  }   In Swift, edit  AppDelegate.swift :  import   UIKit  import   P2UXApp  @UIApplicationMain  class   AppDelegate :   UIResponder ,   UIApplicationDelegate ,   P2UXAppCreatorDelegate   { \n     var   window :   UIWindow ? \n     func   application ( _   application :   UIApplication ,   didFinishLaunchingWithOptions   launchOptions :   [ UIApplicationLaunchOptionsKey :   Any ]?)   -   Bool   { \n         let   appKey   =   xxxxx ; \n         var   opts   :   [ AnyHashable   :   Any ];  #if   DEBUG \n         opts   =   [               P2UXAppCreator_Opt_Env :   P2UXAppCreator_Opt_Env_Recent ,           ]  #endif \n         P2UXAppCreator . createApplication ( withKey :   appKey ,   opts :   opts , \n             resources :   resources ,   delegate :   self ) \n     } \n     func   createBehavior ( forApplication   appid :   String )   -   P2UXAppBehavior   { \n         return   SampleBehavior (); \n     }  }", 
            "title": "iOS/tvOS"
        }, 
        {
            "location": "/general/envandpublish/#android", 
            "text": "Edit  MainActivity.java :  @Override  public   void   onCreate ( Bundle   savedInstanceState )  { \n    mAppKey   =   xxxxx ;       \n    if   (( getApplicationInfo (). flags     ApplicationInfo . FLAG_DEBUGGABLE )   ==   ApplicationInfo . FLAG_DEBUGGABLE )   { \n        if   ( savedInstanceState   ==   null )   { \n            savedInstanceState   =   new   Bundle (); \n        }          savedInstanceState . putString ( P2UXAppCreator . P2UXAppCreator_Opt_Env ,   P2UXAppCreator . P2UXAppCreator_Opt_Env_Recent );      } \n\n    super . onCreate ( savedInstanceState );  }", 
            "title": "Android"
        }, 
        {
            "location": "/general/envandpublish/#stage", 
            "text": "The  Stage  environment is intended for testing an application prior to its release to production. Once application content is staged, it will NOT pick up any changes from subsequent publishes of the application as a  Prototype . Staged application content will also NOT be delivered to native applications using  Production  content.  To make application content available to the  Stage  environment in  Builder :    Click the  Publish  menu dropdown and select  Make it real  from the menu.    Make sure you are in the  Prototypes  tab at the top of the  Make it Real  dialog    Click the  Stage App  button next to the Prototype application bundle.     Click  OK  from the  Stage App Confirmation  to finish the staging.    To use  Stage  content in a native application, the developer needs to setup the  PRL  environment to refer to staged content.   The environment value to use for Prototypes is:  P2UXAppCreator_Opt_Env_Stage  This setting will fetch the staged version of the Application bundle when the application starts if it doesn't already have the most recent version of the bundle.    Staged content is for testing  Using a  Staged  bundle with dynamic updates in a native application is not recommended for applications released to the public. It is meant for testing an application's content changes prior to release.   The following code examples set the environment to  P2UXAppCreator_Opt_Env_Stage  for developer testing and debugging purposes.", 
            "title": "Stage"
        }, 
        {
            "location": "/general/envandpublish/#iostvos_1", 
            "text": "In Objective-C, edit  AppDelegate.m :  #import  AppDelegate.h  @interface   AppDelegate   ()  @end  @implementation   AppDelegate  -   ( BOOL ) application: ( UIApplication   * ) application   didFinishLaunchingWithOptions: ( NSDictionary   * ) launchOptions   { \n     NSString *   appKey ; \n     appKey   =   @ xxxxx ; \n     NSDictionary   * opts ;  #if DEBUG       opts   =   @{ P2UXAppCreator_Opt_Env :   P2UXAppCreator_Opt_Env_Stage } ;  #endif     \n\n     [ P2UXAppCreator   createApplicationWithKey : appKey   opts : opts   resources : resources   delegate : self ]; \n     return   YES ;  }   In Swift, edit  AppDelegate.swift :  import   UIKit  import   P2UXApp  @UIApplicationMain  class   AppDelegate :   UIResponder ,   UIApplicationDelegate ,   P2UXAppCreatorDelegate   { \n     var   window :   UIWindow ? \n     func   application ( _   application :   UIApplication ,   didFinishLaunchingWithOptions   launchOptions :   [ UIApplicationLaunchOptionsKey :   Any ]?)   -   Bool   { \n         let   appKey   =   xxxxx ; \n         var   opts   :   [ AnyHashable   :   Any ];  #if   DEBUG \n         opts   =   [               P2UXAppCreator_Opt_Env :   P2UXAppCreator_Opt_Env_Stage ,           ]  #endif \n         P2UXAppCreator . createApplication ( withKey :   appKey ,   opts :   opts , \n             resources :   resources ,   delegate :   self ) \n     } \n     func   createBehavior ( forApplication   appid :   String )   -   P2UXAppBehavior   { \n         return   SampleBehavior (); \n     }  }", 
            "title": "iOS/tvOS"
        }, 
        {
            "location": "/general/envandpublish/#android_1", 
            "text": "Edit  MainActivity.java :  @Override  public   void   onCreate ( Bundle   savedInstanceState )  { \n    mAppKey   =   xxxxx ;       \n    if   (( getApplicationInfo (). flags     ApplicationInfo . FLAG_DEBUGGABLE )   ==   ApplicationInfo . FLAG_DEBUGGABLE )   { \n        if   ( savedInstanceState   ==   null )   { \n            savedInstanceState   =   new   Bundle (); \n        }          savedInstanceState . putString ( P2UXAppCreator . P2UXAppCreator_Opt_Env ,   P2UXAppCreator . P2UXAppCreator_Opt_Env_Stage );      } \n\n    super . onCreate ( savedInstanceState );  }", 
            "title": "Android"
        }, 
        {
            "location": "/general/envandpublish/#production-deployed", 
            "text": "The  Production  environment is intended for use in the released production application. This is the default setting for the PRL when no specific environment setting is provided. Application content can only be moved into  Production  after first being moved to the  Stage  environment. Once application content is deployed to production, it will NOT pick up any changes from subsequent publishes of the application as a  Prototype  or from content moved into the  Stage  environment.   To make application content available to the  Production  environment in  Builder :    Click the  Publish  menu dropdown and select  Make it real  from the menu.    Click on the  Apps  tab at the top of the  Make it Real  dialog    Click the  Deploy  button next to the Staged application bundle.     To use  Production  content in a native application, the developer needs to setup the PRL environment to refer to deployed content.   The environment value to use for Prototypes is:  P2UXAppCreator_Opt_Env_Production  This setting will fetch the deployed version of the Application bundle when the application starts if it doesn't have the most recent deployed version of the bundle.   To set the PRL to the  Production  environment, either omit the  P2UXAppCreator_Opt_Env  value from the options at startup or explicitly set it to  P2UXAppCreator_Opt_Env_Production . The previous code examples would work as is for using the  Production  environment for released applications as the other environment alternatives are only set when debugging the application.  Last Updated: Nov. 21, 2017", 
            "title": "Production (Deployed)"
        }, 
        {
            "location": "/general/appbundleupdates/", 
            "text": "Application Bundle Updates\n\n\n\n\nOne of the benefits of using P2UX application bundles is its ability to update the application content without having to update the native application binary. Application bundles used by native applications can be updated in a few different ways.\n\n\nAuto Update\n\n\nThe default update policy for P2UX applications is \nAuto Update\n. Each time the application is restarted by the user, the \nPRL\n will compare the version of the application bundle it has against the version for the specified environment on \nBuilder\n. \n\n\n\n\nApplication Environments\n\n\nApplication Environments are used to separate content into different different testing/usage environments. See \nApplication Environments\n for details on use of different environments.\n\n\n\n\nIf a new version of the application bundle is found, the \nPRL\n will prompt the user to let them know there is a new version of the application available. Clicking the OK button from that dialog will restart the application workflow with the new content downloaded from \nBuilder\n. The default prompt is a native dialog for the platform.\n\n\nManual Update\n\n\nOne option for updating application content is to create a manual action triggered by the user or by some other event. Using the \nManual\n update policy, the \nPRL\n will never check for updates, but can do when requested by a \nCheck for Updates\n action in the content. This gives the developer control as to when an update check will happen.\n\n\nIf a new version of the application bundle is found, the \nPRL\n will prompt the user to let them know there is a new version of the application available. Clicking the OK button from that dialog will restart the application workflow with the new content downloaded from \nBuilder\n. The default prompt is a native dialog for the platform.\n\n\nNo Update\n\n\nIf the application content will never be updated dynamically, the developer can opt to tell the \nPRL\n to never allow for updates. The only way to update the content is to use \nStatic\n application content bundles that are built into the native application binaries. (See \nStatic Application Bundle\n) In this mode, any requests to check for updates are ignored by the \nPRL\n. \n\n\nSpecifying Resources\n\n\nIts the responsibility of the application developer to let the \nPRL\n know how the application bundle resources should be used. On startup the application should create an array of objects (one object for each form factor) that define how the resources for the form factor should be used. \n\n\nForm factors are indicated by a numeric value:\n\n\n\n\n\n\n\n\nValue\n\n\nForm Factor\n\n\n\n\n\n\n\n\n\n\n0\n\n\nPhone\n\n\n\n\n\n\n1\n\n\nTablet\n\n\n\n\n\n\n4\n\n\nTV\n\n\n\n\n\n\n\n\nBelow is an example of an application that uses \nNone\n as the update policy for the \nPhone\n form factor. It will never check for updates.\n\n\niOS/tvOS\n\n\nObjective-C\n\n\nIn \nAppDelegate.m\n:\n\n\n-\n \n(\nBOOL\n)\napplication:\n(\nUIApplication\n \n*\n)\napplication\n \ndidFinishLaunchingWithOptions:\n(\nNSDictionary\n \n*\n)\nlaunchOptions\n\n\n{\n\n    \nNSString\n*\n \nappKey\n \n=\n \n@\nxxxxx\n;\n\n\n    \nNSArray\n*\n \nresources\n \n=\n \n@[@{\nP2UXApp_PackageAttrib_FormFactor\n:\n@0\n,\n \nP2UXApp_PackageAttrib_Update\n:\nP2UXApp_PackageUpdate_None\n}]\n;\n\n    \nNSDictionary\n*\n \nopts\n;\n\n\n#ifdef DEBUG\n\n    \nopts\n \n=\n \n@{\nP2UXAppCreator_Opt_Env\n:\n \nP2UXAppCreator_Opt_Env_Stage\n}\n;\n\n\n#endif\n\n    \n[\nP2UXAppCreator\n \ncreateApplicationWithKey\n:\nappKey\n \nopts\n:\nopts\n \nresources\n:\nresources\n \ndelegate\n:\nself\n];\n\n\n    \nreturn\n \n[\nsuper\n \napplication\n:\napplication\n \ndidFinishLaunchingWithOptions\n:\nlaunchOptions\n];\n\n\n}\n\n\n\n\n\n\nSwift\n\n\nIn \nAppDelegate.swift\n:\n\n\n...\n\n\n    \nfunc\n \napplication\n(\n_\n \napplication\n:\n \nUIApplication\n,\n \ndidFinishLaunchingWithOptions\n \nlaunchOptions\n:\n \n[\nUIApplicationLaunchOptionsKey\n:\n \nAny\n]?)\n \n-\n \nBool\n \n{\n\n        \nlet\n \nappKey\n \n=\n \nxxxxx\n;\n\n\n        \nlet\n \nresources\n \n=\n \n[\n\n            \n[\nP2UXApp_PackageAttrib_FormFactor\n:\n0\n,\n \nP2UXApp_PackageAttrib_Update\n:\n \nP2UXApp_PackageUpdate_None\n]\n\n        \n]\n\n\n        \nvar\n \nopts\n \n:\n \n[\nAnyHashable\n \n:\n \nAny\n];\n\n\n#if\n \nDEBUG\n\n        \nopts\n \n=\n \n[\n\n            \nP2UXAppCreator_Opt_Env\n:\n \nP2UXAppCreator_Opt_Env_Recent\n,\n\n            \nP2UXAppCreator_Opt_LogLevel\n:\n \nP2UXCoreLogLevel\n.\nverbose\n.\nrawValue\n \nas\n \nNSNumber\n\n        \n]\n\n\n#endif\n\n\n        \nP2UXAppCreator\n.\ncreateApplication\n(\nwithKey\n:\n \nappKey\n,\n \nopts\n:\n \nopts\n,\n \nresources\n:\n \nresources\n,\n \ndelegate\n:\n \nself\n)\n\n        \nreturn\n \ntrue\n\n    \n}\n\n\n...\n\n\n\n\n\n\nAndroid\n\n\nIn \nMainActivity.java\n: \n\n\npublic\n \nclass\n \nMainActivity\n \nextends\n \nP2UXAppFragmentActivity\n\n\n{\n\n    \n@Override\n\n    \npublic\n \nvoid\n \nonCreate\n(\nBundle\n \nsavedInstanceState\n)\n\n    \n{\n\n        \nmAppKey\n \n=\n \nxxxxxx\n;\n\n        \nif\n \n(\nsavedInstanceState\n \n==\n \nnull\n)\n \n{\n\n            \nsavedInstanceState\n \n=\n \nnew\n \nBundle\n();\n\n        \n}\n\n\n        \n// Build a array of Form Factor objects to setup the resource usage\n\n        \nArrayList\nHashMap\nString\n,\n \nObject\n \nresources\n \n=\n \nnew\n \nArrayList\n();\n\n        \nHashMap\nString\n,\n \nObject\n \nformFactor\n \n=\n \nnew\n \nHashMap\n();\n\n        \nformFactor\n.\nput\n(\nP2UXAppTypes\n.\nP2UXApp_PackageAttrib_FormFactor\n,\n \n0\n);\n\n        \nformFactor\n.\nput\n(\nP2UXAppTypes\n.\nP2UXApp_PackageAttrib_Update\n,\n \nP2UXAppTypes\n.\nP2UXApp_PackageUpdate_None\n);\n\n        \nresources\n.\nadd\n(\nformFactor\n);\n\n        \nsetResources\n(\nresources\n);\n\n\n        \nsuper\n.\nonCreate\n(\nsavedInstanceState\n);\n\n    \n}\n\n\n}", 
            "title": "Application Bundle Updates"
        }, 
        {
            "location": "/general/appbundleupdates/#application-bundle-updates", 
            "text": "One of the benefits of using P2UX application bundles is its ability to update the application content without having to update the native application binary. Application bundles used by native applications can be updated in a few different ways.", 
            "title": "Application Bundle Updates"
        }, 
        {
            "location": "/general/appbundleupdates/#auto-update", 
            "text": "The default update policy for P2UX applications is  Auto Update . Each time the application is restarted by the user, the  PRL  will compare the version of the application bundle it has against the version for the specified environment on  Builder .    Application Environments  Application Environments are used to separate content into different different testing/usage environments. See  Application Environments  for details on use of different environments.   If a new version of the application bundle is found, the  PRL  will prompt the user to let them know there is a new version of the application available. Clicking the OK button from that dialog will restart the application workflow with the new content downloaded from  Builder . The default prompt is a native dialog for the platform.", 
            "title": "Auto Update"
        }, 
        {
            "location": "/general/appbundleupdates/#manual-update", 
            "text": "One option for updating application content is to create a manual action triggered by the user or by some other event. Using the  Manual  update policy, the  PRL  will never check for updates, but can do when requested by a  Check for Updates  action in the content. This gives the developer control as to when an update check will happen.  If a new version of the application bundle is found, the  PRL  will prompt the user to let them know there is a new version of the application available. Clicking the OK button from that dialog will restart the application workflow with the new content downloaded from  Builder . The default prompt is a native dialog for the platform.", 
            "title": "Manual Update"
        }, 
        {
            "location": "/general/appbundleupdates/#no-update", 
            "text": "If the application content will never be updated dynamically, the developer can opt to tell the  PRL  to never allow for updates. The only way to update the content is to use  Static  application content bundles that are built into the native application binaries. (See  Static Application Bundle ) In this mode, any requests to check for updates are ignored by the  PRL .", 
            "title": "No Update"
        }, 
        {
            "location": "/general/appbundleupdates/#specifying-resources", 
            "text": "Its the responsibility of the application developer to let the  PRL  know how the application bundle resources should be used. On startup the application should create an array of objects (one object for each form factor) that define how the resources for the form factor should be used.   Form factors are indicated by a numeric value:     Value  Form Factor      0  Phone    1  Tablet    4  TV     Below is an example of an application that uses  None  as the update policy for the  Phone  form factor. It will never check for updates.", 
            "title": "Specifying Resources"
        }, 
        {
            "location": "/general/appbundleupdates/#iostvos", 
            "text": "", 
            "title": "iOS/tvOS"
        }, 
        {
            "location": "/general/appbundleupdates/#objective-c", 
            "text": "In  AppDelegate.m :  -   ( BOOL ) application: ( UIApplication   * ) application   didFinishLaunchingWithOptions: ( NSDictionary   * ) launchOptions  { \n     NSString *   appKey   =   @ xxxxx ; \n\n     NSArray *   resources   =   @[@{ P2UXApp_PackageAttrib_FormFactor : @0 ,   P2UXApp_PackageAttrib_Update : P2UXApp_PackageUpdate_None }] ; \n     NSDictionary *   opts ;  #ifdef DEBUG \n     opts   =   @{ P2UXAppCreator_Opt_Env :   P2UXAppCreator_Opt_Env_Stage } ;  #endif \n     [ P2UXAppCreator   createApplicationWithKey : appKey   opts : opts   resources : resources   delegate : self ]; \n\n     return   [ super   application : application   didFinishLaunchingWithOptions : launchOptions ];  }", 
            "title": "Objective-C"
        }, 
        {
            "location": "/general/appbundleupdates/#swift", 
            "text": "In  AppDelegate.swift :  ... \n\n     func   application ( _   application :   UIApplication ,   didFinishLaunchingWithOptions   launchOptions :   [ UIApplicationLaunchOptionsKey :   Any ]?)   -   Bool   { \n         let   appKey   =   xxxxx ; \n\n         let   resources   =   [ \n             [ P2UXApp_PackageAttrib_FormFactor : 0 ,   P2UXApp_PackageAttrib_Update :   P2UXApp_PackageUpdate_None ] \n         ] \n\n         var   opts   :   [ AnyHashable   :   Any ];  #if   DEBUG \n         opts   =   [ \n             P2UXAppCreator_Opt_Env :   P2UXAppCreator_Opt_Env_Recent , \n             P2UXAppCreator_Opt_LogLevel :   P2UXCoreLogLevel . verbose . rawValue   as   NSNumber \n         ]  #endif \n\n         P2UXAppCreator . createApplication ( withKey :   appKey ,   opts :   opts ,   resources :   resources ,   delegate :   self ) \n         return   true \n     }  ...", 
            "title": "Swift"
        }, 
        {
            "location": "/general/appbundleupdates/#android", 
            "text": "In  MainActivity.java :   public   class   MainActivity   extends   P2UXAppFragmentActivity  { \n     @Override \n     public   void   onCreate ( Bundle   savedInstanceState ) \n     { \n         mAppKey   =   xxxxxx ; \n         if   ( savedInstanceState   ==   null )   { \n             savedInstanceState   =   new   Bundle (); \n         } \n\n         // Build a array of Form Factor objects to setup the resource usage \n         ArrayList HashMap String ,   Object   resources   =   new   ArrayList (); \n         HashMap String ,   Object   formFactor   =   new   HashMap (); \n         formFactor . put ( P2UXAppTypes . P2UXApp_PackageAttrib_FormFactor ,   0 ); \n         formFactor . put ( P2UXAppTypes . P2UXApp_PackageAttrib_Update ,   P2UXAppTypes . P2UXApp_PackageUpdate_None ); \n         resources . add ( formFactor ); \n         setResources ( resources ); \n\n         super . onCreate ( savedInstanceState ); \n     }  }", 
            "title": "Android"
        }, 
        {
            "location": "/general/dynamicappbundle/", 
            "text": "Dynamic Application Bundle\n\n\n\n\nThe default behavior of the \nP2UX Rendering Library\n (PRL) is to use the application bundle created by \nBuilder\n as a dynamic resource. In this mode, there are no resources bundled into the native application itself. Instead, the first time the application is run, the \nPRL\n will contact \nBuilder\n and retrieve the application bundle for the specified environment (see \nApplication Environments\n) before the application starts. This experience allows for application content to be completely dynamic and easily updatable without need to have a heavy native application binary.\n\n\n\n\nConnectivity Required for First Run\n\n\nUsing dynamic application bundles requires connectivity for the first run of the application so that the application can retrieve its content. In the case where the user runs an application for the first time without connectivity, the \nPRL\n will show an error dialog prompting the user to connect to the internet. If connectivity for first run is an issue, use \nStatic Application Bundles\n\n\n\n\nCustomizing the Startup Screen\n\n\nWhen using application bundles as live dynamic resources, the \nPRL\n will show a loading screen the first time your application runs. The default loading screen shows a P2UX logo, a message and the loading progress. This screen can be customized by the developer to use customized assets and messaging to match your application.\n\n\n\n\nNote\n\n\nAfter the first time the application bundle is successfully downloaded and unpacked, all updates of the application bundle are performed in the background allowing the user to continue using the application. (See \nApplication Bundle Updates\n for more options on updating) It's only the first run of the application where the Startup Screen is shown.\n\n\n\n\niOS/tvOS\n\n\nThe startup screen can be customized by providing an instance of the \nP2UXAppLoadingViewController\n class via the \ncreateLoadingViewController\n method of the \nP2UXAppCreatorDelegate\n protocol. Typically this is handled via your \nAppDelegate\n instance by having it implement the \nP2UXAppCreatorDelegate\n protocol. Since the class \nP2UXAppLoadingViewController\n is just an instance of UIViewController, the contents can be customized using any standard iOS/tvOS APIs. \n\n\nThere are helper methods in the \nP2UXAppLoadingViewController\n class that provide access to the default components of the view.\n\n\n\n\nNote\n\n\nFor Xcode projects created using the P2UX \nCoordinator\n application for macOS, the \nAppDelegate\n class is already setup as the \nP2UXAppCreatorDelegate\n delegate to \nP2UXAppCreator\n.\n\n\n\n\nObjective-C\n\n\nIn \nAppDelegate.m\n\n\n...\n\n\n// Return an instance of a P2UXAppLoadingViewController derived class\n\n\n-\n \n(\nP2UXAppLoadingViewController\n*\n)\n \ncreateLoadingViewController\n \n{\n\n    \nreturn\n \n[[\nCustomLoadingViewController\n \nalloc\n]\n \ninit\n];\n\n\n}\n\n\n\n\n\n\nIn the custom class (in this example \nCustomLoadingViewController\n):\n\n\n...\n\n\n-\n \n(\nvoid\n)\nviewDidLoad\n \n{\n\n    \n[\nsuper\n \nviewDidLoad\n];\n\n\n    \n// for this example, we\nll just override the logo shown in the loading dialog.\n\n    \n// load the UIImage instance of the custom logo from the native app bundle.\n\n    \nUIImage\n*\n \nlogo\n \n=\n \n[\nUIImage\n \nimageNamed\n:\n@\ncustomlogo\n];\n\n    \n// set this image as the current logo\n\n    \n// this is a method of the base class P2UXAppLoadingViewController\n\n    \n[\nself\n \nsetLogoImage\n:\n \nlogo\n];\n    \n\n}\n\n\n\n\n\n\nSwift\n\n\nIn \nAppDelegate.swift\n\n\n...\n\n\n// Return an instance of a P2UXAppLoadingViewController derived class\n\n\nfunc\n \ncreateLoadingViewController\n()\n \n-\n \nP2UXAppLoadingViewController\n \n{\n\n        \nreturn\n \nCustomLoadingViewController\n()\n\n\n}\n\n\n\n\n\n\nIn the custom class (in this example \nCustomLoadingViewController\n):\n\n\n...\n\n\noverride\n \nfunc\n \nviewDidLoad\n()\n \n{\n\n    \nsuper\n.\nviewDidLoad\n()\n\n\n    \n// for this example, we\nll just override the logo shown in the loading dialog\n\n    \n// load the UIImage instance of the customlogo from the native app bundle.\n\n    \nlet\n \nimage\n \n=\n \nUIImage\n.\ninit\n(\nnamed\n:\n \ncustomlogo\n);\n\n    \n// set this image as the current logo\n\n    \n// this is a method of the base class P2UXAppLoadingViewController\n\n    \nself\n.\nsetLogoImage\n(\nimage\n);\n\n\n}\n\n\n\n\n\n\nAndroid\n\n\nIn the \nMainActivity.java\n\n\n// Coming Soon\n\n\n\n\n\n\nCustomizing the Error Screen\n\n\nCustomizing the error screen shown when the \nPRL\n is unable to load the application content is done much in the same way as customizing the loading screen.\n\n\niOS/tvOS\n\n\nThe error screen can be customized by providing an instance of the \nP2UXAppErrorViewController\n class via the \ncreateErrorViewController\n method of the \nP2UXAppCreatorDelegate\n protocol. Typically this is handled via your \nAppDelegate\n instance by having it implement the \nP2UXAppCreatorDelegate\n protocol. Since the class \nP2UXAppErrorViewController\n is just an instance of UIViewController, the contents can be customized using any standard iOS/tvOS APIs. \n\n\nThere are helper methods in the \nP2UXAppErrorViewController\n class that provide access to the default components of the view.\n\n\nObjective-C\n\n\nIn \nAppDelegate.m\n\n\n...\n\n\n// Return an instance of a P2UXAppLoadingViewController derived class\n\n\n-\n \n(\nP2UXAppLoadingViewController\n*\n)\n \ncreateErrorViewController\n \n{\n\n    \nreturn\n \n[[\nCustomErrorViewController\n \nalloc\n]\n \ninit\n];\n\n\n}\n\n\n\n\n\n\nIn the custom class (in this example \nCustomErrorViewController\n):\n\n\n...\n\n\n-\n \n(\nvoid\n)\nviewDidLoad\n \n{\n\n    \n[\nsuper\n \nviewDidLoad\n];\n\n\n    \n// for this example, we\nll just change the background color\n\n    \n[\nself\n.\nview\n \nsetBackgroundColor\n:[\nUIColor\n \nblueColor\n]];\n\n\n}\n\n\n\n\n\n\nSwift\n\n\nIn \nAppDelegate.swift\n\n\n...\n\n\n// Return an instance of a P2UXAppErrorViewController derived class\n\n\nfunc\n \ncreateErrorViewController\n()\n \n-\n \nP2UXAppErrorViewController\n \n{\n\n        \nreturn\n \nCustomErrorViewController\n()\n\n\n}\n\n\n\n\n\n\nIn the custom class (in this example \nCustomErrorViewController\n):\n\n\n...\n\n\noverride\n \nfunc\n \nviewDidLoad\n()\n \n{\n\n    \nsuper\n.\nviewDidLoad\n()\n\n\n    \n// for this example, we\nll just change the background color\n\n    \nself\n.\nview\n.\nbackgroundColor\n \n=\n \nUIColor\n.\nblue\n;\n\n\n}\n\n\n\n\n\n\nAndroid\n\n\nComing soon\n\n\n\n\n\nLast Updated: Nov. 12, 2017", 
            "title": "Dynamic Application Bundle"
        }, 
        {
            "location": "/general/dynamicappbundle/#dynamic-application-bundle", 
            "text": "The default behavior of the  P2UX Rendering Library  (PRL) is to use the application bundle created by  Builder  as a dynamic resource. In this mode, there are no resources bundled into the native application itself. Instead, the first time the application is run, the  PRL  will contact  Builder  and retrieve the application bundle for the specified environment (see  Application Environments ) before the application starts. This experience allows for application content to be completely dynamic and easily updatable without need to have a heavy native application binary.   Connectivity Required for First Run  Using dynamic application bundles requires connectivity for the first run of the application so that the application can retrieve its content. In the case where the user runs an application for the first time without connectivity, the  PRL  will show an error dialog prompting the user to connect to the internet. If connectivity for first run is an issue, use  Static Application Bundles", 
            "title": "Dynamic Application Bundle"
        }, 
        {
            "location": "/general/dynamicappbundle/#customizing-the-startup-screen", 
            "text": "When using application bundles as live dynamic resources, the  PRL  will show a loading screen the first time your application runs. The default loading screen shows a P2UX logo, a message and the loading progress. This screen can be customized by the developer to use customized assets and messaging to match your application.   Note  After the first time the application bundle is successfully downloaded and unpacked, all updates of the application bundle are performed in the background allowing the user to continue using the application. (See  Application Bundle Updates  for more options on updating) It's only the first run of the application where the Startup Screen is shown.", 
            "title": "Customizing the Startup Screen"
        }, 
        {
            "location": "/general/dynamicappbundle/#iostvos", 
            "text": "The startup screen can be customized by providing an instance of the  P2UXAppLoadingViewController  class via the  createLoadingViewController  method of the  P2UXAppCreatorDelegate  protocol. Typically this is handled via your  AppDelegate  instance by having it implement the  P2UXAppCreatorDelegate  protocol. Since the class  P2UXAppLoadingViewController  is just an instance of UIViewController, the contents can be customized using any standard iOS/tvOS APIs.   There are helper methods in the  P2UXAppLoadingViewController  class that provide access to the default components of the view.   Note  For Xcode projects created using the P2UX  Coordinator  application for macOS, the  AppDelegate  class is already setup as the  P2UXAppCreatorDelegate  delegate to  P2UXAppCreator .", 
            "title": "iOS/tvOS"
        }, 
        {
            "location": "/general/dynamicappbundle/#objective-c", 
            "text": "In  AppDelegate.m  ...  // Return an instance of a P2UXAppLoadingViewController derived class  -   ( P2UXAppLoadingViewController * )   createLoadingViewController   { \n     return   [[ CustomLoadingViewController   alloc ]   init ];  }   In the custom class (in this example  CustomLoadingViewController ):  ...  -   ( void ) viewDidLoad   { \n     [ super   viewDidLoad ]; \n\n     // for this example, we ll just override the logo shown in the loading dialog. \n     // load the UIImage instance of the custom logo from the native app bundle. \n     UIImage *   logo   =   [ UIImage   imageNamed : @ customlogo ]; \n     // set this image as the current logo \n     // this is a method of the base class P2UXAppLoadingViewController \n     [ self   setLogoImage :   logo ];      }", 
            "title": "Objective-C"
        }, 
        {
            "location": "/general/dynamicappbundle/#swift", 
            "text": "In  AppDelegate.swift  ...  // Return an instance of a P2UXAppLoadingViewController derived class  func   createLoadingViewController ()   -   P2UXAppLoadingViewController   { \n         return   CustomLoadingViewController ()  }   In the custom class (in this example  CustomLoadingViewController ):  ...  override   func   viewDidLoad ()   { \n     super . viewDidLoad () \n\n     // for this example, we ll just override the logo shown in the loading dialog \n     // load the UIImage instance of the customlogo from the native app bundle. \n     let   image   =   UIImage . init ( named :   customlogo ); \n     // set this image as the current logo \n     // this is a method of the base class P2UXAppLoadingViewController \n     self . setLogoImage ( image );  }", 
            "title": "Swift"
        }, 
        {
            "location": "/general/dynamicappbundle/#android", 
            "text": "In the  MainActivity.java  // Coming Soon", 
            "title": "Android"
        }, 
        {
            "location": "/general/dynamicappbundle/#customizing-the-error-screen", 
            "text": "Customizing the error screen shown when the  PRL  is unable to load the application content is done much in the same way as customizing the loading screen.", 
            "title": "Customizing the Error Screen"
        }, 
        {
            "location": "/general/dynamicappbundle/#iostvos_1", 
            "text": "The error screen can be customized by providing an instance of the  P2UXAppErrorViewController  class via the  createErrorViewController  method of the  P2UXAppCreatorDelegate  protocol. Typically this is handled via your  AppDelegate  instance by having it implement the  P2UXAppCreatorDelegate  protocol. Since the class  P2UXAppErrorViewController  is just an instance of UIViewController, the contents can be customized using any standard iOS/tvOS APIs.   There are helper methods in the  P2UXAppErrorViewController  class that provide access to the default components of the view.", 
            "title": "iOS/tvOS"
        }, 
        {
            "location": "/general/dynamicappbundle/#objective-c_1", 
            "text": "In  AppDelegate.m  ...  // Return an instance of a P2UXAppLoadingViewController derived class  -   ( P2UXAppLoadingViewController * )   createErrorViewController   { \n     return   [[ CustomErrorViewController   alloc ]   init ];  }   In the custom class (in this example  CustomErrorViewController ):  ...  -   ( void ) viewDidLoad   { \n     [ super   viewDidLoad ]; \n\n     // for this example, we ll just change the background color \n     [ self . view   setBackgroundColor :[ UIColor   blueColor ]];  }", 
            "title": "Objective-C"
        }, 
        {
            "location": "/general/dynamicappbundle/#swift_1", 
            "text": "In  AppDelegate.swift  ...  // Return an instance of a P2UXAppErrorViewController derived class  func   createErrorViewController ()   -   P2UXAppErrorViewController   { \n         return   CustomErrorViewController ()  }   In the custom class (in this example  CustomErrorViewController ):  ...  override   func   viewDidLoad ()   { \n     super . viewDidLoad () \n\n     // for this example, we ll just change the background color \n     self . view . backgroundColor   =   UIColor . blue ;  }", 
            "title": "Swift"
        }, 
        {
            "location": "/general/dynamicappbundle/#android_1", 
            "text": "Coming soon  Last Updated: Nov. 12, 2017", 
            "title": "Android"
        }, 
        {
            "location": "/general/staticappbundle/", 
            "text": "Static Application Bundles\n\n\n\n\nApplication developers can choose to include their P2UX application bundle as a static resource contained in their native application binary. Providing the application bundle as a static resource removes the need for connectivity when the application runs for the first time. \n\n\nPotential issues to consider with this approach are:\n\n\n\n\nIf dynamic updates are NOT allowed, updates to application bundle have to be made by updating the application binary itself to include the updated bundle. This means resubmitting your application to the respective stores which can take time to get approval.\n\n\nIf dynamic updates are allowed, a new installation of the application may end up updating its content immediately on first install as the embedded application bundle may be out of date.\n\n\n\n\n\n\nImportant\n\n\nCurrently \nBuilder\n doesn't provide a direct mechanism to download the bundle for inclusion in a native application. The \nCoordinator\n product does provide a way to use application bundles. As of this writting, that application has not been released for public use. Check back soon for more information, or contact P2UX support.\n\n\n\n\nThe following example sets up an application that supports both \nPhone\n and \nTablet\n form factors to use embedded resources. The resources have been unzipped into subdirectories in the project named \nphone\n and \ntablet\n to hold the different resources.\n\n\n\n\nNote\n\n\nIf your project resources are exactly the same for phone and tablet form factors, you can setup the resource usage to point to the same subdirectory in your project. Otherwise they should be in their own subdirectories.\n\n\n\n\niOS/tvOS\n\n\nObjective-C\n\n\nIn \nAppDelegate.m\n:\n\n\n-\n \n(\nBOOL\n)\napplication:\n(\nUIApplication\n \n*\n)\napplication\n \ndidFinishLaunchingWithOptions:\n(\nNSDictionary\n \n*\n)\nlaunchOptions\n\n\n{\n\n    \nNSString\n*\n \nappKey\n \n=\n \n@\nxxxxx\n;\n\n\n    \n// Define the resources for both Phone and Tablet\n\n    \n// for this case, both are using static resources in sub directories named\n\n    \n// \nphone\n and \ntablet\n\n    \nNSArray\n*\n \nresources\n \n=\n \n@[\n\n        \n@{\nP2UXApp_PackageAttrib_FormFactor\n:\n@0\n,\n  \n// Phone \n\n          \nP2UXApp_PackageAttrib_Update\n:\nP2UXApp_PackageUpdate_Auto\n,\n\n          \nP2UXApp_PackageAttrib_Type\n:\nP2UXApp_PackageType_Static\n,\n\n          \nP2UXApp_PackageAttrib_Package\n:\n@\nphone\n}\n,\n\n        \n@{\nP2UXApp_PackageAttrib_FormFactor\n:\n@1\n,\n  \n// Tablet \n\n          \nP2UXApp_PackageAttrib_Update\n:\nP2UXApp_PackageUpdate_Auto\n,\n\n          \nP2UXApp_PackageAttrib_Type\n:\nP2UXApp_PackageType_Static\n,\n\n          \nP2UXApp_PackageAttrib_Package\n:\n@\ntablet\n}\n    \n    \n]\n;\n\n\n    \nNSDictionary\n*\n \nopts\n;\n\n    \n// For Debug builds, use the Stage Environment. That way we can test things before\n\n    \n// release\n\n\n#ifdef DEBUG\n\n    \nopts\n \n=\n \n@{\nP2UXAppCreator_Opt_Env\n:\n \nP2UXAppCreator_Opt_Env_Stage\n}\n;\n\n\n#endif\n\n    \n[\nP2UXAppCreator\n \ncreateApplicationWithKey\n:\nappKey\n \nopts\n:\nopts\n \nresources\n:\nresources\n \ndelegate\n:\nself\n];\n\n\n    \nreturn\n \n[\nsuper\n \napplication\n:\napplication\n \ndidFinishLaunchingWithOptions\n:\nlaunchOptions\n];\n\n\n}\n\n\n\n\n\n\nSwift\n\n\nIn \nAppDelegate.swift\n:\n\n\n...\n\n    \nfunc\n \napplication\n(\n_\n \napplication\n:\n \nUIApplication\n,\n \ndidFinishLaunchingWithOptions\n \nlaunchOptions\n:\n \n[\nUIApplicationLaunchOptionsKey\n:\n \nAny\n]?)\n \n-\n \nBool\n \n{\n\n        \nlet\n \nappKey\n \n=\n \nxxxxx\n;\n\n\n        \n// Define the resources for both Phone and Tablet\n\n        \n// for this case, both are using static resources in sub directories named\n\n        \n// \nphone\n and \ntablet\n\n        \nlet\n \nresources\n \n=\n \n[\n\n            \n[\nP2UXApp_PackageAttrib_FormFactor\n:\n0\n,\n  \n// Phone \n\n             \nP2UXApp_PackageAttrib_Update\n:\nP2UXApp_PackageUpdate_Auto\n,\n\n             \nP2UXApp_PackageAttrib_Type\n:\nP2UXApp_PackageType_Static\n,\n\n             \nP2UXApp_PackageAttrib_Package\n:\nphone\n],\n\n            \n[\nP2UXApp_PackageAttrib_FormFactor\n:\n1\n,\n  \n// Tablet \n\n             \nP2UXApp_PackageAttrib_Update\n:\nP2UXApp_PackageUpdate_Auto\n,\n\n             \nP2UXApp_PackageAttrib_Type\n:\nP2UXApp_PackageType_Static\n,\n\n             \nP2UXApp_PackageAttrib_Package\n:\ntablet\n]\n    \n        \n]\n\n\n        \nvar\n \nopts\n \n:\n \n[\nAnyHashable\n \n:\n \nAny\n];\n\n        \n// For Debug builds, use the Stage Environment. That way we can test things before\n\n        \n// release\n\n\n#if\n \nDEBUG\n\n        \nopts\n \n=\n \n[\n\n            \nP2UXAppCreator_Opt_Env\n:\n \nP2UXAppCreator_Opt_Env_Stage\n\n        \n]\n\n\n#endif\n\n\n        \nP2UXAppCreator\n.\ncreateApplication\n(\nwithKey\n:\n \nappKey\n,\n \nopts\n:\n \nopts\n,\n \nresources\n:\n \nresources\n,\n \ndelegate\n:\n \nself\n)\n\n        \nreturn\n \ntrue\n\n    \n}\n\n\n...\n\n\n\n\n\n\nAndroid\n\n\nIn \nMainActivity.java\n:\n\n\npublic\n \nclass\n \nMainActivity\n \nextends\n \nP2UXAppFragmentActivity\n\n\n{\n\n    \n@Override\n\n    \npublic\n \nvoid\n \nonCreate\n(\nBundle\n \nsavedInstanceState\n)\n\n    \n{\n\n        \nmAppKey\n \n=\n \n0006.6ad72f39bc0b6181f522b51595e0280d2c1505bd7862c702d500744ae4d705fd\n;\n\n        \nif\n \n(\nsavedInstanceState\n \n==\n \nnull\n)\n \n{\n\n            \nsavedInstanceState\n \n=\n \nnew\n \nBundle\n();\n\n        \n}\n\n\n        \n// Define the resources for both Phone and Tablet\n\n        \n// for this case, both are using static resources in sub directories named\n\n        \n// \nphone\n and \ntablet\n\n        \nArrayList\nHashMap\nString\n,\n \nObject\n \nresources\n \n=\n \nnew\n \nArrayList\n();\n\n        \n// Phone form factor\n\n        \nHashMap\nString\n,\n \nObject\n \nformFactor\n \n=\n \nnew\n \nHashMap\n();\n\n        \nformFactor\n.\nput\n(\nP2UXAppTypes\n.\nP2UXApp_PackageAttrib_FormFactor\n,\n \n0\n);\n\n        \nformFactor\n.\nput\n(\nP2UXAppTypes\n.\nP2UXApp_PackageAttrib_Type\n,\n \nP2UXAppTypes\n.\nP2UXApp_PackageType_Static\n);\n\n        \nformFactor\n.\nput\n(\nP2UXAppTypes\n.\nP2UXApp_PackageAttrib_Package\n,\n \nphone\n);\n\n        \nformFactor\n.\nput\n(\nP2UXAppTypes\n.\nP2UXApp_PackageAttrib_Update\n,\n \nP2UXAppTypes\n.\nP2UXApp_PackageUpdate_Auto\n);\n\n        \nresources\n.\nadd\n(\nformFactor\n);\n\n        \n// Tablet form factor\n\n        \nformFactor\n \n=\n \nnew\n \nHashMap\n();\n\n        \nformFactor\n.\nput\n(\nP2UXAppTypes\n.\nP2UXApp_PackageAttrib_FormFactor\n,\n \n1\n);\n\n        \nformFactor\n.\nput\n(\nP2UXAppTypes\n.\nP2UXApp_PackageAttrib_Type\n,\n \nP2UXAppTypes\n.\nP2UXApp_PackageType_Static\n);\n\n        \nformFactor\n.\nput\n(\nP2UXAppTypes\n.\nP2UXApp_PackageAttrib_Package\n,\n \ntablet\n);\n\n        \nformFactor\n.\nput\n(\nP2UXAppTypes\n.\nP2UXApp_PackageAttrib_Update\n,\n \nP2UXAppTypes\n.\nP2UXApp_PackageUpdate_Auto\n);\n\n        \nresources\n.\nadd\n(\nformFactor\n);\n\n        \nsetResources\n(\nresources\n);\n\n\n        \n// Setup options\n\n        \nsavedInstanceState\n.\nputString\n(\nP2UXAppCreator\n.\nP2UXAppCreator_Opt_Env\n,\n \nP2UXAppCreator\n.\nP2UXAppCreator_Opt_Env_Recent\n);\n\n\n        \n// Setup where data sources are persisted to\n\n        \nsavedInstanceState\n.\nputString\n(\nP2UXAppCreator\n.\nP2UXAppCreator_Opt_PersistData\n,\n \nP2UXAppCreator\n.\nP2UXAppCreator_Opt_PersistData_Internal\n);\n\n        \nsuper\n.\nonCreate\n(\nsavedInstanceState\n);\n\n        \napplyTranslucentStatusBar\n();\n\n    \n}\n\n\n}\n\n\n\n\n\n\nLast Updated: Dec. 3, 2017", 
            "title": "Static Application Bundle"
        }, 
        {
            "location": "/general/staticappbundle/#static-application-bundles", 
            "text": "Application developers can choose to include their P2UX application bundle as a static resource contained in their native application binary. Providing the application bundle as a static resource removes the need for connectivity when the application runs for the first time.   Potential issues to consider with this approach are:   If dynamic updates are NOT allowed, updates to application bundle have to be made by updating the application binary itself to include the updated bundle. This means resubmitting your application to the respective stores which can take time to get approval.  If dynamic updates are allowed, a new installation of the application may end up updating its content immediately on first install as the embedded application bundle may be out of date.    Important  Currently  Builder  doesn't provide a direct mechanism to download the bundle for inclusion in a native application. The  Coordinator  product does provide a way to use application bundles. As of this writting, that application has not been released for public use. Check back soon for more information, or contact P2UX support.   The following example sets up an application that supports both  Phone  and  Tablet  form factors to use embedded resources. The resources have been unzipped into subdirectories in the project named  phone  and  tablet  to hold the different resources.   Note  If your project resources are exactly the same for phone and tablet form factors, you can setup the resource usage to point to the same subdirectory in your project. Otherwise they should be in their own subdirectories.", 
            "title": "Static Application Bundles"
        }, 
        {
            "location": "/general/staticappbundle/#iostvos", 
            "text": "", 
            "title": "iOS/tvOS"
        }, 
        {
            "location": "/general/staticappbundle/#objective-c", 
            "text": "In  AppDelegate.m :  -   ( BOOL ) application: ( UIApplication   * ) application   didFinishLaunchingWithOptions: ( NSDictionary   * ) launchOptions  { \n     NSString *   appKey   =   @ xxxxx ; \n\n     // Define the resources for both Phone and Tablet \n     // for this case, both are using static resources in sub directories named \n     //  phone  and  tablet \n     NSArray *   resources   =   @[ \n         @{ P2UXApp_PackageAttrib_FormFactor : @0 ,    // Phone  \n           P2UXApp_PackageAttrib_Update : P2UXApp_PackageUpdate_Auto , \n           P2UXApp_PackageAttrib_Type : P2UXApp_PackageType_Static , \n           P2UXApp_PackageAttrib_Package : @ phone } , \n         @{ P2UXApp_PackageAttrib_FormFactor : @1 ,    // Tablet  \n           P2UXApp_PackageAttrib_Update : P2UXApp_PackageUpdate_Auto , \n           P2UXApp_PackageAttrib_Type : P2UXApp_PackageType_Static , \n           P2UXApp_PackageAttrib_Package : @ tablet }     \n     ] ; \n\n     NSDictionary *   opts ; \n     // For Debug builds, use the Stage Environment. That way we can test things before \n     // release  #ifdef DEBUG \n     opts   =   @{ P2UXAppCreator_Opt_Env :   P2UXAppCreator_Opt_Env_Stage } ;  #endif \n     [ P2UXAppCreator   createApplicationWithKey : appKey   opts : opts   resources : resources   delegate : self ]; \n\n     return   [ super   application : application   didFinishLaunchingWithOptions : launchOptions ];  }", 
            "title": "Objective-C"
        }, 
        {
            "location": "/general/staticappbundle/#swift", 
            "text": "In  AppDelegate.swift :  ... \n     func   application ( _   application :   UIApplication ,   didFinishLaunchingWithOptions   launchOptions :   [ UIApplicationLaunchOptionsKey :   Any ]?)   -   Bool   { \n         let   appKey   =   xxxxx ; \n\n         // Define the resources for both Phone and Tablet \n         // for this case, both are using static resources in sub directories named \n         //  phone  and  tablet \n         let   resources   =   [ \n             [ P2UXApp_PackageAttrib_FormFactor : 0 ,    // Phone  \n              P2UXApp_PackageAttrib_Update : P2UXApp_PackageUpdate_Auto , \n              P2UXApp_PackageAttrib_Type : P2UXApp_PackageType_Static , \n              P2UXApp_PackageAttrib_Package : phone ], \n             [ P2UXApp_PackageAttrib_FormFactor : 1 ,    // Tablet  \n              P2UXApp_PackageAttrib_Update : P2UXApp_PackageUpdate_Auto , \n              P2UXApp_PackageAttrib_Type : P2UXApp_PackageType_Static , \n              P2UXApp_PackageAttrib_Package : tablet ]     \n         ] \n\n         var   opts   :   [ AnyHashable   :   Any ]; \n         // For Debug builds, use the Stage Environment. That way we can test things before \n         // release  #if   DEBUG \n         opts   =   [ \n             P2UXAppCreator_Opt_Env :   P2UXAppCreator_Opt_Env_Stage \n         ]  #endif \n\n         P2UXAppCreator . createApplication ( withKey :   appKey ,   opts :   opts ,   resources :   resources ,   delegate :   self ) \n         return   true \n     }  ...", 
            "title": "Swift"
        }, 
        {
            "location": "/general/staticappbundle/#android", 
            "text": "In  MainActivity.java :  public   class   MainActivity   extends   P2UXAppFragmentActivity  { \n     @Override \n     public   void   onCreate ( Bundle   savedInstanceState ) \n     { \n         mAppKey   =   0006.6ad72f39bc0b6181f522b51595e0280d2c1505bd7862c702d500744ae4d705fd ; \n         if   ( savedInstanceState   ==   null )   { \n             savedInstanceState   =   new   Bundle (); \n         } \n\n         // Define the resources for both Phone and Tablet \n         // for this case, both are using static resources in sub directories named \n         //  phone  and  tablet \n         ArrayList HashMap String ,   Object   resources   =   new   ArrayList (); \n         // Phone form factor \n         HashMap String ,   Object   formFactor   =   new   HashMap (); \n         formFactor . put ( P2UXAppTypes . P2UXApp_PackageAttrib_FormFactor ,   0 ); \n         formFactor . put ( P2UXAppTypes . P2UXApp_PackageAttrib_Type ,   P2UXAppTypes . P2UXApp_PackageType_Static ); \n         formFactor . put ( P2UXAppTypes . P2UXApp_PackageAttrib_Package ,   phone ); \n         formFactor . put ( P2UXAppTypes . P2UXApp_PackageAttrib_Update ,   P2UXAppTypes . P2UXApp_PackageUpdate_Auto ); \n         resources . add ( formFactor ); \n         // Tablet form factor \n         formFactor   =   new   HashMap (); \n         formFactor . put ( P2UXAppTypes . P2UXApp_PackageAttrib_FormFactor ,   1 ); \n         formFactor . put ( P2UXAppTypes . P2UXApp_PackageAttrib_Type ,   P2UXAppTypes . P2UXApp_PackageType_Static ); \n         formFactor . put ( P2UXAppTypes . P2UXApp_PackageAttrib_Package ,   tablet ); \n         formFactor . put ( P2UXAppTypes . P2UXApp_PackageAttrib_Update ,   P2UXAppTypes . P2UXApp_PackageUpdate_Auto ); \n         resources . add ( formFactor ); \n         setResources ( resources ); \n\n         // Setup options \n         savedInstanceState . putString ( P2UXAppCreator . P2UXAppCreator_Opt_Env ,   P2UXAppCreator . P2UXAppCreator_Opt_Env_Recent ); \n\n         // Setup where data sources are persisted to \n         savedInstanceState . putString ( P2UXAppCreator . P2UXAppCreator_Opt_PersistData ,   P2UXAppCreator . P2UXAppCreator_Opt_PersistData_Internal ); \n         super . onCreate ( savedInstanceState ); \n         applyTranslucentStatusBar (); \n     }  }   Last Updated: Dec. 3, 2017", 
            "title": "Android"
        }, 
        {
            "location": "/general/splashscreen/", 
            "text": "Splash Screens\n\n\n\n\nComing soon", 
            "title": "Splash Screens"
        }, 
        {
            "location": "/general/splashscreen/#splash-screens", 
            "text": "Coming soon", 
            "title": "Splash Screens"
        }, 
        {
            "location": "/linking/filtersconditionals/", 
            "text": "Data Filters and Conditionals\n\n\nData linked to controls can be modified using a variety of filters or conditionals. Filters and conditionals can be provided directly in the assignment of data to a specific property on a control or as the result of a conditional. \n\n\nCurrently the \nBuilder\n product doesn't have a special built editor for working with filters or formatters other than working directly with the P2UX format. This guide helps explain how to manually enter filters and conditionals.\n\n\nFiltering Data\n\n\nFilters can be used to apply math, formatting or just combine multiple values together to assign to a property of a component. In general, expressions, formatters and functions have specific delimiters used to indicate their use. \n\n\nTo filter a value applied to a property of a component in \nBuilder\n:\n\n\n\n\nSelect the component in the Screen/Panel Editor.\n\n\nClick the \nData\n Tab from the right side of the editor\n\n\nFrom the \nSelect Property\n drop down, select the property of the component you want to apply the data to.\n\n\n\n\nFrom the \nSelect Source\n drop down for the property, select \nFilter: Data Expression\n\n\n\n\n\n\n\n\nNext add at least one variable to use by clicking the \nWith data:\n link button\n\n\n\n\nFrom the \nEdit Data Link Values\n dialog, select the variable for the property and give it a name by editing the name field (In this example the variable is given the name \nuser\n), then click \nOK\n to close the dialog.\n\n\n\n\n\n\n\nNote\n\n\nYou can add more than one variable to the property and combine values in the filter or the conditional. Click the \nAdd Data Link\n button to add another data link.\n\n\n\n\n\n\nThe expression is typed into the \nExpression\n text field. This particular example shows the \nuser\n variable being combined with the \nstatus\n variable before being assigned to the \nlabel\n property of a Text component. \n\n\n\n\nExample output would show: \nuser is offline\n.\n\n\n\n\n\n\nNote\n\n\nWhen creating a filter or conditional, variables are delimited using the notation \n{{\nname\n}}\n. Variables can be used without any specific expression syntax as well to just combine values together.\n\n\n\n\nConditional Data\n\n\nConditionals can be used to change the resulting value by evaluating one or more variables and choosing a resulting value based on the outcome of the conditional evaluation. Just like with filters, conditionals refer to variables using the notation \n{{\nname\n}}\n. \n\n\nConditionals use the typical programming operators for comparison:\n\n\n\n\n\n\n\n\nOperator\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n==\n\n\nEqual to\n\n\n\n\n\n\n!=\n\n\nNot Equal to\n\n\n\n\n\n\n\n\nGreater than\n\n\n\n\n\n\n\n\nLess than\n\n\n\n\n\n\n=\n\n\nGreater than or equal to\n\n\n\n\n\n\n=\n\n\nLess than or equal to\n\n\n\n\n\n\n\n\nAnd\n\n\n\n\n\n\n||\n\n\nOr\n\n\n\n\n\n\n\n\nTo conditionally assign a value to a property of a component in \nBuilder\n:\n\n\n\n\nSelect the component in the Screen/Panel Editor.\n\n\nClick the \nData\n Tab from the right side of the editor\n\n\nFrom the \nSelect Property\n drop down, select the property of the component you want to apply the data to.\n\n\n\n\nFrom the \nSelect Source\n drop down for the property, select \nFilter: Conditional Data\n\n\n\n\n\n\n\n\nNext add at least one variable to use by clicking the \nWith data:\n link button\n\n\n\n\nFrom the \nEdit Data Link Values\n dialog, select the variable for the property and give it a name by editing the name field (In this example the variable is given the name \nuser\n), then click \nOK\n to close the dialog.\n\n\n\nAdd the conditional logic to the \nIF\n expression box.\n\n\n\n\n\n\nComparing String Values\n\n\nIf the variable to be evaluated is a string, single quotes should be used to delimit the variable and the string it is being compared to.\nExample:\n\n{{\nuser\n}}\n==\nRobert\n\n\n\n\n\n\nComparing Existence of a Variable\n\n\nTo evaluate whether or not a variable exists, use the keyword \nnull\n in the conditional.\nExample: \n{{\nuser\n}}\n==null\n\n\n\n\n\n\nComparing Boolean values\n\n\nTo evaluate if a boolean value is true or false, use the numbers 1 or 0 in place of the words \ntrue\n or \nfalse\n. Example: \n{{\nisconnected\n}}\n==1\n to determine if the variable \nisconnected\n is true\n\n\n\n\n\n\nFinally add the results to the \nTHEN\n and \nELSE\n value text fields. The value can be an filtered expression or just a simple value.\n\n\n\n\n\nAdvanced Filtering and Formatting\n\n\nIn addition to the basic concatenation of variables into a single value, filters can also be used to format data by applying math, string handling or date formatting. These advanced expressions can be used directly in filters or in conditionals.\n\n\nMath Expressions\n\n\nA math expression can be placed anywhere in a filtered data link or conditional string (if, then or else) to modify a value. Math expressions are delimited using \n%=\nexpression\n=%\n. Parenthesis can be used to group math expressions within the delimiters. Also the end result of the expression can be formatted using traditional c-style printf notation. The math expression handler expects numeric input for the value. Only a single math expression can be evaluated within a set of math expression delimiters, but the expression can contain multiple variables as needed.  The syntax for the expression follows general programming math notation. To create a math expression, use the format: \n%=\nformat,expression\n=%\n.\n\n\nExample Math Expression that converts a percent value:\n\n\n%={{pctusers}}*100=% \n\n\n\n\n\n\nExample Math Expression that uses two variables and output formatting to limit the result of the expression to a single decimal point:\n\n\nPct Users Online: %=%2.1f,\n{{\nnumusers\n}}\n/\n{{\ntotalusers\n}}\n*100=%%\n\n\n\n\n\n\n\n\nNote\n\n\nThe extra \n%\n at the end of this example is evaluated as a string and appended to the end of the result of the expression so that the value ends up something like \nPct Users Online: 80.1%\n\n\n\n\n Example Math Expression used in the IF part of a conditional:\n\n\n%=({{value}}/100)=%\n=1\n\n\n\n\n\n\nTimestamp Formatting\n\n\nTimestamp formatting can be applied to values that represent a timestamp value in either integer form (seconds since 1970), or as a string that uses one of the following formats:\n\n\nyyyy-MM-dd\nT\nHH:mm:ssZZZZZ\n\n\nyyyy-MM-dd\nT\nHH:mm:ss\n\n\nyyyyMMdd\nT\nHH:mm:ss\n\n\nTimestamp formatters are delimited using \n#=\nformat\n=#\n\n\nTo use the date formatting associated with a timestamp value, the property for the text component must be \ntimestamp\n.\n\n\n\n\nSelect the text component in the Screen/Panel Editor.\n\n\nClick the \nData\n Tab from the right side of the editor\n\n\nFrom the \nSelect Property\n drop down, select the \ntimestamp\n property of the text component you want to apply the data to.\n\n\nFrom the \nSelect Source\n drop down for the property, select \nFilter: Data Expression\n\n\nIn the \nExpression\n text field, enter the format for the date.\n\n\n\n\nExample Timestamp format:\n\n\n#=h:mm a MM/dd/yyyy=#\n\n\n\n\n\nWould produce the output: \n9\n:\n22\n \nAM\n \n10\n/23/\n2017\n\n\n\n\nNote\n\n\nThe format follows the unicode date formatting standard (\nclick here to see list of supported format values\n).\n\n\n\n\nString Functions\n\n\nAnother modifier for values are string functions. They allow for manipulating or evaluating string attributes. String functions are delimited using the format: \n[=\nfunc(value)\n=]\n\n\nSupported Functions\n\n\n\n\n\n\n\n\nFunction\n\n\nParameters\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntoupper\n\n\nstring\n\n\nconvert the entire string to upper case\n\n\n\n\n\n\ntolower\n\n\nstring\n\n\nconvert the entire string to lower case\n\n\n\n\n\n\nsubstr\n\n\nstring, integer\n\n\nextract a substring from the supplied string, the second parameter is the number of characters to extract\n\n\n\n\n\n\nstrlen\n\n\nstring\n\n\nreturns the length of the supplied string as an integer\n\n\n\n\n\n\nreplaceall\n\n\nstring, string value, string replace\n\n\nReplaces instances of the supplied value (2\nnd\n param) in the string (first param) with the replace value (3\nrd\n param)\nExample: replaceall(\"my fun and exciting example\", \"fun\", \"lame\") \u2192 output: \"my lame and exciting example\"\n\n\n\n\n\n\ncontains\n\n\nstring, string\n\n\nReturns a true/false result based on whether or not the string contains the 2\nnd\n parameter string. This function is case sensitive.\n\n\n\n\n\n\ncapfirst\n\n\nstring\n\n\nCapitalizes the first letter in the supplied string.\n\n\n\n\n\n\ncapall\n\n\nstring\n\n\nCapitalizes every word found in the string. Words are separated by space.\n\n\n\n\n\n\n\n\nExample String Function:\n\n\n[=toupper(\n{{\nuser\n}}\n)=] is online\n\n\n\n\n\n\nWould produce the output: \nROBERT is online\n\n\nLast Updated: Dec. 18, 2017", 
            "title": "Filters and Conditionals"
        }, 
        {
            "location": "/linking/filtersconditionals/#data-filters-and-conditionals", 
            "text": "Data linked to controls can be modified using a variety of filters or conditionals. Filters and conditionals can be provided directly in the assignment of data to a specific property on a control or as the result of a conditional.   Currently the  Builder  product doesn't have a special built editor for working with filters or formatters other than working directly with the P2UX format. This guide helps explain how to manually enter filters and conditionals.", 
            "title": "Data Filters and Conditionals"
        }, 
        {
            "location": "/linking/filtersconditionals/#filtering-data", 
            "text": "Filters can be used to apply math, formatting or just combine multiple values together to assign to a property of a component. In general, expressions, formatters and functions have specific delimiters used to indicate their use.   To filter a value applied to a property of a component in  Builder :   Select the component in the Screen/Panel Editor.  Click the  Data  Tab from the right side of the editor  From the  Select Property  drop down, select the property of the component you want to apply the data to.   From the  Select Source  drop down for the property, select  Filter: Data Expression     Next add at least one variable to use by clicking the  With data:  link button   From the  Edit Data Link Values  dialog, select the variable for the property and give it a name by editing the name field (In this example the variable is given the name  user ), then click  OK  to close the dialog.    Note  You can add more than one variable to the property and combine values in the filter or the conditional. Click the  Add Data Link  button to add another data link.    The expression is typed into the  Expression  text field. This particular example shows the  user  variable being combined with the  status  variable before being assigned to the  label  property of a Text component.    Example output would show:  user is offline .    Note  When creating a filter or conditional, variables are delimited using the notation  {{ name }} . Variables can be used without any specific expression syntax as well to just combine values together.", 
            "title": "Filtering Data"
        }, 
        {
            "location": "/linking/filtersconditionals/#conditional-data", 
            "text": "Conditionals can be used to change the resulting value by evaluating one or more variables and choosing a resulting value based on the outcome of the conditional evaluation. Just like with filters, conditionals refer to variables using the notation  {{ name }} .   Conditionals use the typical programming operators for comparison:     Operator  Description      ==  Equal to    !=  Not Equal to     Greater than     Less than    =  Greater than or equal to    =  Less than or equal to     And    ||  Or     To conditionally assign a value to a property of a component in  Builder :   Select the component in the Screen/Panel Editor.  Click the  Data  Tab from the right side of the editor  From the  Select Property  drop down, select the property of the component you want to apply the data to.   From the  Select Source  drop down for the property, select  Filter: Conditional Data     Next add at least one variable to use by clicking the  With data:  link button   From the  Edit Data Link Values  dialog, select the variable for the property and give it a name by editing the name field (In this example the variable is given the name  user ), then click  OK  to close the dialog.  Add the conditional logic to the  IF  expression box.    Comparing String Values  If the variable to be evaluated is a string, single quotes should be used to delimit the variable and the string it is being compared to.\nExample: {{ user }} == Robert    Comparing Existence of a Variable  To evaluate whether or not a variable exists, use the keyword  null  in the conditional.\nExample:  {{ user }} ==null    Comparing Boolean values  To evaluate if a boolean value is true or false, use the numbers 1 or 0 in place of the words  true  or  false . Example:  {{ isconnected }} ==1  to determine if the variable  isconnected  is true    Finally add the results to the  THEN  and  ELSE  value text fields. The value can be an filtered expression or just a simple value.", 
            "title": "Conditional Data"
        }, 
        {
            "location": "/linking/filtersconditionals/#advanced-filtering-and-formatting", 
            "text": "In addition to the basic concatenation of variables into a single value, filters can also be used to format data by applying math, string handling or date formatting. These advanced expressions can be used directly in filters or in conditionals.", 
            "title": "Advanced Filtering and Formatting"
        }, 
        {
            "location": "/linking/filtersconditionals/#math-expressions", 
            "text": "A math expression can be placed anywhere in a filtered data link or conditional string (if, then or else) to modify a value. Math expressions are delimited using  %= expression =% . Parenthesis can be used to group math expressions within the delimiters. Also the end result of the expression can be formatted using traditional c-style printf notation. The math expression handler expects numeric input for the value. Only a single math expression can be evaluated within a set of math expression delimiters, but the expression can contain multiple variables as needed.  The syntax for the expression follows general programming math notation. To create a math expression, use the format:  %= format,expression =% .  Example Math Expression that converts a percent value:  %={{pctusers}}*100=%    Example Math Expression that uses two variables and output formatting to limit the result of the expression to a single decimal point:  Pct Users Online: %=%2.1f, {{ numusers }} / {{ totalusers }} *100=%%    Note  The extra  %  at the end of this example is evaluated as a string and appended to the end of the result of the expression so that the value ends up something like  Pct Users Online: 80.1%    Example Math Expression used in the IF part of a conditional:  %=({{value}}/100)=% =1", 
            "title": "Math Expressions"
        }, 
        {
            "location": "/linking/filtersconditionals/#timestamp-formatting", 
            "text": "Timestamp formatting can be applied to values that represent a timestamp value in either integer form (seconds since 1970), or as a string that uses one of the following formats:  yyyy-MM-dd T HH:mm:ssZZZZZ  yyyy-MM-dd T HH:mm:ss  yyyyMMdd T HH:mm:ss  Timestamp formatters are delimited using  #= format =#  To use the date formatting associated with a timestamp value, the property for the text component must be  timestamp .   Select the text component in the Screen/Panel Editor.  Click the  Data  Tab from the right side of the editor  From the  Select Property  drop down, select the  timestamp  property of the text component you want to apply the data to.  From the  Select Source  drop down for the property, select  Filter: Data Expression  In the  Expression  text field, enter the format for the date.   Example Timestamp format:  #=h:mm a MM/dd/yyyy=#  Would produce the output:  9 : 22   AM   10 /23/ 2017   Note  The format follows the unicode date formatting standard ( click here to see list of supported format values ).", 
            "title": "Timestamp Formatting"
        }, 
        {
            "location": "/linking/filtersconditionals/#string-functions", 
            "text": "Another modifier for values are string functions. They allow for manipulating or evaluating string attributes. String functions are delimited using the format:  [= func(value) =]  Supported Functions     Function  Parameters  Description      toupper  string  convert the entire string to upper case    tolower  string  convert the entire string to lower case    substr  string, integer  extract a substring from the supplied string, the second parameter is the number of characters to extract    strlen  string  returns the length of the supplied string as an integer    replaceall  string, string value, string replace  Replaces instances of the supplied value (2 nd  param) in the string (first param) with the replace value (3 rd  param) Example: replaceall(\"my fun and exciting example\", \"fun\", \"lame\") \u2192 output: \"my lame and exciting example\"    contains  string, string  Returns a true/false result based on whether or not the string contains the 2 nd  parameter string. This function is case sensitive.    capfirst  string  Capitalizes the first letter in the supplied string.    capall  string  Capitalizes every word found in the string. Words are separated by space.     Example String Function:  [=toupper( {{ user }} )=] is online   Would produce the output:  ROBERT is online  Last Updated: Dec. 18, 2017", 
            "title": "String Functions"
        }, 
        {
            "location": "/datasources/overview/", 
            "text": "Introduction\n\n\nThe P2UX platform offers app creators the unique ability to go beyond simple prototyping by allowing them to integrate external data into their applications. Most importantly, this feature makes it possible to include information in the app that resides outside of the user interface. This data can then be \u201clinked\u201d to properties of the app\u2019s UI components to dynamically change the way the app looks or even works.\n\n\nExternal app data can come from a number of different sources. It may be statically bundled with the app. It may be data that are read and modified locally on the device while the app is running. It may even be obtained from an external source such as a web-based service.\n\n\nThe P2UX platform handles data-related features through the use of Data Sources. Data Sources provide a powerful mechanism that lets app creators model, bundle and access data within their app. Using P2UX, developers and designers can actively define how data will be represented in their user interfaces. For example, it is possible to make an app that integrates data from an external news feed. When the app runs it would request the list of stories from the feed and then link them to the content of a List Component in the UI. This content could, in turn, be used to display the headline and a short summary of the news story. All of this can be accomplished directly in the P2UX Builder visual design tool using Data Sources.\n\n\nP2UX includes three main types of Data Sources that can be defined and used in apps created with the design tool. These are: Static App Data for bundling data directly into the app, Local Device Databases for storing and retrieving data on the device during the running of the app and RESTful Web Services for requesting data from and submitting data to remote services. In addition, the platform employs some built-in Data Sources for integrating device data such as media information and location data. Finally, it is possible to create a custom Data Source in code that can be used in the same manner as the system supported ones. This feature makes it possible to integrate custom data, application functions or services that don\u2019t fit into one of the existing Data Source types.\n\n\nData Source Functionality\n\n\nMost apps will use one or more different Data Sources. For example, an app may use Static data to include some pre-defined set or sets of information. (These might be text for help messages or collections of color values for supporting UI themes.) An app could include a Local Database for storing and retrieving sets of user preferences. Finally, an app might access one or more RESTful Services if the app was, for instance, designed as a front-end to an online service, or if the app creator wanted to include information from third-party services such as Facebook, Twitter or Instagram.\n\n\nRequests\n\n\nP2UX allows app creators to retrieve information from a Data Source via a \u201crequest.\u201d\n \n\n\nA request specification defines how the data from a particular Data Source inquiry will be retrieved or updated. The request can also define arguments to be supplied to the data when the request is made. Additionally, the details of the request specification allow app creators to define whether retrieved data will persist on the device and for how long. \n\n\nApp creators should keep in mind that a Data Source can represent multiple collections of information. How the data are retrieved lies in the hands of the creator and in the details of the request specification. For a Static or Local Data Source, each data request maps directly to a different set of data. With a RESTful Data Source, requests are used to define queries or commands within the service.\n\n\nSchema\n\n\nRequests for data must conform to a specific structure. This structure is defined by use of a \u201cschema.\u201d\n\n\nAny data retrieved from a Data Source will be validated against a creator-defined schema. The P2UX Builder tool also uses the schema when linking parts of the requested data to component properties in the UI. The schema can also include filters and transformations for performing rudimentary changes to the data upon retrieval. These transformations can be simple changes in capitalization of strings or mathematical functions on numbers. They can also provide filtering or sorting of data in an Array.\n\n\nStatic Data Sources\n\n\nStatic Data Sources are a way to include pre-defined sets of data into your application.\n\n\nHow Static Data Works\n\n\nEach request to a Static Data Source includes the complete data for that particular request. However, the data may be \u201cparameterized,\u201d meaning that distinct sets of data can be retrieved depending on the supplied arguments in the request. \n\n\nCommon Uses\n\n\nApp creators frequently use Static data to provide a complex data set that can be queried by the application and, in turn, used to show results to the end user. Common examples of this include help data or catalogs. Another typical use for Static data is as a \u201cplaceholder\u201d model for other, more dynamic, sources of data accessed during the prototyping phase. \n\n\nLocal Data Sources\n\n\nLocal Data Sources work like a small database that resides on a particular device.\n\n\nHow Local Data Works\n\n\nThe creator can retrieve, replace, update or delete local data for a particular request by supplying commands as arguments to the request. (In some cases, an app creator may also include initial \u201cseed\u201d data in a request specification.) In the case of data based on an Array schema type, the request may include arguments for inserting, appending or removing an entry within the Array of data.\n\n\nMuch like app variables in the P2UX platform, changes to Local Data Source requests persist across multiple application runs. However, they provide a mechanism for the addition of more rich and flexible data types.\n\n\nCommon Uses\n\n\nA typical use for Local data is to store user preferences within an app. These might be stored based on user selections the first time the app runs and then retrieved and used on each subsequent invocation to retain the user\u2019s chosen settings. Another common use is for storing data while an app is offline in order to send it to a service at a later time.\n\n\nRESTful Data Sources\n\n\nRESTful Data Sources allow access to data provided by web-based services.\n\n\nHow RESTful Data Works\n\n\nA request within a RESTful Data Source models one of the standard REST method types (GET, PUT, POST, DELETE).  Currently the only supported format for RESTful data on the P2UX platform is JSON. \n\n\nDepending on the method type and the request specification, arguments to a REST request may serve to construct the URL for the request. The arguments may also act as query parameters or be included as \u201cpost\u201d data supplied in the body of the request. Numerous other options can be configured for a RESTful request, including mechanisms for retry and polling requests. \n\n\nCommon Uses\n\n\nFor an app that acts as the front-end UI to a service, a custom RESTful Data Source would be defined that included requests for all of the queries and operations of that service. These operations would then be linked to the app UI when, for example, submitting form-type data or displaying service information on a screen.\n\n\nThe Builder tool also features a number of pre-made RESTful Data Sources for use with common sites including Facebook, Twitter, Instagram and Google services.\n\n\nAuthentication\n\n\nOne key feature unique to RESTful Data Sources is their ability to require authentication.\n\n\nAuthentication allows for the integration of services that require credentialed access. Defined at the Data Source level, authentication works across all requests. However, specific aspects of authentication may be overridden on a per-request basis. P2UX recognizes three primary authentication methods: Basic, Login and OAuth (complying to the OAuth2 authorization protocol).\n\n\nBasic Authentication\n\n\nThis form of authentication supports the HTTP Basic Authentication protocol. The specification can include a username and password for testing, but typically this information would be embedded in custom business logic code. Using basic authentication methods will cause the \u201cAuthorization\u201d header to be included on each request.\n\n\nLogin Authentication\n\n\nLogin Authentication is for traditional user/password submission that uses an HTTP POST method for login. The fields used for login, as well as those returned in the response, can be customized via a schema. The developer would then supply the credentials for the login authentication via custom business logic. \n\n\nOnce login is completed, this method typically relies on session data (i.e. cookies) to retain the authorization. (An advantage of using session data is that the P2UX platform need not add anything additional to the request.)\n\n\nOAuth\n\n\nOauth is the most complex and flexible method of configuring authentication on a RESTful Data Source.\n\n\nThe OAuth method complies with the \nOAuth2 Standard\n. To be precise, OAuth is a collection of authentication methods each defined by a \u201cgrant type.\u201d The P2UX platform supports grant types of AuthCode, Password and Client. Each of these uses a different underlying mechanism to obtain an Authorization Token. The token is then sent along with the individual RESTful requests. With OAuth, client credentials such as \u201cclient id\u201d and \u201cclient secret\u201d are generally managed via static application values or custom business logic.\n\n\nAuthCode Grant Type\n\n\nAuthCode is the authorization grant type used primarily for third-party authorization.\n\n\nFor example, the AuthCode Grant Type would be used to integrate the Facebook API into your application. In such a case, P2UX will provide an embedded web-browser for that is directed to the facebook URL as supplied in the Data Source specification. The user will then authorize access to their Facebook account. Then, the platform re-directs an authorization code back to the application for obtaining the Authorization Token.\n\n\nClient Grant Type\n\n\nClient Grant Type uses a supplied client id and client secret to authorize application access to the service and obtain the Authorization Token.\n\n\nGenerally, Client Grant Type is used to access public APIs or public portions of APIs where the application makes queries directly, rather than on behalf of any user. \n\n\nPassword Grant Type\n\n\nPassword Grant Type provides a way to directly authenticate a user via username and password to acquire the Authorization Token.\n\n\nThis grant type allows authorization of the client application as well. Depending on the services involved, these credentials may be embedded in the custom business logic or they may be obtained via P2UX UI elements that are designed to fit directly into the app\u2019s user interface.", 
            "title": "Overview"
        }, 
        {
            "location": "/datasources/overview/#introduction", 
            "text": "The P2UX platform offers app creators the unique ability to go beyond simple prototyping by allowing them to integrate external data into their applications. Most importantly, this feature makes it possible to include information in the app that resides outside of the user interface. This data can then be \u201clinked\u201d to properties of the app\u2019s UI components to dynamically change the way the app looks or even works.  External app data can come from a number of different sources. It may be statically bundled with the app. It may be data that are read and modified locally on the device while the app is running. It may even be obtained from an external source such as a web-based service.  The P2UX platform handles data-related features through the use of Data Sources. Data Sources provide a powerful mechanism that lets app creators model, bundle and access data within their app. Using P2UX, developers and designers can actively define how data will be represented in their user interfaces. For example, it is possible to make an app that integrates data from an external news feed. When the app runs it would request the list of stories from the feed and then link them to the content of a List Component in the UI. This content could, in turn, be used to display the headline and a short summary of the news story. All of this can be accomplished directly in the P2UX Builder visual design tool using Data Sources.  P2UX includes three main types of Data Sources that can be defined and used in apps created with the design tool. These are: Static App Data for bundling data directly into the app, Local Device Databases for storing and retrieving data on the device during the running of the app and RESTful Web Services for requesting data from and submitting data to remote services. In addition, the platform employs some built-in Data Sources for integrating device data such as media information and location data. Finally, it is possible to create a custom Data Source in code that can be used in the same manner as the system supported ones. This feature makes it possible to integrate custom data, application functions or services that don\u2019t fit into one of the existing Data Source types.", 
            "title": "Introduction"
        }, 
        {
            "location": "/datasources/overview/#data-source-functionality", 
            "text": "Most apps will use one or more different Data Sources. For example, an app may use Static data to include some pre-defined set or sets of information. (These might be text for help messages or collections of color values for supporting UI themes.) An app could include a Local Database for storing and retrieving sets of user preferences. Finally, an app might access one or more RESTful Services if the app was, for instance, designed as a front-end to an online service, or if the app creator wanted to include information from third-party services such as Facebook, Twitter or Instagram.", 
            "title": "Data Source Functionality"
        }, 
        {
            "location": "/datasources/overview/#requests", 
            "text": "P2UX allows app creators to retrieve information from a Data Source via a \u201crequest.\u201d    A request specification defines how the data from a particular Data Source inquiry will be retrieved or updated. The request can also define arguments to be supplied to the data when the request is made. Additionally, the details of the request specification allow app creators to define whether retrieved data will persist on the device and for how long.   App creators should keep in mind that a Data Source can represent multiple collections of information. How the data are retrieved lies in the hands of the creator and in the details of the request specification. For a Static or Local Data Source, each data request maps directly to a different set of data. With a RESTful Data Source, requests are used to define queries or commands within the service.", 
            "title": "Requests"
        }, 
        {
            "location": "/datasources/overview/#schema", 
            "text": "Requests for data must conform to a specific structure. This structure is defined by use of a \u201cschema.\u201d  Any data retrieved from a Data Source will be validated against a creator-defined schema. The P2UX Builder tool also uses the schema when linking parts of the requested data to component properties in the UI. The schema can also include filters and transformations for performing rudimentary changes to the data upon retrieval. These transformations can be simple changes in capitalization of strings or mathematical functions on numbers. They can also provide filtering or sorting of data in an Array.", 
            "title": "Schema"
        }, 
        {
            "location": "/datasources/overview/#static-data-sources", 
            "text": "Static Data Sources are a way to include pre-defined sets of data into your application.", 
            "title": "Static Data Sources"
        }, 
        {
            "location": "/datasources/overview/#how-static-data-works", 
            "text": "Each request to a Static Data Source includes the complete data for that particular request. However, the data may be \u201cparameterized,\u201d meaning that distinct sets of data can be retrieved depending on the supplied arguments in the request.", 
            "title": "How Static Data Works"
        }, 
        {
            "location": "/datasources/overview/#common-uses", 
            "text": "App creators frequently use Static data to provide a complex data set that can be queried by the application and, in turn, used to show results to the end user. Common examples of this include help data or catalogs. Another typical use for Static data is as a \u201cplaceholder\u201d model for other, more dynamic, sources of data accessed during the prototyping phase.", 
            "title": "Common Uses"
        }, 
        {
            "location": "/datasources/overview/#local-data-sources", 
            "text": "Local Data Sources work like a small database that resides on a particular device.", 
            "title": "Local Data Sources"
        }, 
        {
            "location": "/datasources/overview/#how-local-data-works", 
            "text": "The creator can retrieve, replace, update or delete local data for a particular request by supplying commands as arguments to the request. (In some cases, an app creator may also include initial \u201cseed\u201d data in a request specification.) In the case of data based on an Array schema type, the request may include arguments for inserting, appending or removing an entry within the Array of data.  Much like app variables in the P2UX platform, changes to Local Data Source requests persist across multiple application runs. However, they provide a mechanism for the addition of more rich and flexible data types.", 
            "title": "How Local Data Works"
        }, 
        {
            "location": "/datasources/overview/#common-uses_1", 
            "text": "A typical use for Local data is to store user preferences within an app. These might be stored based on user selections the first time the app runs and then retrieved and used on each subsequent invocation to retain the user\u2019s chosen settings. Another common use is for storing data while an app is offline in order to send it to a service at a later time.", 
            "title": "Common Uses"
        }, 
        {
            "location": "/datasources/overview/#restful-data-sources", 
            "text": "RESTful Data Sources allow access to data provided by web-based services.", 
            "title": "RESTful Data Sources"
        }, 
        {
            "location": "/datasources/overview/#how-restful-data-works", 
            "text": "A request within a RESTful Data Source models one of the standard REST method types (GET, PUT, POST, DELETE).  Currently the only supported format for RESTful data on the P2UX platform is JSON.   Depending on the method type and the request specification, arguments to a REST request may serve to construct the URL for the request. The arguments may also act as query parameters or be included as \u201cpost\u201d data supplied in the body of the request. Numerous other options can be configured for a RESTful request, including mechanisms for retry and polling requests.", 
            "title": "How RESTful Data Works"
        }, 
        {
            "location": "/datasources/overview/#common-uses_2", 
            "text": "For an app that acts as the front-end UI to a service, a custom RESTful Data Source would be defined that included requests for all of the queries and operations of that service. These operations would then be linked to the app UI when, for example, submitting form-type data or displaying service information on a screen.  The Builder tool also features a number of pre-made RESTful Data Sources for use with common sites including Facebook, Twitter, Instagram and Google services.", 
            "title": "Common Uses"
        }, 
        {
            "location": "/datasources/overview/#authentication", 
            "text": "One key feature unique to RESTful Data Sources is their ability to require authentication.  Authentication allows for the integration of services that require credentialed access. Defined at the Data Source level, authentication works across all requests. However, specific aspects of authentication may be overridden on a per-request basis. P2UX recognizes three primary authentication methods: Basic, Login and OAuth (complying to the OAuth2 authorization protocol).", 
            "title": "Authentication"
        }, 
        {
            "location": "/datasources/overview/#basic-authentication", 
            "text": "This form of authentication supports the HTTP Basic Authentication protocol. The specification can include a username and password for testing, but typically this information would be embedded in custom business logic code. Using basic authentication methods will cause the \u201cAuthorization\u201d header to be included on each request.", 
            "title": "Basic Authentication"
        }, 
        {
            "location": "/datasources/overview/#login-authentication", 
            "text": "Login Authentication is for traditional user/password submission that uses an HTTP POST method for login. The fields used for login, as well as those returned in the response, can be customized via a schema. The developer would then supply the credentials for the login authentication via custom business logic.   Once login is completed, this method typically relies on session data (i.e. cookies) to retain the authorization. (An advantage of using session data is that the P2UX platform need not add anything additional to the request.)", 
            "title": "Login Authentication"
        }, 
        {
            "location": "/datasources/overview/#oauth", 
            "text": "Oauth is the most complex and flexible method of configuring authentication on a RESTful Data Source.  The OAuth method complies with the  OAuth2 Standard . To be precise, OAuth is a collection of authentication methods each defined by a \u201cgrant type.\u201d The P2UX platform supports grant types of AuthCode, Password and Client. Each of these uses a different underlying mechanism to obtain an Authorization Token. The token is then sent along with the individual RESTful requests. With OAuth, client credentials such as \u201cclient id\u201d and \u201cclient secret\u201d are generally managed via static application values or custom business logic.", 
            "title": "OAuth"
        }, 
        {
            "location": "/datasources/overview/#authcode-grant-type", 
            "text": "AuthCode is the authorization grant type used primarily for third-party authorization.  For example, the AuthCode Grant Type would be used to integrate the Facebook API into your application. In such a case, P2UX will provide an embedded web-browser for that is directed to the facebook URL as supplied in the Data Source specification. The user will then authorize access to their Facebook account. Then, the platform re-directs an authorization code back to the application for obtaining the Authorization Token.", 
            "title": "AuthCode Grant Type"
        }, 
        {
            "location": "/datasources/overview/#client-grant-type", 
            "text": "Client Grant Type uses a supplied client id and client secret to authorize application access to the service and obtain the Authorization Token.  Generally, Client Grant Type is used to access public APIs or public portions of APIs where the application makes queries directly, rather than on behalf of any user.", 
            "title": "Client Grant Type"
        }, 
        {
            "location": "/datasources/overview/#password-grant-type", 
            "text": "Password Grant Type provides a way to directly authenticate a user via username and password to acquire the Authorization Token.  This grant type allows authorization of the client application as well. Depending on the services involved, these credentials may be embedded in the custom business logic or they may be obtained via P2UX UI elements that are designed to fit directly into the app\u2019s user interface.", 
            "title": "Password Grant Type"
        }, 
        {
            "location": "/datasources/datasource/", 
            "text": "Data Sources\n\n\nData Sources are collections of data that can be served from a variety of sources. P2UX Data Sources provide a consistent interface for accessing data and allows the data to be used directly in UI. It can also be parameterized using arguments for query purposes. \n\n\nData Sources consist of a JSON specification defining the requests and the structure of the data for the request as well as an implementation in code for the specific client rendering libraries. \n\n\nTypes of Sources\n\n\nP2UX provides a number of sources that can be used via \nBuilder\n without having to write any code on either of the respective client platforms.\n\n\n\n\nStatic Data\n\n\nLocal Data\n\n\nRESTful Data\n\n\n\n\nIn addition to these basic data sources, developers can provide custom sources of data in code by wrapping the data functionality in the P2UXDataSource protocol.\n\n\n\n\nNote\n\n\nAs of the last version of this document, the specification for Data Sources can only be defined using a JSON editor in \nBuilder\n. It is assumed that the reader understands the basics of JSON structure to be able to edit the data source. A better targeted Data Source editor is being developed to make creation of Data Sources simpiler. \n\n\n\n\nData Source Specification\n\n\nAll Data Sources in P2UX have a specification (based on JSON) that is defined as part of the application in \nBuilder\n. The specification defines the Data Source's unique identifier and name, the type of data source and the requests that are used by the application to access the data.\n\n\nBasic Attributes\n\n\n\n\n\n\n\n\nAttribute\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nname\n\n\nObject\n\n\nThe localized name of the data source.\n\n\n\n\n\n\ntype\n\n\nString\n\n\nThe type of the data source. The basic types provided by P2UX are:\nLOCAL, STATIC, REST\nFor custom data sources, create a unique type value. This value is used to represent the class instance to be created in the client renderer.\nExample: \nMQTT\n\n\n\n\n\n\nsystemtype\n\n\nString\n\n\nThe system name for the data source. This is the value that is used by the rendering library to identify the data source for data linking. When a Data Source is duplicated, this value will not change so that the P2UX rendering libraries can still identify the Data Source for data linking and events.\n\n\n\n\n\n\nrequests\n\n\nObject\n\n\nThe requests for the data source. The key is the identifier of the request. \nSee Requests Objects Attributes\n for more details on the Request object contents.\n\n\n\n\n\n\ninitdata\n\n\nObject\n\n\n(OPTIONAL) - Object that defines global data necessary either across all requests or to be utilized before any requests are made. The format of this is specific to the type of the data source.\n\n\n\n\n\n\ndescription\n\n\nObject\n\n\n(OPTIONAL) - The localized description of the data source.\n\n\n\n\n\n\n\n\nRequests Object Attributes\n\n\nEach key in the \nrequests\n object represents the name for a particular request within the datasource. The associated value is itself an object consisting of a \nrequest\n object and a \nschema\n object. \n\n\n\n\n\n\n\n\nAttribute\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nschema\n\n\nObject\n\n\nThe schema that defines the structure of the request data.\n\n\n\n\n\n\nrequest\n\n\nObject\n\n\nThe request contains attributes defining details of the request. The attributes supported are specific to the request type. See \nRequst Object Attributes\n\n\n\n\n\n\n\n\nRequest Object Attributes\n\n\nThe \nrequest\n object contains information about how to fulfill the request and persist the results for the request in the app. \n\n\n\n\n\n\n\n\nAttribute\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nattributes\n\n\nObject\n\n\n(OPTIONAL) - This object consists of configuration attributes for the request and it's returned data.\n\n\n\n\n\n\nversion\n\n\nInteger\n\n\n(OPTIONAL) - This is the version number for this request. if it is missing then it is assumed to be 0. The version number is used to indicate an incompatible change to a request such as a change in schema structure. When this number is modified it effectively invalidates any persisted results for the request causing new requests to act as if it is being made for the first time.\n\n\n\n\n\n\nformat\n\n\nString\n\n\n(OPTIONAL) - This is string indicating the format of data for the request. Currently only \"JSON\" is supported. This is the default if the attribute is not specified.\n\n\n\n\n\n\nargs\n\n\nObject\n\n\n(OPTIONAL) - Each attribute in this object represents a parameter to be passed to the request along with its associated value. These args are merged with (or overridden by) parameters specified at the time the request is made either via an event action or a data link. Details of how the parameters are processed is determined by the specific type of datasource.\n\n\n\n\n\n\n\n\nSchema Object\n\n\nThe \nschema\n object specifies the structure and type of data returned that the request returns.\n\n\nEvery item in the schema is an object that has at least a \ntype\n and if its an \nObject\n or an \nArray\n, it requires an \nitem\n that defines the details of the item.\n\n\nSupported Types:\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nNumber\n\n\nAn integer or a float value\n\n\n\n\n\n\nString\n\n\nA string value\n\n\n\n\n\n\nDate\n\n\nRepresents a timestamp as an integer value representing the seconds since January 1 1970.\nIt can also be a string in the following formats:\nyyyy-MM-dd\nT\nHH:mm:ssZZZZZ\nyyyy-MM-dd\nT\nHH:mm:ss\nyyyyMMdd\nT\nHH:mm:ss\n\n\n\n\n\n\nObject\n\n\nAn object made up of key / value items.\n\n\n\n\n\n\nArray\n\n\nAn array of items. Arrays support an additional attribute \nindex\n value that can be used to list the field of the object in the array that represents the index value of the object.\n\n\n\n\n\n\n\n\nExample Schema: \n\n\n  \nschema\n: {\n    \ntype\n: \nArray\n,\n    \nindex\n: \nident\n,\n    \nitem\n: {\n      \ntype\n: \nObject\n,\n      \nitem\n: {\n        \nident\n: {\n          \ntype\n: \nString\n\n        },\n        \nfirstname\n: {\n          \ntype\n: \nString\n\n        },\n        \nlastname\n: {\n          \ntype\n: \nString\n\n        },\n        \nemail\n: {\n          \ntype\n: \nString\n\n        }\n      }\n    }\n  }\n\n\n\n\n\nMatching Data:\n\n\n[\n  {\n    \nident\n:\ndd1b366e-d619-4d8c-a9d0-201868744f6a\n,\n    \nfirstname\n:\nJoe\n,\n    \nlastname\n:\nSnow\n,\n    \nemail\n:\njoe.snow@mail.org\n\n  },\n  {\n    \nident\n:\na5fd4f0a-baba-4a9b-b278-8894a7385d61\n,\n    \nfirstname\n:\nJane\n,\n    \nlastname\n:\nDoe\n,\n    \nemail\n:\njane.doe@mail.org\n\n  }\n]\n\n\n\n\n\nCreating Data Sources\n\n\nBuilder\n has a basic JSON interface (as of this article's writing), that allows for creation of a Data Source. The Data Source specification is separated into logical requests. Each request has a schema that defines the data structure and request parameters.\n\n\nTo Create a new Data Source in \nBuilder\n:\n\n\n\n\nMake sure you are in the Application or Screen/Panel Editor for your application.\n\n\nClick on the Data Source Icon from the top tool bar\n\n\n\n\nIn the \nManage Data\n dialog, click the \n+\n button to create a new data source.\n\n\nFrom the \nAdd Data Source\n dialog, click the \n+\n to the right of the \nSelect Data Source\n drop down.\n\n\nIn the \nNew Data Source\n dialog, type in a name for the data source and then select the type of Data Source to create from the \nSelect Type\n drop down.\n\n\n\nClick \nOK\n to save the new data source.\n\n\n\n\nThe newly created data source is now part of the application.\nBuilder\n will create the basic entries needed for the Data Source. It is up to the user to create the specific \nrequests\n that define the data repository. \n\n\nCreating a Request\n\n\nOnce a Data Source has been created, \nrequests\n can be added that represent logical repositories of data. Each request requires a \nschema\n and a \nrequest\n object that define the request details. The \nschema\n object defines the structure of the data. The \nrequest\n object defines the version of the request schema and any other attributes about the request (See Data Source Requests for more information). The details of the \nrequest\n object for the different types of Data Sources can be found in the documentation for those specific Data Source types.\n\n\nTo Create a new Request in \nBuilder\n:\n\n\n\n\nMake sure you are in the Application or Screen/Panel Editor\n\n\nClick on the Data Source Icon from the top tool bar\n\n\n\n\nIn the \nManage Data\n dialog, click the \nedit\n button overlay (or double click) on the Data Source from the list.\n\n\n\n\nIn the \nEdit JSON\n dialog, there will be a JSON node named \nrequests\n.\n\n\nCreate a new key under the requests object that is the name of the request. The object associated with the key will contain the \nschema\n and the \nrequest\n attributes.\n\n\nLast Updated: Jan. 2, 2018", 
            "title": "Basic Data Sources"
        }, 
        {
            "location": "/datasources/datasource/#data-sources", 
            "text": "Data Sources are collections of data that can be served from a variety of sources. P2UX Data Sources provide a consistent interface for accessing data and allows the data to be used directly in UI. It can also be parameterized using arguments for query purposes.   Data Sources consist of a JSON specification defining the requests and the structure of the data for the request as well as an implementation in code for the specific client rendering libraries.", 
            "title": "Data Sources"
        }, 
        {
            "location": "/datasources/datasource/#types-of-sources", 
            "text": "P2UX provides a number of sources that can be used via  Builder  without having to write any code on either of the respective client platforms.   Static Data  Local Data  RESTful Data   In addition to these basic data sources, developers can provide custom sources of data in code by wrapping the data functionality in the P2UXDataSource protocol.   Note  As of the last version of this document, the specification for Data Sources can only be defined using a JSON editor in  Builder . It is assumed that the reader understands the basics of JSON structure to be able to edit the data source. A better targeted Data Source editor is being developed to make creation of Data Sources simpiler.", 
            "title": "Types of Sources"
        }, 
        {
            "location": "/datasources/datasource/#data-source-specification", 
            "text": "All Data Sources in P2UX have a specification (based on JSON) that is defined as part of the application in  Builder . The specification defines the Data Source's unique identifier and name, the type of data source and the requests that are used by the application to access the data.", 
            "title": "Data Source Specification"
        }, 
        {
            "location": "/datasources/datasource/#basic-attributes", 
            "text": "Attribute  Type  Description      name  Object  The localized name of the data source.    type  String  The type of the data source. The basic types provided by P2UX are: LOCAL, STATIC, REST For custom data sources, create a unique type value. This value is used to represent the class instance to be created in the client renderer. Example:  MQTT    systemtype  String  The system name for the data source. This is the value that is used by the rendering library to identify the data source for data linking. When a Data Source is duplicated, this value will not change so that the P2UX rendering libraries can still identify the Data Source for data linking and events.    requests  Object  The requests for the data source. The key is the identifier of the request.  See Requests Objects Attributes  for more details on the Request object contents.    initdata  Object  (OPTIONAL) - Object that defines global data necessary either across all requests or to be utilized before any requests are made. The format of this is specific to the type of the data source.    description  Object  (OPTIONAL) - The localized description of the data source.", 
            "title": "Basic Attributes"
        }, 
        {
            "location": "/datasources/datasource/#requests-object-attributes", 
            "text": "Each key in the  requests  object represents the name for a particular request within the datasource. The associated value is itself an object consisting of a  request  object and a  schema  object.      Attribute  Type  Description      schema  Object  The schema that defines the structure of the request data.    request  Object  The request contains attributes defining details of the request. The attributes supported are specific to the request type. See  Requst Object Attributes", 
            "title": "Requests Object Attributes"
        }, 
        {
            "location": "/datasources/datasource/#request-object-attributes", 
            "text": "The  request  object contains information about how to fulfill the request and persist the results for the request in the app.      Attribute  Type  Description      attributes  Object  (OPTIONAL) - This object consists of configuration attributes for the request and it's returned data.    version  Integer  (OPTIONAL) - This is the version number for this request. if it is missing then it is assumed to be 0. The version number is used to indicate an incompatible change to a request such as a change in schema structure. When this number is modified it effectively invalidates any persisted results for the request causing new requests to act as if it is being made for the first time.    format  String  (OPTIONAL) - This is string indicating the format of data for the request. Currently only \"JSON\" is supported. This is the default if the attribute is not specified.    args  Object  (OPTIONAL) - Each attribute in this object represents a parameter to be passed to the request along with its associated value. These args are merged with (or overridden by) parameters specified at the time the request is made either via an event action or a data link. Details of how the parameters are processed is determined by the specific type of datasource.", 
            "title": "Request Object Attributes"
        }, 
        {
            "location": "/datasources/datasource/#schema-object", 
            "text": "The  schema  object specifies the structure and type of data returned that the request returns.  Every item in the schema is an object that has at least a  type  and if its an  Object  or an  Array , it requires an  item  that defines the details of the item.  Supported Types:     Type  Description      Number  An integer or a float value    String  A string value    Date  Represents a timestamp as an integer value representing the seconds since January 1 1970. It can also be a string in the following formats: yyyy-MM-dd T HH:mm:ssZZZZZ yyyy-MM-dd T HH:mm:ss yyyyMMdd T HH:mm:ss    Object  An object made up of key / value items.    Array  An array of items. Arrays support an additional attribute  index  value that can be used to list the field of the object in the array that represents the index value of the object.     Example Schema:      schema : {\n     type :  Array ,\n     index :  ident ,\n     item : {\n       type :  Object ,\n       item : {\n         ident : {\n           type :  String \n        },\n         firstname : {\n           type :  String \n        },\n         lastname : {\n           type :  String \n        },\n         email : {\n           type :  String \n        }\n      }\n    }\n  }  Matching Data:  [\n  {\n     ident : dd1b366e-d619-4d8c-a9d0-201868744f6a ,\n     firstname : Joe ,\n     lastname : Snow ,\n     email : joe.snow@mail.org \n  },\n  {\n     ident : a5fd4f0a-baba-4a9b-b278-8894a7385d61 ,\n     firstname : Jane ,\n     lastname : Doe ,\n     email : jane.doe@mail.org \n  }\n]", 
            "title": "Schema Object"
        }, 
        {
            "location": "/datasources/datasource/#creating-data-sources", 
            "text": "Builder  has a basic JSON interface (as of this article's writing), that allows for creation of a Data Source. The Data Source specification is separated into logical requests. Each request has a schema that defines the data structure and request parameters.  To Create a new Data Source in  Builder :   Make sure you are in the Application or Screen/Panel Editor for your application.  Click on the Data Source Icon from the top tool bar   In the  Manage Data  dialog, click the  +  button to create a new data source.  From the  Add Data Source  dialog, click the  +  to the right of the  Select Data Source  drop down.  In the  New Data Source  dialog, type in a name for the data source and then select the type of Data Source to create from the  Select Type  drop down.  Click  OK  to save the new data source.   The newly created data source is now part of the application. Builder  will create the basic entries needed for the Data Source. It is up to the user to create the specific  requests  that define the data repository.", 
            "title": "Creating Data Sources"
        }, 
        {
            "location": "/datasources/datasource/#creating-a-request", 
            "text": "Once a Data Source has been created,  requests  can be added that represent logical repositories of data. Each request requires a  schema  and a  request  object that define the request details. The  schema  object defines the structure of the data. The  request  object defines the version of the request schema and any other attributes about the request (See Data Source Requests for more information). The details of the  request  object for the different types of Data Sources can be found in the documentation for those specific Data Source types.  To Create a new Request in  Builder :   Make sure you are in the Application or Screen/Panel Editor  Click on the Data Source Icon from the top tool bar   In the  Manage Data  dialog, click the  edit  button overlay (or double click) on the Data Source from the list.   In the  Edit JSON  dialog, there will be a JSON node named  requests .  Create a new key under the requests object that is the name of the request. The object associated with the key will contain the  schema  and the  request  attributes.  Last Updated: Jan. 2, 2018", 
            "title": "Creating a Request"
        }, 
        {
            "location": "/datasources/staticdatasource/", 
            "text": "Static Data Sources\n\n\nStatic Data Sources are repositories of data that are bundled into the application as a read-only resource. Since it follows the standard Data Source protocol, data from the repository can be used directly in UI and can also be parameterized using arguments for query purposes. Think of it as a catalog of data available to your application. \n\n\n\n\nNote\n\n\nAs of the last version of this document, Data Sources can only be defined using a JSON editor. It is assumed that the reader understands the basics of JSON structure to be able to edit the data source. A better targeted Data Source editor is being developed to make creation of Data Sources simpiler. \n\n\n\n\nRequest Object Attributes\n\n\nIn addition to the standard \nRequest Object Attributes\n provided by Data Sources, Static Data Sources have additional attributes used for data and parameters.\n\n\n\n\n\n\n\n\nAttribute\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndata\n\n\nmixed\n\n\nThis item defines the actual data returned by the request when there are no parameters provided. The data type depends on the \nschema\n for the request.\n\n\n\n\n\n\n\n\nBasic Data Request\n\n\nThis example shows a request with basic data. The request is called \ninfo\n in a data source named \nInternal Data\n. The \ndata\n object in the request defines the data that will be returned when the request is called. \n\n\nThis particular example request contains an object that defines information about a fictitious business. \n\n\n{\n  \nname\n: {\n    \nen_US\n: \nInternal Data\n\n  },\n  \ntype\n: \nSTATIC\n,\n  \nsystemtype\n: \ninternal_data\n,\n  \nrequests\n: {\n\n    \ninfo\n: {\n\n      \nschema\n: {\n        \ntype\n: \nObject\n,\n        \nitem\n: {\n          \nopentime\n: {\n            \ntype\n: \nString\n\n          },\n          \nclosetime\n: {\n            \ntype\n: \nString\n\n          },\n          \nphonenum\n: {\n            \ntype\n: \nString\n\n          },\n          \naddress\n: {\n            \ntype\n: \nString\n\n          },\n          \nstate\n:{\n            \ntype\n:\nString\n\n          },\n          \ncity\n:{\n            \ntype\n:\nString\n\n          }\n        }\n      },\n      \nrequest\n: {\n        \ndata\n: {\n          \naddress\n:\n1234 Somewhere St.\n,\n          \ncity\n:\nSanta Clara\n,\n          \nstate\n:\nCA\n,\n          \nphonenum\n:\n555-555-5555\n,\n          \nclosetime\n:\n7:00pm\n,\n          \nopentime\n:\n9:30am\n\n        }\n      }\n    }\n  }\n}\n\n\n\n\n\nParameterized Data Request\n\n\nStatic data can also include arguments to create queryable data. Parameterized data is defined in a \nparamdata\n object in the request. When arguments are provided to the request, the data is found by matching the arguments provided with the key value in the \nparamdata\n. The other required object definition is a \nparams\n array that has objects defining each of the parameters to the request.\n\n\n\n\nNote\n\n\nA request can have both default unparameterized as well as parameterized data.\n\n\n\n\nRequest Object Attributes for Parameterized Data\n\n\nThe following attributes are additional Request Object Attributes that are part of the \nrequest\n object definition for parameterized data:\n\n\n\n\n\n\n\n\nAttribute\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nparams\n\n\nArray\n\n\nAn array of objects that define each parameter available to the request. \n(See Params Array Object for more Information)\n\n\n\n\n\n\nparamdata\n\n\nObject\n\n\nAn object that defines each possible parameter value and its associated \ndata\n. The \ndata\n item beneath each parameter value follows the \ndata\n definition for default data\n\n\n\n\n\n\n\n\nParams Array Object\n\n\nEach item in the Params array for a request follow this structure:\n\n\n\n\n\n\n\n\nAttribute\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nname\n\n\nString\n\n\nThe name of the parameter. This is the only required item in the specification\n\n\n\n\n\n\nrequired\n\n\nBoolean\n\n\n(OPTIONAL) - Whether or not this parameter item is required to be provided by the requestor. If it is required, and the parameter is not supplied, the request will not complete successfully\n\n\n\n\n\n\ndefault\n\n\nString\n\n\n(OPTIONAL) - An default value to use if the parameter is not supplied as part of the request.\n\n\n\n\n\n\n\n\nBelow is an Example of a request called \ncolors\n in a data source named \nInternal Data\n. The argument to the request is named \ncolor\n which is the color name and the results are color values. \nparams\n defines the parameter \ncolor\n. The \nparamdata\n object defines the results for the primary argument \ncolor\n and each possible argument value for \ncolor\n (\nblue\n \n \nred\n)\n\n\n{\n  \nname\n: {\n    \nen_US\n: \nInternal Data\n\n  },\n  \ntype\n: \nSTATIC\n,\n  \nsystemtype\n: \ninternal_data\n,\n  \nrequests\n: {\n    \ncolors\n: {\n      \nschema\n: {\n        \ntype\n: \nObject\n,\n        \nitem\n: {\n          \ncolor\n: {\n            \ntype\n: \nString\n\n          },\n          \nname\n:{\n            \n*\n:\nString\n\n          }\n        }\n      },\n      \nrequest\n: {\n        \ndata\n: {\n          \ncolor\n:\n#ffffff\n,\n          \nname\n:{\n            \nen_US\n:\nDefault\n\n          }\n        },\n        \nparams\n:[\n          {\n            \nname\n:\ncolor\n\n           }\n        ],\n        \nparamdata\n:{\n          \ncolor\n:{\n            \nblue\n:{\n              \ndata\n:{\n                \ncolor\n:\n#0000ff\n,\n                \nname\n:{\n                  \nen_US\n:\nBlue\n,\n                  \nde_DE\n:\nBlau\n\n                }\n              }\n            },\n            \nred\n:{\n              \ndata\n:{\n                \ncolor\n:\n#ff0000\n,\n                \nname\n:{\n                  \nen_US\n:\nRed\n,\n                  \nde_DE\n:\nRot\n\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\n\n\n\n\n\n\nCreating a New Data Source\n\n\nFor Steps to create a new Data Source in \nBuilder\n, refer to the \nData Sources\n documentation\n\n\n\n\nLast Updated: Jan. 2, 2018", 
            "title": "Static Data"
        }, 
        {
            "location": "/datasources/staticdatasource/#static-data-sources", 
            "text": "Static Data Sources are repositories of data that are bundled into the application as a read-only resource. Since it follows the standard Data Source protocol, data from the repository can be used directly in UI and can also be parameterized using arguments for query purposes. Think of it as a catalog of data available to your application.    Note  As of the last version of this document, Data Sources can only be defined using a JSON editor. It is assumed that the reader understands the basics of JSON structure to be able to edit the data source. A better targeted Data Source editor is being developed to make creation of Data Sources simpiler.", 
            "title": "Static Data Sources"
        }, 
        {
            "location": "/datasources/staticdatasource/#request-object-attributes", 
            "text": "In addition to the standard  Request Object Attributes  provided by Data Sources, Static Data Sources have additional attributes used for data and parameters.     Attribute  Type  Description      data  mixed  This item defines the actual data returned by the request when there are no parameters provided. The data type depends on the  schema  for the request.", 
            "title": "Request Object Attributes"
        }, 
        {
            "location": "/datasources/staticdatasource/#basic-data-request", 
            "text": "This example shows a request with basic data. The request is called  info  in a data source named  Internal Data . The  data  object in the request defines the data that will be returned when the request is called.   This particular example request contains an object that defines information about a fictitious business.   {\n   name : {\n     en_US :  Internal Data \n  },\n   type :  STATIC ,\n   systemtype :  internal_data ,\n   requests : {      info : {        schema : {\n         type :  Object ,\n         item : {\n           opentime : {\n             type :  String \n          },\n           closetime : {\n             type :  String \n          },\n           phonenum : {\n             type :  String \n          },\n           address : {\n             type :  String \n          },\n           state :{\n             type : String \n          },\n           city :{\n             type : String \n          }\n        }\n      },\n       request : {\n         data : {\n           address : 1234 Somewhere St. ,\n           city : Santa Clara ,\n           state : CA ,\n           phonenum : 555-555-5555 ,\n           closetime : 7:00pm ,\n           opentime : 9:30am \n        }\n      }\n    }\n  }\n}", 
            "title": "Basic Data Request"
        }, 
        {
            "location": "/datasources/staticdatasource/#parameterized-data-request", 
            "text": "Static data can also include arguments to create queryable data. Parameterized data is defined in a  paramdata  object in the request. When arguments are provided to the request, the data is found by matching the arguments provided with the key value in the  paramdata . The other required object definition is a  params  array that has objects defining each of the parameters to the request.   Note  A request can have both default unparameterized as well as parameterized data.", 
            "title": "Parameterized Data Request"
        }, 
        {
            "location": "/datasources/staticdatasource/#request-object-attributes-for-parameterized-data", 
            "text": "The following attributes are additional Request Object Attributes that are part of the  request  object definition for parameterized data:     Attribute  Type  Description      params  Array  An array of objects that define each parameter available to the request.  (See Params Array Object for more Information)    paramdata  Object  An object that defines each possible parameter value and its associated  data . The  data  item beneath each parameter value follows the  data  definition for default data", 
            "title": "Request Object Attributes for Parameterized Data"
        }, 
        {
            "location": "/datasources/staticdatasource/#params-array-object", 
            "text": "Each item in the Params array for a request follow this structure:     Attribute  Type  Description      name  String  The name of the parameter. This is the only required item in the specification    required  Boolean  (OPTIONAL) - Whether or not this parameter item is required to be provided by the requestor. If it is required, and the parameter is not supplied, the request will not complete successfully    default  String  (OPTIONAL) - An default value to use if the parameter is not supplied as part of the request.     Below is an Example of a request called  colors  in a data source named  Internal Data . The argument to the request is named  color  which is the color name and the results are color values.  params  defines the parameter  color . The  paramdata  object defines the results for the primary argument  color  and each possible argument value for  color  ( blue     red )  {\n   name : {\n     en_US :  Internal Data \n  },\n   type :  STATIC ,\n   systemtype :  internal_data ,\n   requests : {\n     colors : {\n       schema : {\n         type :  Object ,\n         item : {\n           color : {\n             type :  String \n          },\n           name :{\n             * : String \n          }\n        }\n      },\n       request : {\n         data : {\n           color : #ffffff ,\n           name :{\n             en_US : Default \n          }\n        },\n         params :[\n          {\n             name : color \n           }\n        ],\n         paramdata :{\n           color :{\n             blue :{\n               data :{\n                 color : #0000ff ,\n                 name :{\n                   en_US : Blue ,\n                   de_DE : Blau \n                }\n              }\n            },\n             red :{\n               data :{\n                 color : #ff0000 ,\n                 name :{\n                   en_US : Red ,\n                   de_DE : Rot \n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}   Creating a New Data Source  For Steps to create a new Data Source in  Builder , refer to the  Data Sources  documentation   Last Updated: Jan. 2, 2018", 
            "title": "Params Array Object"
        }, 
        {
            "location": "/datasources/localdatasource/", 
            "text": "Local Data Sources\n\n\nLocal Data Sources are collections of data that store data locally on the device where the application is installed. Since it follows the standard Data Source protocol, data from the repository can be used directly in UI and can also be parameterized using arguments for query purposes. Data is stored as JSON in a file and can optionally be encrypted. Keep in mind that Local Data Sources are modifiable as they are treated like a database. If you want read-only sources of data for an application, use \nStatic Data Sources\n instead.\n\n\n\n\nNote\n\n\nAs of the last version of this document, Data Sources can only be defined using a JSON editor. It is assumed that the reader understands the basics of JSON structure to be able to edit the data source. A better targeted Data Source editor is being developed to make creation of Data Sources simpiler. \n\n\n\n\nRequest Object Attributes\n\n\nIn addition to the basic \nRequest Object Attributes\n provided by Data Sources, Local Data Sources have additional attributes used for data and parameters. \n\n\n\n\n\n\n\n\nAttribute\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nseed\n\n\nmixed\n\n\n(OPTIONAL) - The initial data for the request. When an application is newly installed, this data is used until changes are made by the application.\n\n\n\n\n\n\nmaxentries\n\n\nnumber\n\n\n(OPTIONAL) - This value is used for schema types of Array and Object. It indicates the maximum entries to be stored. If a create or update operation is performed and the array is at its max then the last entry from the end or beginning of the array will be removed.\n\n\n\n\n\n\n\n\nData Schema\n\n\nAll requests require a schema object that defines the structure of the data repository. For Local Data Sources, the top level object needs to be either an Array or an Object. If the top level object is an Object, it is used like an array where the key for the object is the unique identifier of an object instance and the value is an instance of the data Object.\n\n\nThis example shows a request with an array collection of \"user\" objects. The request is called \nusers\n in a data source named \nInternal Data\n.\n\n\n{\n  \nname\n: {\n    \nen_US\n: \nLocal Data\n\n  },\n  \ntype\n: \nLOCAL\n,\n  \nsystemtype\n: \nlocal_data\n,\n  \nrequests\n: {\n    \nusers\n: {\n      \nrequest\n: {\n        \nversion\n: 1\n      },\n      \nschema\n: {\n        \ntype\n: \nArray\n,\n        \nindex\n: \nident\n,\n        \nitem\n: {\n          \ntype\n: \nObject\n,\n          \nitem\n: {\n            \nident\n: {\n              \ntype\n: \nString\n\n            },\n            \nfirstname\n: {\n              \ntype\n: \nString\n\n            },\n            \nlastname\n: {\n              \ntype\n: \nString\n\n            },\n            \npicture\n: {\n              \ntype\n: \nString\n\n            },\n            \npassword\n: {\n              \ntype\n: \nString\n\n            },\n            \nemail\n: {\n              \ntype\n: \nString\n\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\n\n\n\n\nDefault Data\n\n\nLocal Data Source requests can be seeded with data to provide an initial data set for the application. The initial data is provided within the \nrequest\n object with the key \nseed\n. If the initial data changes, the \nversion\n of the request must be incremented to force clients to reseed the database with the provided data.\n\n\n!!! note Version Migration\n    As of version 1.1 of the P2UX Rendering Libraries \n(PRL)\n, Local Data Sources don't support a version migration schema. This is planned for version 1.2 of the client libraries.\n\n\nThis example shows a request with seeded data. The request is called \nmessages\n and contains a default message.\n\n\n{\n  \nname\n: {\n    \nen_US\n: \nLocal Data\n\n  },\n  \ntype\n: \nLOCAL\n,\n  \nsystemtype\n: \nlocal_data\n,\n  \nrequests\n: {\n    \nmessages\n: {\n      \nrequest\n: {\n        \nversion\n: 1,\n        \nseed\n:[\n          {\n            \nident\n:\nff-default\n,\n            \nmessage\n: \nWelcome to the app, you\nll find important messages here.\n,\n            \nfrom\n:\nSystem\n,\n            \ntype\n:0\n          }\n        ]\n      },\n      \nschema\n: {\n        \ntype\n: \nArray\n,\n        \nindex\n: \nident\n,\n        \nitem\n: {\n          \ntype\n: \nObject\n,\n          \nitem\n: {\n            \nident\n: {\n              \ntype\n: \nString\n\n            },\n            \nmessage\n: {\n              \ntype\n:\nString\n\n            },\n            \ntimestamp\n: {\n              \ntype\n: \nDate\n\n            },\n            \nfrom\n: {\n              \ntype\n: \nString\n\n            },\n            \ntype\n:{\n              \ntype\n: \nNumber\n\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\n\n\n\n\n\n\nCreating a New Data Source\n\n\nFor Steps to create a new Data Source in \nBuilder\n, refer to the \nData Sources\n documentation\n\n\n\n\nLast Updated: Jan. 2, 2018", 
            "title": "Local Data"
        }, 
        {
            "location": "/datasources/localdatasource/#local-data-sources", 
            "text": "Local Data Sources are collections of data that store data locally on the device where the application is installed. Since it follows the standard Data Source protocol, data from the repository can be used directly in UI and can also be parameterized using arguments for query purposes. Data is stored as JSON in a file and can optionally be encrypted. Keep in mind that Local Data Sources are modifiable as they are treated like a database. If you want read-only sources of data for an application, use  Static Data Sources  instead.   Note  As of the last version of this document, Data Sources can only be defined using a JSON editor. It is assumed that the reader understands the basics of JSON structure to be able to edit the data source. A better targeted Data Source editor is being developed to make creation of Data Sources simpiler.", 
            "title": "Local Data Sources"
        }, 
        {
            "location": "/datasources/localdatasource/#request-object-attributes", 
            "text": "In addition to the basic  Request Object Attributes  provided by Data Sources, Local Data Sources have additional attributes used for data and parameters.      Attribute  Type  Description      seed  mixed  (OPTIONAL) - The initial data for the request. When an application is newly installed, this data is used until changes are made by the application.    maxentries  number  (OPTIONAL) - This value is used for schema types of Array and Object. It indicates the maximum entries to be stored. If a create or update operation is performed and the array is at its max then the last entry from the end or beginning of the array will be removed.", 
            "title": "Request Object Attributes"
        }, 
        {
            "location": "/datasources/localdatasource/#data-schema", 
            "text": "All requests require a schema object that defines the structure of the data repository. For Local Data Sources, the top level object needs to be either an Array or an Object. If the top level object is an Object, it is used like an array where the key for the object is the unique identifier of an object instance and the value is an instance of the data Object.  This example shows a request with an array collection of \"user\" objects. The request is called  users  in a data source named  Internal Data .  {\n   name : {\n     en_US :  Local Data \n  },\n   type :  LOCAL ,\n   systemtype :  local_data ,\n   requests : {\n     users : {\n       request : {\n         version : 1\n      },\n       schema : {\n         type :  Array ,\n         index :  ident ,\n         item : {\n           type :  Object ,\n           item : {\n             ident : {\n               type :  String \n            },\n             firstname : {\n               type :  String \n            },\n             lastname : {\n               type :  String \n            },\n             picture : {\n               type :  String \n            },\n             password : {\n               type :  String \n            },\n             email : {\n               type :  String \n            }\n          }\n        }\n      }\n    }\n  }\n}", 
            "title": "Data Schema"
        }, 
        {
            "location": "/datasources/localdatasource/#default-data", 
            "text": "Local Data Source requests can be seeded with data to provide an initial data set for the application. The initial data is provided within the  request  object with the key  seed . If the initial data changes, the  version  of the request must be incremented to force clients to reseed the database with the provided data.  !!! note Version Migration\n    As of version 1.1 of the P2UX Rendering Libraries  (PRL) , Local Data Sources don't support a version migration schema. This is planned for version 1.2 of the client libraries.  This example shows a request with seeded data. The request is called  messages  and contains a default message.  {\n   name : {\n     en_US :  Local Data \n  },\n   type :  LOCAL ,\n   systemtype :  local_data ,\n   requests : {\n     messages : {\n       request : {\n         version : 1,\n         seed :[\n          {\n             ident : ff-default ,\n             message :  Welcome to the app, you ll find important messages here. ,\n             from : System ,\n             type :0\n          }\n        ]\n      },\n       schema : {\n         type :  Array ,\n         index :  ident ,\n         item : {\n           type :  Object ,\n           item : {\n             ident : {\n               type :  String \n            },\n             message : {\n               type : String \n            },\n             timestamp : {\n               type :  Date \n            },\n             from : {\n               type :  String \n            },\n             type :{\n               type :  Number \n            }\n          }\n        }\n      }\n    }\n  }\n}   Creating a New Data Source  For Steps to create a new Data Source in  Builder , refer to the  Data Sources  documentation   Last Updated: Jan. 2, 2018", 
            "title": "Default Data"
        }, 
        {
            "location": "/datasources/restfuldatasource/", 
            "text": "RESTful Data Sources\n\n\nRESTful Data Sources are collections of data are fetched via HTTP/HTTPS. Since it follows the standard Data Source protocol, data from the repository can be used directly in UI. Data can be persisted locally when fetched from a REST service to provide an offline experience. Data persisted can also be expired based on a time validity period.\n\n\n\n\nNote\n\n\nAs of the last version of this document, Data Sources can only be defined using a JSON editor. It is assumed that the reader understands the basics of JSON structure to be able to edit the data source. A better targeted Data Source editor is being developed to make creation of Data Sources simpiler. \n\n\n\n\nInitData Object Attributes\n\n\nThe \ninitdata\n object for RESTful Data Sources includes the following attributes:\n\n\n\n\n\n\n\n\nAttribute\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nbaseurl\n\n\nstring\n\n\nThe a URL that is to provide a basis for each of the requests in this datasource. Requests that use this simply provide a path element to append to this base URL. Alternatively, each request can supply its own full requesturl attribute.\n\n\n\n\n\n\nauth\n\n\nobject\n\n\nThe authentication method and details necessary to authorize a client for access to the requests defined in this datasource. The details of the auth object are specified according to the value of the type attribute. See \nAuthentication\n for more information\n\n\n\n\n\n\n\n\nRequest Object Attributes\n\n\nIn addition to the standard \nRequest Object Attributes\n provided by Data Sources, RESTful Data Sources have a additional attributes used for data and parameters.\n\n\n\n\n\n\n\n\nAttribute\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nattributes\n\n\nobject\n\n\n(OPTIONAL) - An object that defines additional attributes for the request. See \nAttributes Object\n for more information\n\n\n\n\n\n\nmethod\n\n\nstring\n\n\nThis is the HTTP method to perform for this request. Valid values are \"GET\", \"PUT\", \"POST\", \"DELETE\" and \"PATCH\"\n\n\n\n\n\n\npath\n\n\nstring\n\n\nThis attribute defines a path extension to add to the baseurl rather than replacing it completely with the url. This path may contain \"parameterized\" path elements. These elements are begin with a \":\" character and will be replaced by associated values supplied in the args passed to the request. For example the path \"/users/:id\" would have \":id\" replaced with the value from the field \"id\" passed in the args.\nNote: \npath\n and \nurl\n are mutually exclusive.\n\n\n\n\n\n\nurl\n\n\nstring\n\n\nThis attribute defines a fully qualified URL for this request rather than using the baseurl and path. This url itself may contain \"parameterized\" path elements. These elements are begin with a \":\" character and will be replaced by associated values supplied in the args passed to the request. For example the url \"https://servername/users/:user\" would have \":user\" replaced with the value from the field \"user\" passed in the args.\nNote: \npath\n and \nurl\n are mutually exclusive.\n\n\n\n\n\n\nargs\n\n\nobject\n\n\nThis is an args object as described in the general datasource attributes. For a RESTful datasource these are processed in a few ways after merging these with the args passed in from either the event action or data link. The args fields will first be matched against any \"parameterized\" path elements in the constructed request URL (see path and url above). Any remaining fields not matched in the URL path will either be used to construct query parameters for a GET or DELETE request or will be posted into the body of the request for a PUT or POST request.\n\n\n\n\n\n\npostschema\n\n\nobject\n\n\nThis is a \nschema\n object as described in the general datasource specification. This schema is used to validate the type and structure of the data that will be included in the body of a POST or PUT request.\n\n\n\n\n\n\nfailFields\n\n\nobject\n\n\nIf a request results in a failure indicated by its schema this object can contain a message and a detail field that will be used to construct an error object that may be used in place of the actual data results. Each of these fields is a string value that contains a \"dotted-path\" to a field within the returned data. For example the message may be found in \".response.body.error.msg\".\n\n\n\n\n\n\nerrorSchema\n\n\nobject\n\n\nIf the request results in failure due to the HTTP method returning an error code. This object may contain a schema in the standard datasource schema format that will be used to validate and parse any data returned in the error result.\n\n\n\n\n\n\nerrorFields\n\n\nobject\n\n\nIf the request results in a failure due to the HTTP method returning an error code and an errorSchema is provided, this object may contain a message and a detail field that will be used to construct an error object. Each of these fields is a string value that contains a \"dotted-path\" to a field within the returned data. For example the detail may be found in \".error.description\".\n\n\n\n\n\n\nasync\n\n\nboolean\n\n\nIf this field is present and set to TRUE then it indicates that this request may utilize asynchronous polling for results. If the reqest results in a \"partial\" value as indicated by its schema then a TRUE value here will cause the request to poll for a complete result if there is an associated polling object as well.\n\n\n\n\n\n\npolling\n\n\nobject\n\n\nThis is an object that defines how the polling for results will be performed. It is primarily controlled by a \ndelay\n field that specifies a number of seconds between issuing subsequent poll requests for a full result. It can also have a \ncount\n field which specifies the maximum number of poll attempts it will make. If the request continues to return partial (i.e. non-success or failure) results then the polling will continue until it reaches the count. The polling object may also contain overrides for many of the other attributes in the initial request including the \nmethod\n, \npath\n, \nurl\n, \npostschema\n, or the \nschema\n. Finally, it is possible to have the \nurl\n for polling come from the results via a \nurlfield\n attribute that specifies a \"dotted-path\" into the results.\n\n\n\n\n\n\n\n\nAttributes Object\n\n\nThe \nrequest\n object can have additional attributes that control how its data is handled.\n\n\n\n\n\n\n\n\nAttribute\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\npersist\n\n\nboolean\n\n\n(OPTIONAL) - Whether or not data retrieved from the REST service for a request is persisted locally. If this attribute not specified, no data will be persisted and network connectivity will be required to use any data from the request.\n\n\n\n\n\n\nvalidity\n\n\nnumber\n\n\n(OPTIONAL) - When data is persisted, this value indicates how long that data should be considered valid. This allows for requests to be defined where it will trigger a new request if the data no longer valid versus always fetching data from the service.\nThis value is the number of seconds to consider the data valid from the time it was persisted\n\n\n\n\n\n\nrefresh\n\n\nnumber\n\n\n(OPTIONAL) - This value will create a polling type of request once a the request has been triggered by an event in the client. Use this value only in the case where the client needs to poll a request on a service based on a time interval.\nThis value is the number of seconds to wait between requests.\n\n\n\n\n\n\nencrypt\n\n\nboolean\n\n\n(OPTIONAL) - When \npersist\n is set to \ntrue\n, setting \nencrypt\n to \ntrue\n will encrypt the data persisted on the client device.\n\n\n\n\n\n\n\n\nAuthentication\n\n\nThe \nauth\n object defines the form of authentication to use (if any) when accessing the data source requests. Most attributes of the \nauth\n object are dependent on the type of auth. However, the following attributes are defined at the top level.\n\n\n\n\n\n\n\n\nAttribute\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntype\n\n\nstring\n\n\nThis is a string that defines the authentication method for access to the requests defined in this datasource. The details of many of the fields in the auth object are defined by the value of the \ntype\n attribute.  (See \nAuth Types\n for more information)\n\n\n\n\n\n\nurl\n\n\nstring\n\n\n(OPTIONAL) - This attribute defines a full URL that will override the baseurl construction and be used directly as the URL for authentication. Certain auth types may require this element.\n\n\n\n\n\n\npath\n\n\nstring\n\n\n(OPTIONAL) - This attribute defines a path extension that is appended to the baseURL rather than replacing it completely with the auth \nurl\n.\n\n\n\n\n\n\nservicename\n\n\nstring\n\n\n(OPTIONAL) - This is a string identifying the name of the service that will be used for this authorization option. It may be necessary for the client to have pre-registered with this service and to have information such as a username, password or client_id.\n\n\n\n\n\n\nargs\n\n\nobject\n\n\n(OPTIONAL) - Defines arguments to be passed to the authentication request. These are used depending on the type of the authentication. Args can be static values or data links. Args will be used to populate values in a \nloginschema\n or as parameters to a \nurl\n.\n\n\n\n\n\n\n\n\nThe remainder of the attributes in the auth object are dependent on the type of auth object that is specified.\n\n\nAuth Types\n\n\nThese are the current authentication types supported by RESTful Data Sources. Additional types can be created by supplying a custom string for the \ntype\n and then by creating custom subclasses of the \nP2UXRestDataSource\n class in client code.\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nBasic\n\n\nThe authentication credentials are provided using the standard HTTP Basic authentication protocol specified in RFC 2617 with the credentials supplied in the HTTP \u201cAuthorization\u201d header field.\n\n\n\n\n\n\nLogin\n\n\nThe authentication credentials are provided by \u201clogin\u201d credentials. The default is username and password, but the exact format is defined via a standard REST POST request specification and can include other parameters.\n\n\n\n\n\n\nTokenLogin\n\n\nThe authentication credentials are provided by \"login\" credentials and the result of the login is a token that can be used with request data for authentication. This is similar to OAuth, but is more freeform to accomodate specific server implementations.\n\n\n\n\n\n\nOAuth\n\n\nThe authentication credentials are provided in accordance with RFC 6749 (aka the OAuth 2.0 specification). The specific type of authorization is determined by the \ngranttype\n attribute.\n\n\n\n\n\n\n\n\nBasic Auth\n\n\n\n\n\n\n\n\nAttribute\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nusername\n\n\nstring\n\n\nThe username to be sent in the Authorization header field. If this is not present, the application will need to supply this information from another source. Typically this is defined as a data link to prompt the user. Its the responsibility of the application using the data source to respond to the request for the information by triggering UI and responding with the provided information. (See \nData Source - Requesting User Information\n)\n\n\n\n\n\n\npassword\n\n\nstring\n\n\nThe password to be sent in the Authorization header field. If this is not present, the application will need to supply this information from another source. Typically this is defined as a data link to prompt the user. Its the responsibility of the application using the data source to respond to the request for the information by triggering UI and responding with the provided information. (See \nData Source - Requesting User Information\n)\n\n\n\n\n\n\nrealm\n\n\nstring\n\n\n(OPTIONAL) - The authentication \u201crealm\u201d to use for this server. This should contain the value that would normally be included in the WWW-Authenticate HTTP header from a web server in a 401 response message.\n\n\n\n\n\n\n\n\nExample Basic Auth:\n\n\n{\n  \ninitdata\n: {\n    \nbaseurl\n: \nhttp://www.testme.com\n,\n    \nauth\n: {\n      \ntype\n: \nBasic\n,\n      \npath\n: \nlogin\n,\n      \nusername\n: \nthatguy\n,\n      \npassword\n: \n123Happy\n\n    }\n  }\n  ...\n}\n\n\n\n\n\nLogin Auth\n\n\n\n\n\n\n\n\nAttribute\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nrequest\n\n\nstring\n\n\nA standard REST request object specifying the format, method and either path or full requesturl. See REST request specification below. In most cases the request will be a \u201cPOST\u201d method.\n\n\n\n\n\n\nloginschema\n\n\nobject\n\n\nThe schema specification in the REST \nschema\n format defined below for the data required to log into the service. The login auth request may contain alias fields if the submitted data in the request has different names than the fields with semantic meaning to the application.\nSupported Attributes:\nAttribute\nType\nDescription\nusername\nstring\nTells the client which field (if any) represents the login username. If there is a \u201cusername\u201d field in the schema this is not needed.\npassword\nstring\nTells the client which field (if any) represents the login password. If there is a \u201cpassword\u201d field in the schema this is not needed\n\n\n\n\n\n\nschema\n\n\nobject\n\n\nContains a schema specification in the REST schema format defined below. It specifies the format of the data that is returned from the login request.\n\n\n\n\n\n\npersist\n\n\narray\n\n\n(OPTIONAL) - defines data from the \"schema\" that should be persisted for further use in subsequent requests. The values returned from the successful login are stored encrypted and then injected into requests depending on the \nuse\n defined for each parameter. Values that don't need to be used as part of requests don't need to be included in the persist array. If no data needs to be persisted for use, then this object can be omitted entirely.\nEach item defined in the persist array corresponds to a value in the schema for the login and how that value should be used for subsequent requests. All of the specified values are required. (See \nPersist Attributes\n)\n\n\n\n\n\n\n\n\nExample Login Auth\n\n\n{\n  \ninitdata\n: {\n    \nbaseurl\n: \nhttp://sampleservice.com/\n,\n    \nauth\n: {\n      \ntype\n: \nLogin\n,\n      \nrequest\n: {\n        \nformat\n: \nJSON\n,\n        \nmethod\n: \nPOST\n,\n        \npath\n: \nlogin\n\n      },\n      \nloginschema\n: {\n        \ntype\n: \nObject\n,\n        \nitem\n: {\n          \nusername\n: \nname\n,\n          \nname\n: {\n            \ntype\n: \nString\n\n          },\n          \npassword\n: {\n            \ntype\n: \nString\n\n          }\n        }\n      },\n      \nschema\n: {\n        \ntype\n: \nObject\n,\n        \nitem\n: {\n          \nresult\n: {\n            \ntype\n: \nNumber\n\n          }\n        },\n        \nsuccess\n: {\n          \nresult\n: 0\n        }\n      }\n    }\n  }\n  ...\n}\n\n\n\n\n\nTokenLogin Auth\n\n\nTokenLogin uses standard login credentials but can handle a token returned when the login is successful. This token is applied to requests depending on the server requirements. It also can support refreshing the token if that is supported.\n\n\n\n\n\n\n\n\nAttribute\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nrefresh\n\n\nobject\n\n\nAn object that defines how to refresh the token when it expires. The format of this follows the \nauth\n object format with some additional parameters (See \nRefresh Attributes\n)\n\n\n\n\n\n\nloginschema\n\n\nobject\n\n\nThe schema specification in the REST \nschema\n format defined below for the data required to log into the service. The login auth request may contain alias fields if the submitted data in the request has different names than the fields with semantic meaning to the application.\nSupported Attributes:\nAttribute\nType\nDescription\nusername\nstring\nTells the client which field (if any) represents the login username. If there is a \u201cusername\u201d field in the schema this is not needed.\npassword\nstring\nTells the client which field (if any) represents the login password. If there is a \u201cpassword\u201d field in the schema this is not needed\n\n\n\n\n\n\nschema\n\n\nobject\n\n\nContains a schema specification in the REST schema format defined below. It specifies the format of the data that is returned from the login request.\n\n\n\n\n\n\npersist\n\n\narray\n\n\n(OPTIONAL) - defines data from the \"schema\" that should be persisted for further use in subsequent requests. The values returned from the successful login are stored encrypted and then injected into requests depending on the \nuse\n defined for each parameter. Values that don't need to be used as part of requests don't need to be included in the persist array. If no data needs to be persisted for use, then this object can be omitted entirely.\nEach item defined in the persist array corresponds to a value in the schema for the login and how that value should be used for subsequent requests. All of the specified values are required. (See \nPersist Attributes\n)\n\n\n\n\n\n\n\n\nExample TokenLogin Auth\n\nThis example shows using token login authentication with a \nFirebase\n application. The \nrefresh_token\n in the \nrefresh\n object refers to cached authentication values via a link of type 16 (auth value). The \nkey\n refers to a static value in the application named \nauthkey\n. The args in the \nrefresh\n object are used to populate the \nloginschema\n for the refresh request.\n\n\n{\n  \ninitdata\n: {\n    \nauth\n: {\n      \nrefresh\n: {\n        \nargs\n: {\n          \nkey\n: {\n            \nvar\n: \nauthkey\n,\n            \ntype\n: 14\n          },\n          \nrefresh_token\n: {\n            \nvar\n: \nrefreshToken\n,\n            \ntype\n: 16\n          },\n          \ngrant_type\n: \nrefresh_token\n\n        },\n        \npersistpaths\n: {\n          \nrefresh_token\n: \nrefreshToken\n,\n          \nid_token\n: \nidToken\n,\n          \nexpires_in\n: \nexpiresIn\n\n        },\n        \nloginschema\n: {\n          \ntype\n: \nObject\n,\n          \nitem\n: {\n            \ngrant_type\n: {\n              \ntype\n: \nString\n\n            },\n            \nrefresh_token\n: {\n              \ntype\n: \nString\n\n            }\n          }\n        },\n        \nschema\n: {\n          \ntype\n: \nObject\n,\n          \nitem\n: {\n            \nexpires-in\n: {\n              \ntype\n: \nString\n\n            },\n            \nrefresh_token\n: {\n              \ntype\n: \nString\n\n            },\n            \nproject_id\n: {\n              \ntype\n: \nString\n\n            },\n            \nuser_id\n: {\n              \ntype\n: \nString\n\n            },\n            \nid_token\n: {\n              \ntype\n: \nString\n\n            },\n            \ntoken_type\n: {\n              \ntype\n: \nString\n\n            }\n          }\n        },\n        \nurl\n: \nhttps://securetoken.googleapis.com/v1/token?key=:key\n\n      },\n      \ntype\n: \nTokenLogin\n,\n      \nservicename\n: \nsample\n,\n      \nurl\n: \nhttps://www.googleapis.com/identitytoolkit/v3/relyingparty/verifyPassword?key=:key\n,\n      \nrequest\n: {\n        \nformat\n: \nJSON\n,\n        \nmethod\n: \nPOST\n\n      },\n      \npersist\n: [\n        {\n          \npath\n: \nappId\n,\n          \nfield\n: \nX-HTTP-AppId\n,\n          \nuse\n: \nheader\n,\n          \nval\n: {\n            \nvar\n: \nauthkey\n,\n            \ntype\n: 14\n          }\n        },\n        {\n          \nmethod\n: \nPOST\n,\n          \nfield\n: \nidToken\n,\n          \npath\n: \nidToken\n,\n          \nuse\n: \npayload\n\n        },\n        {\n          \nmethod\n: \nGET\n,\n          \nfield\n: \nauth\n,\n          \npath\n: \nidToken\n,\n          \nuse\n: \nparameter\n\n        },\n        {\n          \npath\n: \nrefreshToken\n,\n          \nuse\n: \nrefreshtoken\n\n        },\n        {\n          \npath\n: \nexpiresIn\n,\n          \nuse\n: \nexpires\n\n        },\n        {\n          \npath\n: \nidToken\n,\n          \nuse\n: \naccesstoken\n\n        }\n      ],\n      \nargs\n: {\n        \nkey\n: {\n          \nvar\n: \nauthkey\n,\n          \ntype\n: 14\n        },\n        \nemail\n: {\n          \nvar\n: \nemail\n,\n          \ntype\n: 15\n        },\n        \npassword\n: {\n          \nvar\n: \npassword\n,\n          \ntype\n: 15\n        },\n        \nreturnSecureToken\n: true\n      },\n      \nloginschema\n: {\n        \ntype\n: \nObject\n,\n        \nitem\n: {\n          \nreturnSecureToken\n: {\n            \ntype\n: \nBoolean\n\n          },\n          \npassword\n: {\n            \ntype\n: \nString\n\n          },\n          \nemail\n: {\n            \ntype\n: \nString\n\n          }\n        }\n      },\n      \nschema\n: {\n        \ntype\n: \nObject\n,\n        \nitem\n: {\n          \nexpiresIn\n: {\n            \ntype\n: \nString\n\n          },\n          \nrefreshToken\n: {\n            \ntype\n: \nString\n\n          },\n          \nregistered\n: {\n            \ntype\n: \nBoolean\n\n          },\n          \nidToken\n: {\n            \ntype\n: \nString\n\n          },\n          \ndisplayName\n: {\n            \ntype\n: \nString\n\n          },\n          \nemail\n: {\n            \ntype\n: \nString\n\n          },\n          \nlocalId\n: {\n            \ntype\n: \nString\n\n          },\n          \nkind\n: {\n            \ntype\n: \nString\n\n          }\n        }\n      }\n    },\n    \nbaseurl\n: \nhttps://sampleapp.firebaseio.com/\n\n  }\n  ...\n}\n\n\n\n\n\nOAuth Auth\n\n\nThe OAuth authentication mode can provide a variety of different ways to authenticate the user depending on the service requirements and client capabilities. The specific authentication mechanism is controlled by a \"granttype\" setting. For OAuth the auth url (or baseurl + auth path) is a mandatory attribute. The authorization is performed by submitting these parameters to the auth url in exchange for an \u201cAuthorization Token\u201d which will be sent to the service when each of the requests are made. The URL will have query parameters appended to it by the client based on the specific granttype protocol being performed. Some of these required parameters may come from the client having to be registered with a specific service. These values will need to be embedded into the client code or obtained through application-specific business logic. \n\n\nFor certain OAuth granttype values, the client will utilize an embedded web-browser as the first step in the protocol before submitting the token request directly over HTTP. When this is the case, it is usually because the client is being authenticated on behalf of a user on a third-party service (e.g Facebook). In this case, a separate code_url is used to construct the URL sent to the browser. Along with the required parameters this includes a redirect_uri where the service will redirect the browser once the user authorizes the client. This url should generally be a \"localhost\" url as the client will use this to retreive an Authorization Code that it will then submit to the authurl in exchange for the Authorization Token\n\n\n\n\n\n\n\n\nAttribute\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngrant\n\n\nstring\n\n\nOne of the 3 possible \u201cauthorization grant\u201d types supported by the OAuth 2.0 protocol.\nPossible Values:\nValue\nDescription\nAuthCode\nThis indicates that the client should initiate a request for an \u201cAuthorization Code\u201d. The client will be launch in an embedded browser with the codeurl (see below) in order to allow the user to authenticate the client to the service using their credentials. The client will append information to the URL obtained when registering for the service. This includes a CLIENT_ID and a REDIRECT_URI. In response to this request, the client will  submit the returned code to the authurl in order to redeem it for an \u201cAuthorization Token\u201d.\nPassword\nThis indicated that client should directly request an \u201cAuthorization Token\u201d by providing a username and password pair. This must be supplied by the client via a user prompt or some other internal mechanism. It will also need to have a CLIENT_ID. The client will need to complete the authurl as well in this case by appending the USERNAME, PASSWORD and CLIENT_ID parameters.\nClient\nThis indicates that the client should directly request an \u201cAuthorization Token\u201d by providing its pre-registered client credentials in the form of a CLIENT_ID and CLIENT_SECRET. This will be supplied in the HTTP Authorization header field using the \u201cBasic\u201d authentication format.\n\n\n\n\n\n\ncode_url\n\n\nstring\n\n\nUsed for a granttype of \u201cAuthCode\u2019. it specifies a URL to that will be opened in an embedded web browser in order to obtain the Authorization Code.\n\n\n\n\n\n\nredirect_uri\n\n\nstring\n\n\nUsed for a granttype of \"AuthCode\". This will be appended to the codeurl so the service may redirect the embedded browser and supply the Authorization Code to the client once the user has authorized it.\n\n\n\n\n\n\n\n\nClient ID and Secret\n\n\nThe client id and secret can be provided to OAuth authentication using Static Values in an Application specification via the \nargs\n object for the auth request. This mechanism allows for a RESTful Data source to be generic in its definition and reusable by different applications as the application provides the instance values. (See Static Values for more information). \n\n\nExample OAuth Auth\n\nIn this example, the \nclient_id\n and \nclient_secret\n values would be defined in the application as static values and populated by the PRL at runtime.\n\n\n{\n  \ninitdata\n: {\n    \nbaseurl\n: \nhttps://api.instagram.com/\n,\n    \nauth\n: {\n      \nservicename\n: \nInstagram\n,\n      \ntype\n: \nOAuth\n,\n      \ngranttype\n: \nAuthCode\n,\n      \nurl\n: \nhttps://api.instagram.com/oauth2/token\n,\n      \ncode_url\n: \nhttps://api.instagram.com/oauth/authorize/\n,\n      \nredirect_uri\n: \nhttp://localhost\n,\n      \nargs\n: {\n        \nclient_id\n:{\n          \ntype\n:14,\n          \nval\n:\ninstagram_client_id\n\n        },\n        \nclient_secret\n:{\n          \ntype\n:14,\n          \nval\n:\ninstagram_client_secret\n\n        }\n      }\n    }\n  }\n  ...\n}\n\n\n\n\n\nPersist Attributes\n\n\nTokenLogin\n and \nLogin\n authentication types can provide a \npersist\n array that defines how values returned from a successful login are to be cached securely on the client device and used in requests.\n\n\n\n\n\n\n\n\nAttribute\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\npath\n\n\nstring\n\n\nA path to the value in the response. Supports dotted notation to navigate through object heirarchy (e.g. \"results.token\")\n\n\n\n\n\n\nuse\n\n\nstring\n\n\nDescribes the use of the value with regards to inclusion in requests for the data source.\nPossible Values:\nValue\nDescription\npayload\nthe value is placed in the payload (body) of the request.\nheader\nThe value is included in the header of the request.\nparameter\nThe value is passed as a query parameter to the request.\nexpires\nThe value is used to determine the expiration of any authentication\nrefreshtoken\nIf the authentication supports refresh tokens, this indicates which value in the data is the refreshtoken.\n\n\n\n\n\n\nfield\n\n\nstring\n\n\nThe name of the field to use for the value. When the use of the data is payload or argument, this becomes the key for the value in the key/value pair that is submitted either in the body of or the query parameters for each request. If the use is header, this is the HTTP header field to use when submitting the value with each request\n\n\n\n\n\n\nmethod\n\n\nstring\n\n\n(OPTIONAL) - the specific method of request that the persist data should be applied to. If no method is specified, the data would be applied to any method of data request. If multiple methods are needed, they can be provided as single value separated by commas.\nPossible Values:\nValue\nGET\nPOST\nPUT\nDELETE\n\n\n\n\n\n\n\n\nData Schema\n\n\nAll requests require a schema object that defines the structure of the data returned for the request.\n\n\nThis example shows a request with an array collection of \"user\" objects. The request is called \nusers\n in a data source named \nService Data\n.\n\n\n{\n  \nname\n: {\n    \nen_US\n: \nService Data\n\n  },\n  \ntype\n: \nREST\n,\n  \nsystemtype\n: \nservice_data\n,\n  \nrequests\n: {\n    \nusers\n: {\n      \nrequest\n: {\n        \nversion\n: 1\n      },\n      \nschema\n: {\n        \ntype\n: \nArray\n,\n        \nindex\n: \nident\n,\n        \nitem\n: {\n          \ntype\n: \nObject\n,\n          \nitem\n: {\n            \nident\n: {\n              \ntype\n: \nString\n\n            },\n            \nfirstname\n: {\n              \ntype\n: \nString\n\n            },\n            \nlastname\n: {\n              \ntype\n: \nString\n\n            },\n            \npicture\n: {\n              \ntype\n: \nString\n\n            },\n            \npassword\n: {\n              \ntype\n: \nString\n\n            },\n            \nemail\n: {\n              \ntype\n: \nString\n\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\n\n\n\n\nExamples\n\n\nTwitter using OAuth\n\n\nThis example specification uses Twitter's RESTful API with OAuth as the authentication type. It defines a request called \nsearch\n that takes a search parameter as an argument. In this example, the argument has a default value supplied by the spec. If the application doesn't provide the argument at runtime as part of the request, this value would be used as the default argument. For authentication, the \nclient_id\n and \nclient_secret\n values used for OAuth are provided by the application using \nStatic Values\n. Since \npersist\n is not defined in the attributes of the request, the results of the request would not be saved on the client device for offline use.\n\n\n{\n  \nname\n: {\n    \nen_US\n: \nTwitter\n\n  },\n  \ntype\n: \nREST\n,\n  \nsystemtype\n: \ntwitter\n,\n  \ninitdata\n: {\n    \nauth\n: {\n      \ngranttype\n: \nClient\n,\n      \ntype\n: \nOAuth\n,\n      \nservicename\n: \nTwitter\n,\n      \npath\n: \noauth2/token\n,\n      \nargs\n: {\n        \nclient_id\n: {\n          \ntype\n: 14,\n          \nvar\n: \ntwitter_client_id\n\n        },\n        \nclient_secret\n: {\n          \ntype\n: 14,\n          \nvar\n: \ntwitter_client_secret\n\n        }\n      }\n    },\n    \nbaseurl\n: \nhttps://api.twitter.com\n\n  },\n  \nrequests\n: {\n    \nsearch\n: {\n      \nschema\n: {\n        \nitem\n: {\n          \nsearch_metadata\n: {\n            \nitem\n: {\n              \nsince_id_str\n: {\n                \ntype\n: \nString\n\n              },\n              \nmax_id_str\n: {\n                \ntype\n: \nString\n\n              },\n              \nquery\n: {\n                \ntype\n: \nString\n\n              },\n              \ncompleted_in\n: {\n                \ntype\n: \nNumber\n\n              },\n              \ncount\n: {\n                \ntype\n: \nNumber\n\n              },\n              \nnext_results\n: {\n                \ntype\n: \nString\n\n              },\n              \nrefresh_uri\n: {\n                \ntype\n: \nString\n\n              },\n              \nsince_id\n: {\n                \ntype\n: \nNumber\n\n              },\n              \nmax_id\n: {\n                \ntype\n: \nNumber\n\n              }\n            },\n            \ntype\n: \nObject\n\n          },\n          \nstatuses\n: {\n            \nitem\n: {\n              \nitem\n: {\n                \nuser\n: {\n                  \nitem\n: {\n                    \nscreen_name\n: {\n                      \ntype\n: \nString\n\n                    },\n                    \nfriends_count\n: {\n                      \ntype\n: \nNumber\n\n                    },\n                    \nstatuses_count\n: {\n                      \ntype\n: \nNumber\n\n                    },\n                    \ndescription\n: {\n                      \ntype\n: \nString\n\n                    },\n                    \ntime_zone\n: {\n                      \ntype\n: \nString\n\n                    },\n                    \nfollowers_count\n: {\n                      \ntype\n: \nNumber\n\n                    },\n                    \nlang\n: {\n                      \ntype\n: \nString\n\n                    },\n                    \nutc_offset\n: {\n                      \ntype\n: \nNumber\n\n                    },\n                    \nurl\n: {\n                      \ntype\n: \nString\n\n                    },\n                    \nid_str\n: {\n                      \ntype\n: \nString\n\n                    },\n                    \nid\n: {\n                      \ntype\n: \nNumber\n\n                    },\n                    \nlocation\n: {\n                      \ntype\n: \nString\n\n                    },\n                    \ncreated_at\n: {\n                      \ntype\n: \nString\n\n                    },\n                    \nprofile_image_url_https\n: {\n                      \ntype\n: \nString\n\n                    },\n                    \nprofile_image_url\n: {\n                      \ntype\n: \nString\n\n                    },\n                    \nname\n: {\n                      \ntype\n: \nString\n\n                    }\n                  },\n                  \ntype\n: \nObject\n\n                },\n                \nin_reply_to_screen_name\n: {\n                  \ntype\n: \nString\n\n                },\n                \nin_reply_to_status_id_str\n: {\n                  \ntype\n: \nString\n\n                },\n                \nin_reply_to_status_id\n: {\n                  \ntype\n: \nNumber\n\n                },\n                \nretweet_count\n: {\n                  \ntype\n: \nNumber\n\n                },\n                \nretweeted\n: {\n                  \ntype\n: \nBoolean\n\n                },\n                \nid_str\n: {\n                  \ntype\n: \nString\n\n                },\n                \nid\n: {\n                  \ntype\n: \nNumber\n\n                },\n                \ntext\n: {\n                  \ntype\n: \nString\n\n                },\n                \ncreated_at\n: {\n                  \ntype\n: \nString\n\n                },\n                \ntruncated\n: {\n                  \ntype\n: \nBoolean\n\n                },\n                \nfavorited\n: {\n                  \ntype\n: \nBoolean\n\n                },\n                \ncoordinates\n: {\n                  \nitem\n: {\n                    \ntype\n: {\n                      \ntype\n: \nString\n\n                    },\n                    \ncoordinates\n: {\n                      \nitem\n: {\n                        \ntype\n: \nNumber\n\n                      },\n                      \ntype\n: \nArray\n\n                    }\n                  },\n                  \ntype\n: \nObject\n\n                }\n              },\n              \ntype\n: \nObject\n\n            },\n            \ntype\n: \nArray\n\n          }\n        },\n        \ntype\n: \nObject\n\n      },\n      \nrequest\n: {\n        \nargs\n: {\n          \nq\n: \n#beef\n\n        },\n        \nformat\n: \nJSON\n,\n        \nmethod\n: \nGET\n,\n        \npath\n: \n1.1/search/tweets.json\n,\n        \nversion\n:1\n      }\n    }\n  }\n}\n\n\n\n\n\n\n\nCreating a New Data Source\n\n\nFor Steps to create a new Data Source in \nBuilder\n, refer to the \nData Sources\n documentation\n\n\n\n\nLast Updated: Dec. 27, 2017", 
            "title": "RESTful Data"
        }, 
        {
            "location": "/datasources/restfuldatasource/#restful-data-sources", 
            "text": "RESTful Data Sources are collections of data are fetched via HTTP/HTTPS. Since it follows the standard Data Source protocol, data from the repository can be used directly in UI. Data can be persisted locally when fetched from a REST service to provide an offline experience. Data persisted can also be expired based on a time validity period.   Note  As of the last version of this document, Data Sources can only be defined using a JSON editor. It is assumed that the reader understands the basics of JSON structure to be able to edit the data source. A better targeted Data Source editor is being developed to make creation of Data Sources simpiler.", 
            "title": "RESTful Data Sources"
        }, 
        {
            "location": "/datasources/restfuldatasource/#initdata-object-attributes", 
            "text": "The  initdata  object for RESTful Data Sources includes the following attributes:     Attribute  Type  Description      baseurl  string  The a URL that is to provide a basis for each of the requests in this datasource. Requests that use this simply provide a path element to append to this base URL. Alternatively, each request can supply its own full requesturl attribute.    auth  object  The authentication method and details necessary to authorize a client for access to the requests defined in this datasource. The details of the auth object are specified according to the value of the type attribute. See  Authentication  for more information", 
            "title": "InitData Object Attributes"
        }, 
        {
            "location": "/datasources/restfuldatasource/#request-object-attributes", 
            "text": "In addition to the standard  Request Object Attributes  provided by Data Sources, RESTful Data Sources have a additional attributes used for data and parameters.     Attribute  Type  Description      attributes  object  (OPTIONAL) - An object that defines additional attributes for the request. See  Attributes Object  for more information    method  string  This is the HTTP method to perform for this request. Valid values are \"GET\", \"PUT\", \"POST\", \"DELETE\" and \"PATCH\"    path  string  This attribute defines a path extension to add to the baseurl rather than replacing it completely with the url. This path may contain \"parameterized\" path elements. These elements are begin with a \":\" character and will be replaced by associated values supplied in the args passed to the request. For example the path \"/users/:id\" would have \":id\" replaced with the value from the field \"id\" passed in the args. Note:  path  and  url  are mutually exclusive.    url  string  This attribute defines a fully qualified URL for this request rather than using the baseurl and path. This url itself may contain \"parameterized\" path elements. These elements are begin with a \":\" character and will be replaced by associated values supplied in the args passed to the request. For example the url \"https://servername/users/:user\" would have \":user\" replaced with the value from the field \"user\" passed in the args. Note:  path  and  url  are mutually exclusive.    args  object  This is an args object as described in the general datasource attributes. For a RESTful datasource these are processed in a few ways after merging these with the args passed in from either the event action or data link. The args fields will first be matched against any \"parameterized\" path elements in the constructed request URL (see path and url above). Any remaining fields not matched in the URL path will either be used to construct query parameters for a GET or DELETE request or will be posted into the body of the request for a PUT or POST request.    postschema  object  This is a  schema  object as described in the general datasource specification. This schema is used to validate the type and structure of the data that will be included in the body of a POST or PUT request.    failFields  object  If a request results in a failure indicated by its schema this object can contain a message and a detail field that will be used to construct an error object that may be used in place of the actual data results. Each of these fields is a string value that contains a \"dotted-path\" to a field within the returned data. For example the message may be found in \".response.body.error.msg\".    errorSchema  object  If the request results in failure due to the HTTP method returning an error code. This object may contain a schema in the standard datasource schema format that will be used to validate and parse any data returned in the error result.    errorFields  object  If the request results in a failure due to the HTTP method returning an error code and an errorSchema is provided, this object may contain a message and a detail field that will be used to construct an error object. Each of these fields is a string value that contains a \"dotted-path\" to a field within the returned data. For example the detail may be found in \".error.description\".    async  boolean  If this field is present and set to TRUE then it indicates that this request may utilize asynchronous polling for results. If the reqest results in a \"partial\" value as indicated by its schema then a TRUE value here will cause the request to poll for a complete result if there is an associated polling object as well.    polling  object  This is an object that defines how the polling for results will be performed. It is primarily controlled by a  delay  field that specifies a number of seconds between issuing subsequent poll requests for a full result. It can also have a  count  field which specifies the maximum number of poll attempts it will make. If the request continues to return partial (i.e. non-success or failure) results then the polling will continue until it reaches the count. The polling object may also contain overrides for many of the other attributes in the initial request including the  method ,  path ,  url ,  postschema , or the  schema . Finally, it is possible to have the  url  for polling come from the results via a  urlfield  attribute that specifies a \"dotted-path\" into the results.", 
            "title": "Request Object Attributes"
        }, 
        {
            "location": "/datasources/restfuldatasource/#attributes-object", 
            "text": "The  request  object can have additional attributes that control how its data is handled.     Attribute  Type  Description      persist  boolean  (OPTIONAL) - Whether or not data retrieved from the REST service for a request is persisted locally. If this attribute not specified, no data will be persisted and network connectivity will be required to use any data from the request.    validity  number  (OPTIONAL) - When data is persisted, this value indicates how long that data should be considered valid. This allows for requests to be defined where it will trigger a new request if the data no longer valid versus always fetching data from the service. This value is the number of seconds to consider the data valid from the time it was persisted    refresh  number  (OPTIONAL) - This value will create a polling type of request once a the request has been triggered by an event in the client. Use this value only in the case where the client needs to poll a request on a service based on a time interval. This value is the number of seconds to wait between requests.    encrypt  boolean  (OPTIONAL) - When  persist  is set to  true , setting  encrypt  to  true  will encrypt the data persisted on the client device.", 
            "title": "Attributes Object"
        }, 
        {
            "location": "/datasources/restfuldatasource/#authentication", 
            "text": "The  auth  object defines the form of authentication to use (if any) when accessing the data source requests. Most attributes of the  auth  object are dependent on the type of auth. However, the following attributes are defined at the top level.     Attribute  Type  Description      type  string  This is a string that defines the authentication method for access to the requests defined in this datasource. The details of many of the fields in the auth object are defined by the value of the  type  attribute.  (See  Auth Types  for more information)    url  string  (OPTIONAL) - This attribute defines a full URL that will override the baseurl construction and be used directly as the URL for authentication. Certain auth types may require this element.    path  string  (OPTIONAL) - This attribute defines a path extension that is appended to the baseURL rather than replacing it completely with the auth  url .    servicename  string  (OPTIONAL) - This is a string identifying the name of the service that will be used for this authorization option. It may be necessary for the client to have pre-registered with this service and to have information such as a username, password or client_id.    args  object  (OPTIONAL) - Defines arguments to be passed to the authentication request. These are used depending on the type of the authentication. Args can be static values or data links. Args will be used to populate values in a  loginschema  or as parameters to a  url .     The remainder of the attributes in the auth object are dependent on the type of auth object that is specified.", 
            "title": "Authentication"
        }, 
        {
            "location": "/datasources/restfuldatasource/#auth-types", 
            "text": "These are the current authentication types supported by RESTful Data Sources. Additional types can be created by supplying a custom string for the  type  and then by creating custom subclasses of the  P2UXRestDataSource  class in client code.     Type  Description      Basic  The authentication credentials are provided using the standard HTTP Basic authentication protocol specified in RFC 2617 with the credentials supplied in the HTTP \u201cAuthorization\u201d header field.    Login  The authentication credentials are provided by \u201clogin\u201d credentials. The default is username and password, but the exact format is defined via a standard REST POST request specification and can include other parameters.    TokenLogin  The authentication credentials are provided by \"login\" credentials and the result of the login is a token that can be used with request data for authentication. This is similar to OAuth, but is more freeform to accomodate specific server implementations.    OAuth  The authentication credentials are provided in accordance with RFC 6749 (aka the OAuth 2.0 specification). The specific type of authorization is determined by the  granttype  attribute.", 
            "title": "Auth Types"
        }, 
        {
            "location": "/datasources/restfuldatasource/#basic-auth", 
            "text": "Attribute  Type  Description      username  string  The username to be sent in the Authorization header field. If this is not present, the application will need to supply this information from another source. Typically this is defined as a data link to prompt the user. Its the responsibility of the application using the data source to respond to the request for the information by triggering UI and responding with the provided information. (See  Data Source - Requesting User Information )    password  string  The password to be sent in the Authorization header field. If this is not present, the application will need to supply this information from another source. Typically this is defined as a data link to prompt the user. Its the responsibility of the application using the data source to respond to the request for the information by triggering UI and responding with the provided information. (See  Data Source - Requesting User Information )    realm  string  (OPTIONAL) - The authentication \u201crealm\u201d to use for this server. This should contain the value that would normally be included in the WWW-Authenticate HTTP header from a web server in a 401 response message.     Example Basic Auth:  {\n   initdata : {\n     baseurl :  http://www.testme.com ,\n     auth : {\n       type :  Basic ,\n       path :  login ,\n       username :  thatguy ,\n       password :  123Happy \n    }\n  }\n  ...\n}", 
            "title": "Basic Auth"
        }, 
        {
            "location": "/datasources/restfuldatasource/#login-auth", 
            "text": "Attribute  Type  Description      request  string  A standard REST request object specifying the format, method and either path or full requesturl. See REST request specification below. In most cases the request will be a \u201cPOST\u201d method.    loginschema  object  The schema specification in the REST  schema  format defined below for the data required to log into the service. The login auth request may contain alias fields if the submitted data in the request has different names than the fields with semantic meaning to the application. Supported Attributes: Attribute Type Description username string Tells the client which field (if any) represents the login username. If there is a \u201cusername\u201d field in the schema this is not needed. password string Tells the client which field (if any) represents the login password. If there is a \u201cpassword\u201d field in the schema this is not needed    schema  object  Contains a schema specification in the REST schema format defined below. It specifies the format of the data that is returned from the login request.    persist  array  (OPTIONAL) - defines data from the \"schema\" that should be persisted for further use in subsequent requests. The values returned from the successful login are stored encrypted and then injected into requests depending on the  use  defined for each parameter. Values that don't need to be used as part of requests don't need to be included in the persist array. If no data needs to be persisted for use, then this object can be omitted entirely. Each item defined in the persist array corresponds to a value in the schema for the login and how that value should be used for subsequent requests. All of the specified values are required. (See  Persist Attributes )     Example Login Auth  {\n   initdata : {\n     baseurl :  http://sampleservice.com/ ,\n     auth : {\n       type :  Login ,\n       request : {\n         format :  JSON ,\n         method :  POST ,\n         path :  login \n      },\n       loginschema : {\n         type :  Object ,\n         item : {\n           username :  name ,\n           name : {\n             type :  String \n          },\n           password : {\n             type :  String \n          }\n        }\n      },\n       schema : {\n         type :  Object ,\n         item : {\n           result : {\n             type :  Number \n          }\n        },\n         success : {\n           result : 0\n        }\n      }\n    }\n  }\n  ...\n}", 
            "title": "Login Auth"
        }, 
        {
            "location": "/datasources/restfuldatasource/#tokenlogin-auth", 
            "text": "TokenLogin uses standard login credentials but can handle a token returned when the login is successful. This token is applied to requests depending on the server requirements. It also can support refreshing the token if that is supported.     Attribute  Type  Description      refresh  object  An object that defines how to refresh the token when it expires. The format of this follows the  auth  object format with some additional parameters (See  Refresh Attributes )    loginschema  object  The schema specification in the REST  schema  format defined below for the data required to log into the service. The login auth request may contain alias fields if the submitted data in the request has different names than the fields with semantic meaning to the application. Supported Attributes: Attribute Type Description username string Tells the client which field (if any) represents the login username. If there is a \u201cusername\u201d field in the schema this is not needed. password string Tells the client which field (if any) represents the login password. If there is a \u201cpassword\u201d field in the schema this is not needed    schema  object  Contains a schema specification in the REST schema format defined below. It specifies the format of the data that is returned from the login request.    persist  array  (OPTIONAL) - defines data from the \"schema\" that should be persisted for further use in subsequent requests. The values returned from the successful login are stored encrypted and then injected into requests depending on the  use  defined for each parameter. Values that don't need to be used as part of requests don't need to be included in the persist array. If no data needs to be persisted for use, then this object can be omitted entirely. Each item defined in the persist array corresponds to a value in the schema for the login and how that value should be used for subsequent requests. All of the specified values are required. (See  Persist Attributes )     Example TokenLogin Auth \nThis example shows using token login authentication with a  Firebase  application. The  refresh_token  in the  refresh  object refers to cached authentication values via a link of type 16 (auth value). The  key  refers to a static value in the application named  authkey . The args in the  refresh  object are used to populate the  loginschema  for the refresh request.  {\n   initdata : {\n     auth : {\n       refresh : {\n         args : {\n           key : {\n             var :  authkey ,\n             type : 14\n          },\n           refresh_token : {\n             var :  refreshToken ,\n             type : 16\n          },\n           grant_type :  refresh_token \n        },\n         persistpaths : {\n           refresh_token :  refreshToken ,\n           id_token :  idToken ,\n           expires_in :  expiresIn \n        },\n         loginschema : {\n           type :  Object ,\n           item : {\n             grant_type : {\n               type :  String \n            },\n             refresh_token : {\n               type :  String \n            }\n          }\n        },\n         schema : {\n           type :  Object ,\n           item : {\n             expires-in : {\n               type :  String \n            },\n             refresh_token : {\n               type :  String \n            },\n             project_id : {\n               type :  String \n            },\n             user_id : {\n               type :  String \n            },\n             id_token : {\n               type :  String \n            },\n             token_type : {\n               type :  String \n            }\n          }\n        },\n         url :  https://securetoken.googleapis.com/v1/token?key=:key \n      },\n       type :  TokenLogin ,\n       servicename :  sample ,\n       url :  https://www.googleapis.com/identitytoolkit/v3/relyingparty/verifyPassword?key=:key ,\n       request : {\n         format :  JSON ,\n         method :  POST \n      },\n       persist : [\n        {\n           path :  appId ,\n           field :  X-HTTP-AppId ,\n           use :  header ,\n           val : {\n             var :  authkey ,\n             type : 14\n          }\n        },\n        {\n           method :  POST ,\n           field :  idToken ,\n           path :  idToken ,\n           use :  payload \n        },\n        {\n           method :  GET ,\n           field :  auth ,\n           path :  idToken ,\n           use :  parameter \n        },\n        {\n           path :  refreshToken ,\n           use :  refreshtoken \n        },\n        {\n           path :  expiresIn ,\n           use :  expires \n        },\n        {\n           path :  idToken ,\n           use :  accesstoken \n        }\n      ],\n       args : {\n         key : {\n           var :  authkey ,\n           type : 14\n        },\n         email : {\n           var :  email ,\n           type : 15\n        },\n         password : {\n           var :  password ,\n           type : 15\n        },\n         returnSecureToken : true\n      },\n       loginschema : {\n         type :  Object ,\n         item : {\n           returnSecureToken : {\n             type :  Boolean \n          },\n           password : {\n             type :  String \n          },\n           email : {\n             type :  String \n          }\n        }\n      },\n       schema : {\n         type :  Object ,\n         item : {\n           expiresIn : {\n             type :  String \n          },\n           refreshToken : {\n             type :  String \n          },\n           registered : {\n             type :  Boolean \n          },\n           idToken : {\n             type :  String \n          },\n           displayName : {\n             type :  String \n          },\n           email : {\n             type :  String \n          },\n           localId : {\n             type :  String \n          },\n           kind : {\n             type :  String \n          }\n        }\n      }\n    },\n     baseurl :  https://sampleapp.firebaseio.com/ \n  }\n  ...\n}", 
            "title": "TokenLogin Auth"
        }, 
        {
            "location": "/datasources/restfuldatasource/#oauth-auth", 
            "text": "The OAuth authentication mode can provide a variety of different ways to authenticate the user depending on the service requirements and client capabilities. The specific authentication mechanism is controlled by a \"granttype\" setting. For OAuth the auth url (or baseurl + auth path) is a mandatory attribute. The authorization is performed by submitting these parameters to the auth url in exchange for an \u201cAuthorization Token\u201d which will be sent to the service when each of the requests are made. The URL will have query parameters appended to it by the client based on the specific granttype protocol being performed. Some of these required parameters may come from the client having to be registered with a specific service. These values will need to be embedded into the client code or obtained through application-specific business logic.   For certain OAuth granttype values, the client will utilize an embedded web-browser as the first step in the protocol before submitting the token request directly over HTTP. When this is the case, it is usually because the client is being authenticated on behalf of a user on a third-party service (e.g Facebook). In this case, a separate code_url is used to construct the URL sent to the browser. Along with the required parameters this includes a redirect_uri where the service will redirect the browser once the user authorizes the client. This url should generally be a \"localhost\" url as the client will use this to retreive an Authorization Code that it will then submit to the authurl in exchange for the Authorization Token     Attribute  Type  Description      grant  string  One of the 3 possible \u201cauthorization grant\u201d types supported by the OAuth 2.0 protocol. Possible Values: Value Description AuthCode This indicates that the client should initiate a request for an \u201cAuthorization Code\u201d. The client will be launch in an embedded browser with the codeurl (see below) in order to allow the user to authenticate the client to the service using their credentials. The client will append information to the URL obtained when registering for the service. This includes a CLIENT_ID and a REDIRECT_URI. In response to this request, the client will  submit the returned code to the authurl in order to redeem it for an \u201cAuthorization Token\u201d. Password This indicated that client should directly request an \u201cAuthorization Token\u201d by providing a username and password pair. This must be supplied by the client via a user prompt or some other internal mechanism. It will also need to have a CLIENT_ID. The client will need to complete the authurl as well in this case by appending the USERNAME, PASSWORD and CLIENT_ID parameters. Client This indicates that the client should directly request an \u201cAuthorization Token\u201d by providing its pre-registered client credentials in the form of a CLIENT_ID and CLIENT_SECRET. This will be supplied in the HTTP Authorization header field using the \u201cBasic\u201d authentication format.    code_url  string  Used for a granttype of \u201cAuthCode\u2019. it specifies a URL to that will be opened in an embedded web browser in order to obtain the Authorization Code.    redirect_uri  string  Used for a granttype of \"AuthCode\". This will be appended to the codeurl so the service may redirect the embedded browser and supply the Authorization Code to the client once the user has authorized it.", 
            "title": "OAuth Auth"
        }, 
        {
            "location": "/datasources/restfuldatasource/#client-id-and-secret", 
            "text": "The client id and secret can be provided to OAuth authentication using Static Values in an Application specification via the  args  object for the auth request. This mechanism allows for a RESTful Data source to be generic in its definition and reusable by different applications as the application provides the instance values. (See Static Values for more information).   Example OAuth Auth \nIn this example, the  client_id  and  client_secret  values would be defined in the application as static values and populated by the PRL at runtime.  {\n   initdata : {\n     baseurl :  https://api.instagram.com/ ,\n     auth : {\n       servicename :  Instagram ,\n       type :  OAuth ,\n       granttype :  AuthCode ,\n       url :  https://api.instagram.com/oauth2/token ,\n       code_url :  https://api.instagram.com/oauth/authorize/ ,\n       redirect_uri :  http://localhost ,\n       args : {\n         client_id :{\n           type :14,\n           val : instagram_client_id \n        },\n         client_secret :{\n           type :14,\n           val : instagram_client_secret \n        }\n      }\n    }\n  }\n  ...\n}", 
            "title": "Client ID and Secret"
        }, 
        {
            "location": "/datasources/restfuldatasource/#persist-attributes", 
            "text": "TokenLogin  and  Login  authentication types can provide a  persist  array that defines how values returned from a successful login are to be cached securely on the client device and used in requests.     Attribute  Type  Description      path  string  A path to the value in the response. Supports dotted notation to navigate through object heirarchy (e.g. \"results.token\")    use  string  Describes the use of the value with regards to inclusion in requests for the data source. Possible Values: Value Description payload the value is placed in the payload (body) of the request. header The value is included in the header of the request. parameter The value is passed as a query parameter to the request. expires The value is used to determine the expiration of any authentication refreshtoken If the authentication supports refresh tokens, this indicates which value in the data is the refreshtoken.    field  string  The name of the field to use for the value. When the use of the data is payload or argument, this becomes the key for the value in the key/value pair that is submitted either in the body of or the query parameters for each request. If the use is header, this is the HTTP header field to use when submitting the value with each request    method  string  (OPTIONAL) - the specific method of request that the persist data should be applied to. If no method is specified, the data would be applied to any method of data request. If multiple methods are needed, they can be provided as single value separated by commas. Possible Values: Value GET POST PUT DELETE", 
            "title": "Persist Attributes"
        }, 
        {
            "location": "/datasources/restfuldatasource/#data-schema", 
            "text": "All requests require a schema object that defines the structure of the data returned for the request.  This example shows a request with an array collection of \"user\" objects. The request is called  users  in a data source named  Service Data .  {\n   name : {\n     en_US :  Service Data \n  },\n   type :  REST ,\n   systemtype :  service_data ,\n   requests : {\n     users : {\n       request : {\n         version : 1\n      },\n       schema : {\n         type :  Array ,\n         index :  ident ,\n         item : {\n           type :  Object ,\n           item : {\n             ident : {\n               type :  String \n            },\n             firstname : {\n               type :  String \n            },\n             lastname : {\n               type :  String \n            },\n             picture : {\n               type :  String \n            },\n             password : {\n               type :  String \n            },\n             email : {\n               type :  String \n            }\n          }\n        }\n      }\n    }\n  }\n}", 
            "title": "Data Schema"
        }, 
        {
            "location": "/datasources/restfuldatasource/#examples", 
            "text": "", 
            "title": "Examples"
        }, 
        {
            "location": "/datasources/restfuldatasource/#twitter-using-oauth", 
            "text": "This example specification uses Twitter's RESTful API with OAuth as the authentication type. It defines a request called  search  that takes a search parameter as an argument. In this example, the argument has a default value supplied by the spec. If the application doesn't provide the argument at runtime as part of the request, this value would be used as the default argument. For authentication, the  client_id  and  client_secret  values used for OAuth are provided by the application using  Static Values . Since  persist  is not defined in the attributes of the request, the results of the request would not be saved on the client device for offline use.  {\n   name : {\n     en_US :  Twitter \n  },\n   type :  REST ,\n   systemtype :  twitter ,\n   initdata : {\n     auth : {\n       granttype :  Client ,\n       type :  OAuth ,\n       servicename :  Twitter ,\n       path :  oauth2/token ,\n       args : {\n         client_id : {\n           type : 14,\n           var :  twitter_client_id \n        },\n         client_secret : {\n           type : 14,\n           var :  twitter_client_secret \n        }\n      }\n    },\n     baseurl :  https://api.twitter.com \n  },\n   requests : {\n     search : {\n       schema : {\n         item : {\n           search_metadata : {\n             item : {\n               since_id_str : {\n                 type :  String \n              },\n               max_id_str : {\n                 type :  String \n              },\n               query : {\n                 type :  String \n              },\n               completed_in : {\n                 type :  Number \n              },\n               count : {\n                 type :  Number \n              },\n               next_results : {\n                 type :  String \n              },\n               refresh_uri : {\n                 type :  String \n              },\n               since_id : {\n                 type :  Number \n              },\n               max_id : {\n                 type :  Number \n              }\n            },\n             type :  Object \n          },\n           statuses : {\n             item : {\n               item : {\n                 user : {\n                   item : {\n                     screen_name : {\n                       type :  String \n                    },\n                     friends_count : {\n                       type :  Number \n                    },\n                     statuses_count : {\n                       type :  Number \n                    },\n                     description : {\n                       type :  String \n                    },\n                     time_zone : {\n                       type :  String \n                    },\n                     followers_count : {\n                       type :  Number \n                    },\n                     lang : {\n                       type :  String \n                    },\n                     utc_offset : {\n                       type :  Number \n                    },\n                     url : {\n                       type :  String \n                    },\n                     id_str : {\n                       type :  String \n                    },\n                     id : {\n                       type :  Number \n                    },\n                     location : {\n                       type :  String \n                    },\n                     created_at : {\n                       type :  String \n                    },\n                     profile_image_url_https : {\n                       type :  String \n                    },\n                     profile_image_url : {\n                       type :  String \n                    },\n                     name : {\n                       type :  String \n                    }\n                  },\n                   type :  Object \n                },\n                 in_reply_to_screen_name : {\n                   type :  String \n                },\n                 in_reply_to_status_id_str : {\n                   type :  String \n                },\n                 in_reply_to_status_id : {\n                   type :  Number \n                },\n                 retweet_count : {\n                   type :  Number \n                },\n                 retweeted : {\n                   type :  Boolean \n                },\n                 id_str : {\n                   type :  String \n                },\n                 id : {\n                   type :  Number \n                },\n                 text : {\n                   type :  String \n                },\n                 created_at : {\n                   type :  String \n                },\n                 truncated : {\n                   type :  Boolean \n                },\n                 favorited : {\n                   type :  Boolean \n                },\n                 coordinates : {\n                   item : {\n                     type : {\n                       type :  String \n                    },\n                     coordinates : {\n                       item : {\n                         type :  Number \n                      },\n                       type :  Array \n                    }\n                  },\n                   type :  Object \n                }\n              },\n               type :  Object \n            },\n             type :  Array \n          }\n        },\n         type :  Object \n      },\n       request : {\n         args : {\n           q :  #beef \n        },\n         format :  JSON ,\n         method :  GET ,\n         path :  1.1/search/tweets.json ,\n         version :1\n      }\n    }\n  }\n}   Creating a New Data Source  For Steps to create a new Data Source in  Builder , refer to the  Data Sources  documentation   Last Updated: Dec. 27, 2017", 
            "title": "Twitter using OAuth"
        }
    ]
}